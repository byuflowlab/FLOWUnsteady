<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Maneuver Definition · FLOWUnsteady</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FLOWUnsteady logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Intro</a></li><li><a class="tocitem" href="../../installation/general/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Simple Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../wing-4p2aoa/">Basics</a></li><li><a class="tocitem" href="../wing-aoasweep/">AOA Sweep</a></li></ul></li><li><a class="tocitem" href="../tetheredwing/">Tethered Wing</a></li><li><a class="tocitem" href="../heavingwing/">Heaving Wing</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Propeller</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../propeller-J040/">Basics</a></li><li><a class="tocitem" href="../propeller-jsweep/"><span>$J$</span> Sweep</a></li><li><a class="tocitem" href="../propeller-quasisteady/">Quasi-Steady Solver</a></li><li><a class="tocitem" href="../propeller-incidence/">Incidence Sweep</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Rotor in Hover</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../rotorhover-aero/">Variable Fidelity</a></li><li><a class="tocitem" href="../rotorhover-fdom/">Fluid Domain</a></li><li><a class="tocitem" href="../rotorhover-acoustics/">Aeroacoustics</a></li><li><a class="tocitem" href="../rotorhover-quasisteady/">Quasi-Steady Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Blown Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../blownwing-aero/">Aerodynamic Solution</a></li><li><a class="tocitem" href="../blownwing-asm/">Actuator Surface Model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox" checked/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">eVTOL Aircraft</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../vahana-vehicle/">Vehicle Definition</a></li><li class="is-active"><a class="tocitem" href>Maneuver Definition</a></li><li><a class="tocitem" href="../vahana-monitor/">Monitors Definitions</a></li><li><a class="tocitem" href="../vahana-run/">Run Simulation</a></li></ul></li></ul></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../theory/rvpm/">Reformulated VPM</a></li><li><a class="tocitem" href="../../theory/convergence/">Convergence</a></li><li><a class="tocitem" href="../../theory/validation/">Validation</a></li><li><a class="tocitem" href="../../theory/publications/">Publications</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">API Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">(1) Vehicle Definition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowunsteady-vehicle-types/">Vehicle types</a></li><li><a class="tocitem" href="../../api/flowunsteady-vehicle-components/">Generating components</a></li><li><a class="tocitem" href="../../api/flowunsteady-vehicle-asm/">Actuator surface model</a></li></ul></li><li><a class="tocitem" href="../../api/flowunsteady-maneuver/">(2) Maneuver Definition</a></li><li><a class="tocitem" href="../../api/flowunsteady-simulation/">(3) Simulation Definition</a></li><li><a class="tocitem" href="../../api/flowunsteady-monitor/">(4) Monitors Definitions</a></li><li><a class="tocitem" href="../../api/flowunsteady-run/">(5) Run Simulation</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">(6) Viz and Postprocessing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-fdom/">Fluid Domain</a></li><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-noise/">Aeroacoustic Noise</a></li><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-misc/">Miscellaneous</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-7" type="checkbox"/><label class="tocitem" for="menuitem-7-7"><span class="docs-label">Extras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-7-1"><span class="docs-label">FLOWVPM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowvpm-particle/">Particle Field</a></li><li><a class="tocitem" href="../../api/flowvpm-uj/">UJ Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-viscous/">Viscous Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-relaxation/">Relaxation Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-sfs/">SFS Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-time/">Time Integration</a></li><li><a class="tocitem" href="../../api/flowvpm-utils/">Utilities</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">eVTOL Aircraft</a></li><li class="is-active"><a href>Maneuver Definition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Maneuver Definition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWUnsteady/blob/master/docs/src/examples/vahana-maneuver.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="vahanamaneuver"><a class="docs-heading-anchor" href="#vahanamaneuver">Maneuver Definition</a><a id="vahanamaneuver-1"></a><a class="docs-heading-anchor-permalink" href="#vahanamaneuver" title="Permalink"></a></h1><p>In this section we define a function that generates the eVTOL transition maneuver (a <a href="../../api/flowunsteady-maneuver/#FLOWUnsteady.KinematicManeuver"><code>uns.KinematicManeuver</code></a> object). This maneuver object contains the non-dimensional velocity and attitude of the aircraft over a non-dimensional time (where <span>$t=0$</span> is the beginning of the maneuver and <span>$t=1$</span> is the end), which prescribes the kinematics of the vehicle. It also contains the control inputs for the aircraft over time: tilting angles for each tilting system and RPM for each rotor system shown below.</p><table>
    <tr>
        <td>
            <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-tiltingsystems00.png" alt="Pic here" style="width:90%;"/>
        </td>
        <td>
            <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-rotorsystems00.png" alt="Pic here" style="width:90%;"/>
        </td>
    </tr>
</table><p>The maneuver here defined contains five stages:</p><ol><li>Takeoff, climb, hover</li><li>Hover <span>$\rightarrow$</span> cruise transition (powered lift to wing-borne flight)</li><li>Cruise</li><li>Cruise <span>$\rightarrow$</span> hover transition (wing-borne flight to powered lift)</li><li>Hover, descend, landing</li></ol><p>Since the vehicle kinematics and control inputs used in the maneuver definition are non-dimensional, the maneuver can be performed as fast or as slow as desired when we define the total time, reference velocity, and reference RPM of <a href="../../api/flowunsteady-simulation/#FLOWUnsteady.Simulation"><code>uns.Simulation</code></a> later in the next section, without needing to change the maneuver definition shown here.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    Generates the eVTOL transition maneuver of Vahana aircraft
&quot;&quot;&quot;
function generate_maneuver_vahana(; disp_plot=false,    # If true, it will display a plot of the maneuver
                                    add_rotors=true,    # Whether to add rotors contorl inputs to the maneuver
                                    V0=0.0001           # Initial non-dimensional velocity (slightly different than zero to avoid instabilities)
                                    )

    # NOTE: The following parameters are non-dimensional and scaled between 0
    #       and 1. Here, t=0 is the beginning of the maneuver and t=1 is the end.

    # Define end time of each stage
    #  Stage 1: [0,  t1] -&gt; Take off
    #  Stage 2: [t1, t2] -&gt; Transition
    #  Stage 3: [t2, t3] -&gt; Cruise
    #  Stage 4: [t3, t4] -&gt; Transition
    #  Stage 5: [t4, 1 ] -&gt; Landing
    t1, t2, t3, t4 = 0.2, 0.3, 0.5, 0.6

    # Target velocity at each stage (ratio of cruise velocity)
    V1 = 0.25
    V2 = 0.10
    V3 = 1.00
    V4 = V2
    V5 = 0.5*V1

    # Target RPM at each stage (ratio of hover RPM)
    RPM1 = 1.10
    RPM2 = 1.50
    RPM3 = 0.75
    RPM3_stacked = 2/600
    RPM4 = 1.00
    RPM5 = 0.90

    r_RPMh_stup = 3.50             # Ratio between stacked and main rotor RPM in hover
    r_RPMh_tw = 0.75               # Ratio between tandem and main rotor RPM in hover

    # NOTE: -x is in the direction of flight and +z is climb with ground at z=0


    ############################################################################
    # AIRCRAFT VELOCITY
    ############################################################################
    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the
        non-dimensional velocity vector of the aircraft at that instant.
    &quot;&quot;&quot;
    function Vaircraft(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            # Weibull acceleration to target climb
            if t&lt;t1/2
                val = t / (t1/2)
                Vz = V0 + V1*(1-exp(-(2*val)^5))

            # Weibull deceleration to hover
            else
                val = 1 - (t-t1/2) / (t1/2)
                Vz = V1*(1-exp(-(2*val)^5))
            end

            return [0, 0, Vz]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2

            # Weibull acceleration to cruise
            val = 1.5 * (t-t1) / (t2-t1) + 0.25
            Vx = V3*(1-exp(-(val)^5))

            # Slight drop during transition
            val = (1/0.8) * (t-t1) / (t2-t1)
            Vz = 0.5 * (5 * val^4 * exp(-val^5))
            Vz = 0.2*V3 * Vz

            return [-Vx, 0, -Vz]

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3

            return [-V3, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4

            # Weibull deceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            Vx = V3*(1-exp(-(val)^5))

            # Slight climb during transition
            val = 2.0 * (t-t3) / (t4-t3)
            Vz = 0.5 * (5 * val^4 * exp(-val^5))
            Vz = 0.2*V3 * Vz

            return [-Vx, 0, Vz]

        # ------------ LANDING -------------------------------------------------
        else

            # Weibull acceleration to target descend
            if (t-t4)&lt;(1-t4)*0.35
                val = (t-t4) / ((1-t4)*0.35)
                Vz = V5*(1-exp(-(2*val)^5))
            # Weibull deceleration to hover
            else
                val = 1 - ((t-t4) - (1-t4)*0.35) / ((1-t4)*(1-0.35))
                Vz = V0 + V5*(1-exp(-(2*val)^10))
            end

            return [0, 0, -Vz]

        end
    end


    ############################################################################
    # AIRCRAFT ANGLES
    ############################################################################
    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the attitude
        of the aircraft. The attitude is a vector indicating the angle of the
        vehicle frame with respect to each global axis.
    &quot;&quot;&quot;
    function angleaircraft(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            return [0, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2
            # Slightly pitching down during transition
            val = 1.5 * (t-t1) / (t2-t1)
            val3 = 1.5*val
            val3 = (val3)^(val3 &lt; 1 ? 3 : 1.5)
            angle_aircraft = -15*(1.5/0.75 * val3^0.5 * exp(-(val3^1.5)))
            return [0, angle_aircraft, 0]

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3
            return [0, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4
            # Weibull deceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            # Slight climb during transition
            val = 2.0 * (t-t3) / (t4-t3)
            angle_aircraft = 15 * 0.5 * (5 * val^4 * exp(-val^5))
            return [0, angle_aircraft, 0]

        # ------------ LANDING -------------------------------------------------
        else
            return [0, 0, 0]
        end
    end


    ############################################################################
    # CONTROL INPUT: TILTING SYSTEMS
    ############################################################################
    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns a vector
        with the angles of the main-wing system (in degrees) relative to the
        aircraft frame.

        This tilting system is made out of the tip-mounted tiltrotors on the
        main wing and winglets.
    &quot;&quot;&quot;
    function angle_main(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            # Tiltrotors pointing up
            return [0, 90, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2

            # Tilt forward to cruise position
            val = 1.5 * (t-t1) / (t2-t1)
            val2 = val - 0.00
            angle = 90 - 90*(1-exp(-(val2)^6))
            return [0, angle, 0]

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3

            # Tiltrotors pointing forward in propeller mode
            return [0, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4

            # Tilt back to hover position
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            angle = 90 - 90*(1-exp(-(val)^5))
            return [0, angle, 0]

        # ------------ LANDING -------------------------------------------------
        else
            # Tiltrotors pointing up
            return [0, 90, 0]
        end
    end

    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns a vector
        with the angles of the tandem-wing system (in degrees) relative to the
        aircraft frame.

        This tilting system is made out of the tandem wing and rotors.
    &quot;&quot;&quot;
    function angle_tandem(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            # System pointing up
            return [0, 90, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2

            # Tilt forward to cruise position
            val = 2.0 * (t-t1) / (t2-t1)
            val1 = val + 0.25
            angle = 90 - 90*(1-exp(-(val1)^5))
            return [0, angle, 0]

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3

            # System pointing forward in cruise mode
            return [0, 0, 0]

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4

            # Tilt back to hover position
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            angle = 90 - 90*(1-exp(-(val)^5))
            return [0, angle, 0]

        # ------------ LANDING -------------------------------------------------
        else
            # System pointing up
            return [0, 90, 0]
        end
    end





    ############################################################################
    # ROTORS RPM
    ############################################################################
    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the RPM of
        main-wing tiltrotors normalized by the hover RPM.
    &quot;&quot;&quot;
    function RPM_main(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            # Weibull acceleration to target climb
            if t&lt;t1/2
                val = t / (t1/2)
                RPM_w = RPM1*(1.05-exp(-(5*val)^2))

            # Weibull deceleration to hover
            else
                val = 1 - (t-t1/2) / (t1/2)
                RPM_w = 1.0 + (RPM1-1.0)*(1-exp(-(2*val)^5))
            end

            return RPM_w

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2

            # Increase RPM to sustain forward flight and hover
            if (t-t1)&lt;(t2-t1)*0.25
                val = (t-t1)/((t2-t1)*0.25)
                RPM_w = 1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5))

            # Decrease RPM as tiltrotors transition to propeller mode
            else
                val = 1 - ((t2-t)/(t2-t1)-0.25) / (1-0.25)
                RPM_w = RPM2 + (RPM3-RPM2)*(1-exp(-(1.1*val)^5))
            end

            return RPM_w

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3

            # Propeller mode
            RPM_w = RPM3
            return RPM_w

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4

            # Weibull acceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            RPM_w = RPM4 + (RPM3-RPM4)*(1-exp(-(val)^3))
            return RPM_w

        # ------------ LANDING -------------------------------------------------
        else

            # Weibull deceleration to target descend
            if (t-t4)&lt;(1-t4)*0.55
                val = (t-t4) / ((1-t4)*0.55)
                RPM_w = RPM4 + (RPM5-RPM4)*(1-exp(-(3*val)^5))

            # Weibull acceleration to hover
            else
                val = ((t-t4) - (1-t4)*0.55) / ((1-t4)*(1-0.55))
                val = val + 0.60
                RPM_w = RPM5*(3.0*(val)^(3.0-1)*exp(-(val)^5.0))/1.0
            end

            return RPM_w

        end
    end

    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the RPM of
        stacked upper rotors in main wing normalized by the hover RPM.
    &quot;&quot;&quot;
    function RPM_stacked_up(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            # Weibull acceleration to target climb
            if t&lt;t1/5
                val = t / (t1/5)
                RPM_w = RPM1*(1.05-exp(-(5*val)^2))

            # Weibull deceleration to hover
            else
                val = 1 - (t-t1/5) / (1-t1/5)
                RPM_w = 1.0 + (RPM1-1.0)*(1-exp(-(2*val)^5))
            end

            return r_RPMh_stup*RPM_w

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2

            # Increase RPM to sustain forward flight and hover
            if (t-t1)&lt;(t2-t1)*0.65
                val = (t-t1)/((t2-t1)*0.65)
                RPM_tw = r_RPMh_tw*(1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5)))

            # Decrease RPM as it transitions out of powered lift
            else
                val = 1 - (t2-t)/(t2-((t2-t1)*0.65 + t1))
                RPM_tw = r_RPMh_tw*(RPM2 + val*(RPM3_stacked-RPM2))
            end

            return RPM_tw

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3

            # Stopped rotor
            return RPM3_stacked

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4

            # Weibull acceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            RPM_w = RPM4 + (RPM3_stacked-RPM4)*(1-exp(-(val)^3))
            return r_RPMh_stup*RPM_w

        # ------------ LANDING -------------------------------------------------
        else

            # Weibull deceleration to target descend
            if (t-t4)&lt;(1-t4)*0.75
                val = (t-t4) / ((1-t4)*0.75)
                RPM_w = RPM4 + (RPM5-RPM4)*(1-exp(-(3*val)^5))

            # Weibull acceleration to hover
            else
                val = ((t-t4) - (1-t4)*0.75) / ((1-t4)*(1-0.75))
                val = val + 0.60
                RPM_w = RPM5*(3.0*(val)^(3.0-1)*exp(-(val)^5.0))/1.0
            end

            return r_RPMh_stup*RPM_w
        end
    end


    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the RPM of
        stacked lower rotors in main wing normalized by the hover RPM.
    &quot;&quot;&quot;
    function RPM_stacked_low(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1
            return RPM_stacked_up(t)

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2
            return RPM_stacked_up(t)

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3
            return RPM_stacked_up(t)

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4
            return RPM_stacked_up(t)

        # ------------ LANDING -------------------------------------------------
        else
            return RPM_stacked_up(t)
        end
    end

    &quot;&quot;&quot;
        Receives a nondimensional time between 0 and 1, and returns the RPM of
        tandem wing rotors normalized by the hover RPM.
    &quot;&quot;&quot;
    function RPM_tandem(t)

        # ------------ TAKE OFF ------------------------------------------------
        if t&lt;t1

            return r_RPMh_tw*RPM_main(t)

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t2

            # Increases RPM to sustain forward flight and hover
            if (t-t1)&lt;(t2-t1)*0.65
                val = (t-t1)/((t2-t1)*0.65)
                RPM_tw = r_RPMh_tw*(1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5)))

            # Decrease RPM as rotors transition to propeller mode
            else
                val = 1 - (t2-t)/(t2-((t2-t1)*0.65 + t1))
                RPM_tw = r_RPMh_tw*(RPM2 + val*(RPM3-RPM2))
            end

            return RPM_tw

        # ------------ CRUISE --------------------------------------------------
        elseif t&lt;t3

            return r_RPMh_tw*RPM_main(t)

        # ------------ TRANSITION ----------------------------------------------
        elseif t&lt;t4

            # Weibull acceleration to hover
            val = 1.5 * (1 - (t-t3) / (t4-t3))
            RPM_tw = r_RPMh_tw * (RPM4 + (RPM3-RPM4)*(1-exp(-(0.8*val)^8)))
            return RPM_tw

        # ------------ LANDING -------------------------------------------------
        else
            return r_RPMh_tw*RPM_main(t)
        end
    end



    ############################################################################
    # MANEUVER OBJECT
    ############################################################################
    # Angle function of each tilting system
    angle = (angle_main, angle_tandem)

    # RPM function of each rotor system
    if add_rotors
        RPM = (RPM_main, RPM_stacked_up, RPM_stacked_low, RPM_tandem)
    else
        RPM = ()
    end

    # Aircraft velocity and angles (attitude)
    Vvehicle = Vaircraft
    anglevehicle = angleaircraft

    # Define non-dimensional maneuver
    maneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)

    # Plot maneuver for verification purposes
    if disp_plot
        uns.plot_maneuver(maneuver; tstages=[t1, t2, t3, t4])
    end

    return maneuver
end</code></pre><center>
    <br><br>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-kinematics.png" alt="Pic here" style="width:100%;"/>
    <br><br><br><br>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-controls.png" alt="Pic here" style="width:75%;"/>
</center><p>Notice that this plot shows four rotor systems instead of only three. This is because the system of stacked rotors was split into two (all upper stack rotors are grouped together, while all lower stack rotors are also grouped together). This way we could change the index angle of the stacked rotors throughout the simulation by modulating upper and lower RPMs independently. However, for simplicity, in this example we have kept upper and lower RPMs the same.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vahana-vehicle/">« Vehicle Definition</a><a class="docs-footer-nextpage" href="../vahana-monitor/">Monitors Definitions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 6 April 2023 02:38">Thursday 6 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
