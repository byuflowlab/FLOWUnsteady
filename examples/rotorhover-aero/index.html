<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variable Fidelity · FLOWUnsteady</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-B7CBF7WC7L"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B7CBF7WC7L', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FLOWUnsteady logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Intro</a></li><li><a class="tocitem" href="../../installation/general/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Simple Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../wing-4p2aoa/">Basics</a></li><li><a class="tocitem" href="../wing-aoasweep/">AOA Sweep</a></li></ul></li><li><a class="tocitem" href="../tetheredwing/">Tethered Wing</a></li><li><a class="tocitem" href="../heavingwing/">Heaving Wing</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Propeller</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../propeller-J040/">Basics</a></li><li><a class="tocitem" href="../propeller-jsweep/"><span>$J$</span> Sweep</a></li><li><a class="tocitem" href="../propeller-quasisteady/">Quasi-Steady Solver</a></li><li><a class="tocitem" href="../propeller-incidence/">Incidence Sweep</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox" checked/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Rotor in Hover</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Variable Fidelity</a></li><li><a class="tocitem" href="../rotorhover-fdom/">Fluid Domain</a></li><li><a class="tocitem" href="../rotorhover-acoustics/">Aeroacoustics</a></li><li><a class="tocitem" href="../rotorhover-quasisteady/">Quasi-Steady Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Blown Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../blownwing-aero/">Wing-on-Rotor Interactions</a></li><li><a class="tocitem" href="../blownwing-asm/">Actuator Surface Model</a></li><li><a class="tocitem" href="../prowim-aero/">Rotor-on-Wing Interactions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">eVTOL Aircraft</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../vahana-vehicle/">Vehicle Definition</a></li><li><a class="tocitem" href="../vahana-maneuver/">Maneuver Definition</a></li><li><a class="tocitem" href="../vahana-monitor/">Monitors Definitions</a></li><li><a class="tocitem" href="../vahana-run/">Run Simulation</a></li></ul></li><li><a class="tocitem" href="../openvsp-aircraft/">OpenVSP Geometry</a></li></ul></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../theory/rvpm/">Reformulated VPM</a></li><li><a class="tocitem" href="../../theory/convergence/">Convergence</a></li><li><a class="tocitem" href="../../theory/validation/">Validation</a></li><li><a class="tocitem" href="../../theory/publications/">Publications</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">API Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">(1) Vehicle Definition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowunsteady-vehicle-types/">Vehicle types</a></li><li><a class="tocitem" href="../../api/flowunsteady-vehicle-components/">Generating components</a></li><li><a class="tocitem" href="../../api/flowunsteady-vehicle-asm/">Actuator surface model</a></li><li><a class="tocitem" href="../../api/flowunsteady-openvsp/">OpenVSP geometry</a></li></ul></li><li><a class="tocitem" href="../../api/flowunsteady-maneuver/">(2) Maneuver Definition</a></li><li><a class="tocitem" href="../../api/flowunsteady-simulation/">(3) Simulation Definition</a></li><li><a class="tocitem" href="../../api/flowunsteady-monitor/">(4) Monitors Definitions</a></li><li><a class="tocitem" href="../../api/flowunsteady-run/">(5) Run Simulation</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">(6) Viz and Postprocessing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-fdom/">Fluid Domain</a></li><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-noise/">Aeroacoustic Noise</a></li><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-misc/">Miscellaneous</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-7" type="checkbox"/><label class="tocitem" for="menuitem-7-7"><span class="docs-label">Extras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-7-1"><span class="docs-label">FLOWVPM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowvpm-particle/">Particle Field</a></li><li><a class="tocitem" href="../../api/flowvpm-uj/">UJ Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-viscous/">Viscous Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-relaxation/">Relaxation Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-sfs/">SFS Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-time/">Time Integration</a></li><li><a class="tocitem" href="../../api/flowvpm-utils/">Utilities</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Rotor in Hover</a></li><li class="is-active"><a href>Variable Fidelity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variable Fidelity</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWUnsteady/blob/master/docs/src/examples/rotorhover-aero.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="rotorhoveraero"><a class="docs-heading-anchor" href="#rotorhoveraero">Variable Fidelity</a><a id="rotorhoveraero-1"></a><a class="docs-heading-anchor-permalink" href="#rotorhoveraero" title="Permalink"></a></h1><div style="position:relative;padding-top:50%;">
    <iframe style="position:absolute;left:0;top:0;height:80%;width:72%;"
        src="https://www.youtube.com/embed/u9SgYbYhPpU?hd=1"
        title="YouTube video player" frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        allowfullscreen></iframe>
</div><p>While propeller simulations tend to be numerically well behaved, a hover case can pose multiple numerical challenges. The rotation of blades in static air drives a strong axial flow that is solely caused by the shedding of tip vortices. This is challenging to simulate since, in the absence of a freestream, the wake quickly becomes fully turbulent and breaks down as tip vortices leapfrog and mix close to the rotor. Thus, a rotor in hover is a good engineering application to showcase the numerical stability and accuracy of FLOWUnsteady.</p><p>In this example we simulate a DJI rotor in hover, and we use this case to demonstrate some of the advanced features of FLOWUnsteady that make it robust and accurate in resolving turbulent mixing:</p><ul><li><a href="../../theory/rvpm/#sfsmodel">Subfilter scale (SFS) model</a> of turbulence related to vortex stretching</li><li>How to monitor the dynamic SFS model coefficient with   <a href="../../api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_Cd"><code>uns.generate_monitor_Cd</code></a></li><li>How to monitor the global flow enstrophy with   <a href="../../api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_enstrophy"><code>uns.generate_monitor_enstrophy</code></a> and track numerical stability</li><li>Defining a wake treatment procedure to suppress initial hub wake, avoiding   hub fountain effects and accelerating convergence</li><li>Defining hub and tip loss corrections</li></ul><p>Also, in this example you can vary the fidelity of the simulation setting the following parameters:</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: center">Mid-low fidelity</th><th style="text-align: center">Mid-high fidelity</th><th style="text-align: center">High fidelity</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>n</code></td><td style="text-align: center"><code>20</code></td><td style="text-align: center"><code>50</code></td><td style="text-align: center"><code>50</code></td><td style="text-align: left">Number of blade elements per blade</td></tr><tr><td style="text-align: center"><code>nsteps_per_rev</code></td><td style="text-align: center"><code>36</code></td><td style="text-align: center"><code>72</code></td><td style="text-align: center"><code>360</code></td><td style="text-align: left">Time steps per revolution</td></tr><tr><td style="text-align: center"><code>p_per_step</code></td><td style="text-align: center"><code>4</code></td><td style="text-align: center"><code>2</code></td><td style="text-align: center"><code>2</code></td><td style="text-align: left">Particle sheds per time step</td></tr><tr><td style="text-align: center"><code>sigma_rotor_surf</code></td><td style="text-align: center"><code>R/10</code></td><td style="text-align: center"><code>R/10</code></td><td style="text-align: center"><code>R/80</code></td><td style="text-align: left">Rotor-on-VPM smoothing radius</td></tr><tr><td style="text-align: center"><code>sigmafactor_vpmonvlm</code></td><td style="text-align: center"><code>1.0</code></td><td style="text-align: center"><code>1.0</code></td><td style="text-align: center"><code>5.5</code></td><td style="text-align: left">Expand particles by this factor when calculating VPM-on-VLM/Rotor induced velocities</td></tr><tr><td style="text-align: center"><code>shed_starting</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: left">Whether to shed starting vortex</td></tr><tr><td style="text-align: center"><code>suppress_fountain</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: left">Whether to suppress hub fountain effect</td></tr><tr><td style="text-align: center"><code>vpm_integration</code></td><td style="text-align: center"><code>vpm.euler</code></td><td style="text-align: center">RK3<span>$^\star$</span></td><td style="text-align: center">RK3<span>$^\star$</span></td><td style="text-align: left">VPM time integration scheme</td></tr><tr><td style="text-align: center"><code>vpm_SFS</code></td><td style="text-align: center">None<span>$^\dag$</span></td><td style="text-align: center">None<span>$^\dag$</span></td><td style="text-align: center">Dynamic<span>$^\ddag$</span></td><td style="text-align: left">VPM LES subfilter-scale model</td></tr></table><ul><li><span>$^\star$</span><em>RK3:</em> <code>vpm_integration = vpm.rungekutta3</code></li><li><span>$^\dag$</span><em>None:</em> <code>vpm_SFS = vpm.SFS_none</code></li><li><span>$^\ddag$</span><em>Dynamic:</em> <code>vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter</code></li></ul><br>

<table>
    <tr>
        <td>
            <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-midlow-00.png" alt="Pic here" style="width:100%;"/>
            <br>
            <center><b>Mid-Low</b><br>70k particles<br>~7 mins.</center>
        </td>
        <td>
            <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-midhigh-00.png" alt="Pic here" style="width:100%;"/>
            <br>
            <center><b>Mid-High</b><br>200k particles<br>~60 mins.</center>
        </td>
        <td>
            <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-high-03.png" alt="Pic here" style="width:100%;"/>
            <br>
            <center><b>High</b><br>1M particles<br>~30 hrs.</center>
        </td>
    </tr>
</table><br><pre><code class="language-julia hljs">#=##############################################################################
# DESCRIPTION
    Simulation of a DJI 9443 rotor in hover (two-bladed rotor, 9.4 inches
    diameter).

    This example replicates the experiment described in Zawodny &amp; Boyd (2016),
    &quot;Acoustic Characterization and Prediction of Representative,
    Small-scale Rotary-wing Unmanned Aircraft System Components.&quot;

# AUTHORSHIP
  * Author          : Eduardo J. Alvarez (edoalvarez.com)
  * Email           : Edo.AlvarezR@gmail.com
  * Created         : Mar 2023
  * Last updated    : Mar 2023
  * License         : MIT
=###############################################################################


import FLOWUnsteady as uns
import FLOWVLM as vlm
import FLOWVPM as vpm

run_name        = &quot;rotorhover-example&quot;      # Name of this simulation
save_path       = run_name                  # Where to save this simulation
paraview        = true                      # Whether to visualize with Paraview

# ----------------- GEOMETRY PARAMETERS ----------------------------------------

# Rotor geometry
rotor_file      = &quot;DJI9443.csv&quot;             # Rotor geometry
data_path       = uns.def_data_path         # Path to rotor database
pitch           = 0.0                       # (deg) collective pitch of blades
CW              = false                     # Clock-wise rotation
xfoil           = false                     # Whether to run XFOIL
read_polar      = vlm.ap.read_polar2        # What polar reader to use

# NOTE: If `xfoil=true`, XFOIL will be run to generate the airfoil polars used
#       by blade elements before starting the simulation. XFOIL is run
#       on the airfoil contours found in `rotor_file` at the corresponding
#       local Reynolds and Mach numbers along the blade.
#       Alternatively, the user can provide pre-computer airfoil polars using
#       `xfoil=false` and providing the polar files through `rotor_file`.
#       `read_polar` is the function that will be used to parse polar files. Use
#       `vlm.ap.read_polar` for files that are direct outputs of XFOIL (e.g., as
#       downloaded from www.airfoiltools.com). Use `vlm.ap.read_polar2` for CSV
#       files.

# Discretization
n               = 20                        # Number of blade elements per blade
r               = 1/10                      # Geometric expansion of elements

# NOTE: Here a geometric expansion of 1/10 means that the spacing between the
#       tip elements is 1/10 of the spacing between the hub elements. Refine the
#       discretization towards the blade tip like this in order to better
#       resolve the tip vortex.

# Read radius of this rotor and number of blades
R, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]

# ----------------- SIMULATION PARAMETERS --------------------------------------

# Operating conditions
RPM             = 5400                      # RPM
J               = 0.0001                    # Advance ratio Vinf/(nD)
AOA             = 0                         # (deg) Angle of attack (incidence angle)

rho             = 1.071778                  # (kg/m^3) air density
mu              = 1.85508e-5                # (kg/ms) air dynamic viscosity
speedofsound    = 342.35                    # (m/s) speed of sound

# NOTE: For cases with zero freestream velocity, it is recommended that a
#       negligible small velocity is used instead of zero in order to avoid
#       potential numerical instabilities (hence, J here is negligible small
#       instead of zero)

magVinf         = J*RPM/60*(2*R)
Vinf(X, t)      = magVinf*[cos(AOA*pi/180), sin(AOA*pi/180), 0]  # (m/s) freestream velocity vector

ReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number
Matip           = 2*pi*RPM/60 * R / speedofsound    # Tip Mach number

println(&quot;&quot;&quot;
    RPM:    $(RPM)
    Vinf:   $(Vinf(zeros(3), 0)) m/s
    Matip:  $(round(Matip, digits=3))
    ReD:    $(round(ReD, digits=0))
&quot;&quot;&quot;)

# ----------------- SOLVER PARAMETERS ------------------------------------------

# Aerodynamic solver
VehicleType     = uns.UVLMVehicle           # Unsteady solver
# VehicleType     = uns.QVLMVehicle         # Quasi-steady solver
const_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the
                                                # solution is constant or not
# Time parameters
nrevs           = 10                        # Number of revolutions in simulation
nsteps_per_rev  = 36                        # Time steps per revolution
nsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps
ttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time

# VPM particle shedding
p_per_step      = 4                         # Sheds per time step
shed_starting   = false                     # Whether to shed starting vortex
shed_unsteady   = true                      # Whether to shed vorticity from unsteady loading
unsteady_shedcrit = 0.001                   # Shed unsteady loading whenever circulation
                                            #  fluctuates by more than this ratio
max_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles

# Regularization
sigma_rotor_surf= R/10                      # Rotor-on-VPM smoothing radius
lambda_vpm      = 2.125                     # VPM core overlap
                                            # VPM smoothing radius
sigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)
sigmafactor_vpmonvlm= 1                     # Shrink particles by this factor when
                                            #  calculating VPM-on-VLM/Rotor induced velocities

# Rotor solver
vlm_rlx         = 0.5                       # VLM relaxation &lt;-- this also applied to rotors
hubtiploss_correction = ((0.4, 5, 0.1, 0.05), (2, 1, 0.25, 0.05)) # Hub and tip correction

# VPM solver
vpm_integration = vpm.euler                 # VPM temporal integration scheme
# vpm_integration = vpm.rungekutta3

vpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme
# vpm_viscous   = vpm.CoreSpreading(-1, -1, vpm.zeta_fmm; beta=100.0, itmax=20, tol=1e-1)

vpm_SFS         = vpm.SFS_none              # VPM LES subfilter-scale model
# vpm_SFS       = vpm.SFS_Cd_twolevel_nobackscatter
# vpm_SFS       = vpm.SFS_Cd_threelevel_nobackscatter
# vpm_SFS       = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;
#                                   alpha=0.999, maxC=1.0,
#                                   clippings=[vpm.clipping_backscatter])
# vpm_SFS       = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;
#                                   alpha=0.999, rlxf=0.005, minC=0, maxC=1
#                                   clippings=[vpm.clipping_backscatter],
#                                   controls=[vpm.control_sigmasensor],
#                                   )

# NOTE: In most practical situations, open rotors operate at a Reynolds number
#       high enough that viscous diffusion in the wake is actually negligible.
#       Hence, it does not make much of a difference whether we run the
#       simulation with viscous diffusion enabled or not. On the other hand,
#       such high Reynolds numbers mean that the wake quickly becomes turbulent
#       and it is crucial to use a subfilter-scale (SFS) model to accurately
#       capture the turbulent decay of the wake (turbulent diffusion).

if VehicleType == uns.QVLMVehicle
    # Mute warnings regarding potential colinear vortex filaments. This is
    # needed since the quasi-steady solver will probe induced velocities at the
    # lifting line of the blade
    uns.vlm.VLMSolver._mute_warning(true)
end



# ----------------- WAKE TREATMENT ---------------------------------------------
# NOTE: It is known in the CFD community that rotor simulations with an
#       impulsive RPM start (*i.e.*, 0 to RPM in the first time step, as opposed
#       to gradually ramping up the RPM) leads to the hub &quot;fountain effect&quot;,
#       with the root wake reversing the flow near the hub.
#       The fountain eventually goes away as the wake develops, but this happens
#       very slowly, which delays the convergence of the simulation to a steady
#       state. To accelerate convergence, here we define a wake treatment
#       procedure that suppresses the hub wake for the first three revolutions,
#       avoiding the fountain effect altogether.
#       This is especially helpful in low and mid-fidelity simulations.

suppress_fountain   = true                  # Toggle

# Supress wake shedding on blade elements inboard of this r/R radial station
no_shedding_Rthreshold = suppress_fountain ? 0.35 : 0.0

# Supress wake shedding for this many time steps
no_shedding_nstepsthreshold = 3*nsteps_per_rev

omit_shedding = []          # Index of blade elements to supress wake shedding

# Function to suppress or activate wake shedding
function wake_treatment_supress(sim, args...; optargs...)

    # Case: start of simulation -&gt; suppress shedding
    if sim.nt == 1

        # Identify blade elements on which to suppress shedding
        for i in 1:vlm.get_m(rotor)
            HS = vlm.getHorseshoe(rotor, i)
            CP = HS[5]

            if uns.vlm.norm(CP - vlm._get_O(rotor)) &lt;= no_shedding_Rthreshold*R
                push!(omit_shedding, i)
            end
        end
    end

    # Case: sufficient time steps -&gt; enable shedding
    if sim.nt == no_shedding_nstepsthreshold

        # Flag to stop suppressing
        omit_shedding .= -1

    end

    return false
end


# ----------------- 1) VEHICLE DEFINITION --------------------------------------
println(&quot;Generating geometry...&quot;)

# Generate rotor
rotor = uns.generate_rotor(rotor_file; pitch=pitch,
                                        n=n, CW=CW, blade_r=r,
                                        altReD=[RPM, J, mu/rho],
                                        xfoil=xfoil,
                                        read_polar=read_polar,
                                        data_path=data_path,
                                        verbose=true,
                                        plot_disc=true
                                        );

println(&quot;Generating vehicle...&quot;)

# Generate vehicle
system = vlm.WingSystem()                   # System of all FLOWVLM objects
vlm.addwing(system, &quot;Rotor&quot;, rotor)

rotors = [rotor];                           # Defining this rotor as its own system
rotor_systems = (rotors, );                 # All systems of rotors

wake_system = vlm.WingSystem()              # System that will shed a VPM wake
                                            # NOTE: Do NOT include rotor when using the quasi-steady solver
if VehicleType != uns.QVLMVehicle
    vlm.addwing(wake_system, &quot;Rotor&quot;, rotor)
end

vehicle = VehicleType(   system;
                            rotor_systems=rotor_systems,
                            wake_system=wake_system
                         );


# ------------- 2) MANEUVER DEFINITION -----------------------------------------
# Non-dimensional translational velocity of vehicle over time
Vvehicle(t) = zeros(3)

# Angle of the vehicle over time
anglevehicle(t) = zeros(3)

# RPM control input over time (RPM over `RPMref`)
RPMcontrol(t) = 1.0

angles = ()                                 # Angle of each tilting system (none)
RPMs = (RPMcontrol, )                       # RPM of each rotor system

maneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)


# ------------- 3) SIMULATION DEFINITION ---------------------------------------

Vref = 0.0                                  # Reference velocity to scale maneuver by
RPMref = RPM                                # Reference RPM to scale maneuver by
Vinit = Vref*Vvehicle(0)                    # Initial vehicle velocity
Winit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity

simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;
                                                    Vinit=Vinit, Winit=Winit);

# Restart simulation
restart_file = nothing

# NOTE: Uncomment the following line to restart a previous simulation.
#       Point it to a particle field file (with its full path) at a specific
#       time step, and `run_simulation` will start this simulation with the
#       particle field found in the restart simulation.

# restart_file = &quot;/path/to/a/previous/simulation/rotorhover-example_pfield.360&quot;


# ------------- 4) MONITORS DEFINITIONS ----------------------------------------

# Generate rotor monitor
monitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;
                                            t_scale=RPM/60,        # Scaling factor for time in plots
                                            t_lbl=&quot;Revolutions&quot;,   # Label for time axis
                                            save_path=save_path,
                                            run_name=run_name,
                                            figname=&quot;rotor monitor&quot;,
                                            )

# Generate monitor of flow enstrophy (numerical stability)
monitor_enstrophy = uns.generate_monitor_enstrophy(;
                                            save_path=save_path,
                                            run_name=run_name,
                                            figname=&quot;enstrophy monitor&quot;
                                            )

# Generate monitor of SFS model coefficient Cd
monitor_Cd = uns.generate_monitor_Cd(;
                                            save_path=save_path,
                                            run_name=run_name,
                                            figname=&quot;Cd monitor&quot;
                                            )
# Concatenate monitors
monitors = uns.concatenate(monitor_rotor, monitor_enstrophy, monitor_Cd)


# ------------- 5) RUN SIMULATION ----------------------------------------------
println(&quot;Running simulation...&quot;)

# Concatenate monitors and wake treatment procedure into one runtime function
runtime_function = uns.concatenate(monitors, wake_treatment_supress)

# Run simulation
uns.run_simulation(simulation, nsteps;
                    # ----- SIMULATION OPTIONS -------------
                    Vinf=Vinf,
                    rho=rho, mu=mu, sound_spd=speedofsound,
                    # ----- SOLVERS OPTIONS ----------------
                    p_per_step=p_per_step,
                    max_particles=max_particles,
                    vpm_integration=vpm_integration,
                    vpm_viscous=vpm_viscous,
                    vpm_SFS=vpm_SFS,
                    sigma_vlm_surf=sigma_rotor_surf,
                    sigma_rotor_surf=sigma_rotor_surf,
                    sigma_vpm_overwrite=sigma_vpm_overwrite,
                    sigmafactor_vpmonvlm=sigmafactor_vpmonvlm,
                    vlm_rlx=vlm_rlx,
                    hubtiploss_correction=hubtiploss_correction,
                    shed_starting=shed_starting,
                    shed_unsteady=shed_unsteady,
                    unsteady_shedcrit=unsteady_shedcrit,
                    omit_shedding=omit_shedding,
                    extra_runtime_function=runtime_function,
                    # ----- RESTART OPTIONS -----------------
                    restart_vpmfile=restart_file,
                    # ----- OUTPUT OPTIONS ------------------
                    save_path=save_path,
                    run_name=run_name,
                    save_wopwopin=true,  # &lt;--- Generates input files for PSU-WOPWOP noise analysis
                    );




# ----------------- 6) VISUALIZATION -------------------------------------------
if paraview
    println(&quot;Calling Paraview...&quot;)

    # Files to open in Paraview
    files = joinpath(save_path, run_name*&quot;_pfield...xmf;&quot;)
    for bi in 1:B
        global files
        files *= run_name*&quot;_Rotor_Blade$(bi)_loft...vtk;&quot;
        files *= run_name*&quot;_Rotor_Blade$(bi)_vlm...vtk;&quot;
    end

    # Call Paraview
    run(`paraview --data=$(files)`)

end

</code></pre><span style="font-size: 0.9em; color:gray;"><i>
    Mid-low fidelity runtime: ~7 minutes on a 16-core AMD EPYC 7302 processor. <br>
    Mid-high fidelity runtime: ~60 minutes on a 16-core AMD EPYC 7302 processor. <br>
    High fidelity runtime: ~30 hours on a 16-core AMD EPYC 7302 processor.
</i></span>
<br><br><p>Rotor monitor in the high-fidelity case:</p><center>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotor_convergence.png" alt="Pic here" style="width:100%;"/>
</center><p>As the simulation runs, you will see the monitor shown below plotting the global enstrophy of the flow. The global enstrophy achieves a steady state once the rate of enstrophy produced by the rotor eventually balances out with the forward scatter of the SFS turbulence model, making the simulation indefinitely stable.</p><center>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotorenstrophy.png" alt="Pic here" style="width:50%;"/>
</center><p>The SFS model uses a <a href="../../theory/rvpm/#sfsmodel">dynamic procedure</a> to compute its own model coefficient <span>$C_d$</span> as the simulation evolves. The value of the model coefficient varies for each particle in space and time. The <span>$C_d$</span>-monitor shown below plots the mean value from all the particle in the field that have a non-zero <span>$C_d$</span> (left), and also the ratio of the number of particles that got clipped to a zero <span>$C_d$</span> over the total number of particles (right).</p><center>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotorChistory.png" alt="Pic here" style="width:100%;"/>
</center><div class="admonition is-info"><header class="admonition-header">Prescribing the Model Coefficient</header><div class="admonition-body"><p>The SFS model helps the simulation to more accurately capture the effects of turbulence from the scales that are not resolved, but it adds computational cost. The following table summarizes the cost of the rVPM, the SFS model, and the <span>$C_d$</span> dynamic procedure. <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rvpmsfs-benchmark02.png" alt="pic"/> The dynamic procedure is the most costly operation, which increases the simulation runtime by about 35%.</p><p>If you need to run a case multiple times with only slight changes (e.g., sweeping the AOA and/or RPM), you can first run the simulation with the dynamic procedure (<code>vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter</code>), take note of what the mean <span>$C_d$</span> shown in the monitor converges to, and then prescribe that value to subsequent simulations. Prescribing <span>$C_d$</span> ends up in a simulation that is only 8% slower than the classic VPM without any SFS model.</p><p><span>$C_d$</span> can then be prescribed as follows</p><pre><code class="language-julia hljs">vpm_SFS = vpm.ConstantSFS(vpm.Estr_fmm; Cs=value, clippings=[vpm.clipping_backscatter])</code></pre><p>where <code>CS = value</code> is the value to prescribe for the model coefficient, and <code>clippings=[vpm.clipping_backscatter]</code> clips the backscatter of enstrophy (making it a purely diffusive model). As a reference, in this hover case, <span>$C_d$</span> converges to <span>$0.26$</span> in the high-fidelity simulation.</p></div></div><p>In <a href="https://github.com/byuflowlab/FLOWUnsteady/blob/master/examples/rotorhover/rotorhover_postprocessing.jl">examples/rotorhover/rotorhover_postprocessing.jl</a> we show how to postprocess the simulations to compare <span>$C_T$</span> and blade loading to experimental data by Zawodny <em>et al</em>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> and a URANS simulation (STAR-CCM+) by Schenk<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>:</p><center>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-CTcomparison.png" alt="Pic here" style="width:75%;"/>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-loadingcomparison.png" alt="Pic here" style="width:75%;"/>
</center><table><tr><th style="text-align: right"></th><th style="text-align: center"><span>$C_T$</span></th><th style="text-align: center">Error</th></tr><tr><td style="text-align: right">Experimental</td><td style="text-align: center">0.072</td><td style="text-align: center">–</td></tr><tr><td style="text-align: right">URANS</td><td style="text-align: center">0.071</td><td style="text-align: center">1%</td></tr><tr><td style="text-align: right">rVPM – high fidelity</td><td style="text-align: center">0.073</td><td style="text-align: center">1%</td></tr><tr><td style="text-align: right">rVPM – mid-high fidelity</td><td style="text-align: center">0.066</td><td style="text-align: center">8%</td></tr><tr><td style="text-align: right">rVPM – mid-low fidelity</td><td style="text-align: center">0.064</td><td style="text-align: center">11%</td></tr><tr><td style="text-align: right">BEMT (quasi-steady)</td><td style="text-align: center">0.073</td><td style="text-align: center">2%</td></tr></table><div class="admonition is-info"><header class="admonition-header">Hub/Tip Loss Correction</header><div class="admonition-body"><p>In the rotor actuator line model, hub and tip corrections can be applied to <span>$c_\ell$</span> to account for the effects that bring the aerodynamic loading to zero at the hub and tips. These correction factors, <span>$F_\mathrm{tip}$</span> and <span>$F_\mathrm{hub}$</span>, are defined as modified Prandtl loss functions,</p><p class="math-container">\[\begin{align*}
    F_\mathrm{tip}
&amp; =
    \frac{2}{\pi} \cos^{-1} \left( \exp\left( -f_\mathrm{tip} \right) \right)
, \qquad
    f_\mathrm{tip}
=
    \frac{B}{2}
    \frac{
        \left[  \left( \frac{R_\mathrm{rotor}}{r} \right)^{t_1} - 1  \right]^{t_2}
    }{
        \vert \sin \left( \theta_\mathrm{eff} \right) \vert^{t_3}
    }
\\
    F_\mathrm{hub}
&amp; =
    \frac{2}{\pi} \cos^{-1} \left( \exp\left( -f_\mathrm{hub} \right) \right)
, \qquad
    f_\mathrm{hub}
=
    \frac{B}{2}
    \frac{
        \left[  \left( \frac{r}{R_\mathrm{hub}} \right)^{h_1} - 1  \right]^{h_2}
    }{
        \vert \sin \left( \theta_\mathrm{eff} \right) \vert^{h_3}
    }
,\end{align*}\]</p><p>where <span>$R_\mathrm{rotor}$</span> and <span>$R_\mathrm{hub}$</span> are the rotor and hub radii, <span>$B$</span> is the number of blades, <span>$r$</span> is the radial position of the blade element, and <span>$t_1$</span>, <span>$t_2$</span>, <span>$t_3$</span>, <span>$h_1$</span>, <span>$h_2$</span>, and <span>$h_3$</span> are tunable parameters. The normal and tangential force coefficients, respectively <span>$c_n$</span> and <span>$c_t$</span>, are then calculated as</p><p class="math-container">\[\begin{align*}
    c_n
&amp; =
    F_\mathrm{tip} F_\mathrm{hub} c_\ell\cos\theta_\mathrm{eff} + c_d\sin\theta_\mathrm{eff}
\\
    c_t
&amp; =
    F_\mathrm{tip} F_\mathrm{hub} c_\ell\sin\theta_\mathrm{eff} - c_d\cos\theta_\mathrm{eff}
.\end{align*}\]</p><p>The hub and tip corrections are passed to <a href="../../api/flowunsteady-run/#FLOWUnsteady.run_simulation"><code>uns.run_simulation</code></a> through the keyword argument <code>hubtiploss_correction = ((t1, t2, t3, tminangle), (h1, h2, h3, hminangle))</code>, where <code>tminangle</code> and <code>hminangle</code> are clipping thresholds for the minimum allowable value of <span>$\vert\theta_\mathrm{eff}\vert$</span> (in degs) that is used in tip and hub corrections. The following corrections are predefined in FLOWVLM for the user:</p></div></div><pre><code class="language-julia hljs">import FLOWVLM as vlm

# No corrections
vlm.hubtiploss_nocorrection</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((1, 0, Inf, 1.1102230246251565e-15), (1, 0, Inf, 1.1102230246251565e-15))</code></pre><pre><code class="language-julia hljs"># Original Prandtl corrections
vlm.hubtiploss_correction_prandtl</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((1, 1, 1, 1.0), (1, 1, 1, 1.0))</code></pre><pre><code class="language-julia hljs"># Modified Prandtl with a strong hub correction
vlm.hubtiploss_correction_modprandtl</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((0.6, 5, 0.5, 10), (2, 1, 0.25, 0.05))</code></pre><div class="admonition is-info"><header class="admonition-header">ParaView Visualization</header><div class="admonition-body"><p>The <code>.pvsm</code> file visualizing the simulation as shown at the top of this page is available here: <a href="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-monitors-particles11.pvsm">LINK</a> (<code>right click → save as...</code>).</p><p>To open in ParaView: <code>File → Load State → (select .pvsm file)</code> then select &quot;Search files under specified directory&quot; and point it to the folder where the simulation was saved.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>N. S. Zawodny, D. D. Boyd, Jr., and C. L. Burley, “Acoustic Characterization and Prediction of Representative, Small-scale Rotary-wing Unmanned Aircraft System Components,” in <em>72nd American Helicopter Society (AHS) Annual Forum</em> (2016).</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>A. R. Schenk, &quot;Computational Investigation of the Effects of Rotor-on-Rotor Interactions on Thrust and Noise,&quot; Masters thesis, <em>Brigham Young University</em> (2020).</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../propeller-incidence/">« Incidence Sweep</a><a class="docs-footer-nextpage" href="../rotorhover-fdom/">Fluid Domain »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 8 January 2024 07:37">Monday 8 January 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
