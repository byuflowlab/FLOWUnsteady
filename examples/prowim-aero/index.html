<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Prop-on-Wing Interactions · FLOWUnsteady</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-B7CBF7WC7L"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B7CBF7WC7L', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FLOWUnsteady logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Intro</a></li><li><a class="tocitem" href="../../installation/general/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Simple Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../wing-4p2aoa/">Basics</a></li><li><a class="tocitem" href="../wing-aoasweep/">AOA Sweep</a></li></ul></li><li><a class="tocitem" href="../tetheredwing/">Tethered Wing</a></li><li><a class="tocitem" href="../heavingwing/">Heaving Wing</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Propeller</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../propeller-J040/">Basics</a></li><li><a class="tocitem" href="../propeller-jsweep/"><span>$J$</span> Sweep</a></li><li><a class="tocitem" href="../propeller-quasisteady/">Quasi-Steady Solver</a></li><li><a class="tocitem" href="../propeller-incidence/">Incidence Sweep</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Rotor in Hover</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../rotorhover-aero/">Variable Fidelity</a></li><li><a class="tocitem" href="../rotorhover-fdom/">Fluid Domain</a></li><li><a class="tocitem" href="../rotorhover-acoustics/">Aeroacoustics</a></li><li><a class="tocitem" href="../rotorhover-quasisteady/">Quasi-Steady Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox" checked/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Blown Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../blownwing-aero/">Wing-on-Prop Interactions</a></li><li><a class="tocitem" href="../blownwing-asm/">Actuator Surface Model</a></li><li class="is-active"><a class="tocitem" href>Prop-on-Wing Interactions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">eVTOL Aircraft</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../vahana-vehicle/">Vehicle Definition</a></li><li><a class="tocitem" href="../vahana-maneuver/">Maneuver Definition</a></li><li><a class="tocitem" href="../vahana-monitor/">Monitors Definitions</a></li><li><a class="tocitem" href="../vahana-run/">Run Simulation</a></li></ul></li><li><a class="tocitem" href="../openvsp-aircraft/">OpenVSP Geometry</a></li></ul></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../theory/rvpm/">Reformulated VPM</a></li><li><a class="tocitem" href="../../theory/convergence/">Convergence</a></li><li><a class="tocitem" href="../../theory/validation/">Validation</a></li><li><a class="tocitem" href="../../theory/publications/">Publications</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">API Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">(1) Vehicle Definition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowunsteady-vehicle-types/">Vehicle types</a></li><li><a class="tocitem" href="../../api/flowunsteady-vehicle-components/">Generating components</a></li><li><a class="tocitem" href="../../api/flowunsteady-vehicle-asm/">Actuator surface model</a></li><li><a class="tocitem" href="../../api/flowunsteady-openvsp/">OpenVSP geometry</a></li></ul></li><li><a class="tocitem" href="../../api/flowunsteady-maneuver/">(2) Maneuver Definition</a></li><li><a class="tocitem" href="../../api/flowunsteady-simulation/">(3) Simulation Definition</a></li><li><a class="tocitem" href="../../api/flowunsteady-monitor/">(4) Monitors Definitions</a></li><li><a class="tocitem" href="../../api/flowunsteady-run/">(5) Run Simulation</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">(6) Viz and Postprocessing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-fdom/">Fluid Domain</a></li><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-noise/">Aeroacoustic Noise</a></li><li><a class="tocitem" href="../../api/flowunsteady-postprocessing-misc/">Miscellaneous</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-7" type="checkbox"/><label class="tocitem" for="menuitem-7-7"><span class="docs-label">Extras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-7-1"><span class="docs-label">FLOWVPM</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/flowvpm-particle/">Particle Field</a></li><li><a class="tocitem" href="../../api/flowvpm-uj/">UJ Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-viscous/">Viscous Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-relaxation/">Relaxation Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-sfs/">SFS Scheme</a></li><li><a class="tocitem" href="../../api/flowvpm-time/">Time Integration</a></li><li><a class="tocitem" href="../../api/flowvpm-utils/">Utilities</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Blown Wing</a></li><li class="is-active"><a href>Prop-on-Wing Interactions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Prop-on-Wing Interactions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWUnsteady/blob/master/docs/src/examples/prowim-aero.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="prowimaero"><a class="docs-heading-anchor" href="#prowimaero">Prop-on-Wing Interactions</a><a id="prowimaero-1"></a><a class="docs-heading-anchor-permalink" href="#prowimaero" title="Permalink"></a></h1>  <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//veldhuis2004-expsetup01.png" alt="Pic here" style="width: 49%;"/><br><br><p>In this example we use the <a href="../blownwing-asm/#asm">actuator surface model</a> (ASM) to more accurately predict the effects of props blowing on a wing. This case simulates the PROWIM experiment in <a href="https://repository.tudelft.nl/islandora/object/uuid%3A8ffbde9c-b483-40de-90e0-97095202fbe3">Leo Veldhuis&#39; dissertation</a> (2005), and reproduces the validation study published in <a href="https://arc.aiaa.org/doi/10.2514/1.C037279">Alvarez &amp; Ning (2023)</a>.</p><p>In this example you can vary the fidelity of the simulation setting the following parameters:</p><table><tr><th style="text-align: center">Parameter</th><th style="text-align: center">Low fidelity</th><th style="text-align: center">Mid-low fidelity</th><th style="text-align: center">Mid-high fidelity</th><th style="text-align: center">High fidelity</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: center"><code>n_wing</code></td><td style="text-align: center"><code>50</code></td><td style="text-align: center"><code>50</code></td><td style="text-align: center"><code>50</code></td><td style="text-align: center"><code>100</code></td><td style="text-align: left">Number of wing elements per semispan</td></tr><tr><td style="text-align: center"><code>n_rotor</code></td><td style="text-align: center"><code>12</code></td><td style="text-align: center"><code>12</code></td><td style="text-align: center"><code>20</code></td><td style="text-align: center"><code>50</code></td><td style="text-align: left">Number of blade elements per blade</td></tr><tr><td style="text-align: center"><code>nsteps_per_rev</code></td><td style="text-align: center"><code>36</code></td><td style="text-align: center"><code>36</code></td><td style="text-align: center"><code>36</code></td><td style="text-align: center"><code>72</code></td><td style="text-align: left">Time steps per revolution</td></tr><tr><td style="text-align: center"><code>p_per_step</code></td><td style="text-align: center"><code>2</code></td><td style="text-align: center"><code>5</code></td><td style="text-align: center"><code>5</code></td><td style="text-align: center"><code>5</code></td><td style="text-align: left">Particle sheds per time step</td></tr><tr><td style="text-align: center"><code>shed_starting</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: left">Whether to shed starting vortex</td></tr><tr><td style="text-align: center"><code>shed_unsteady</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: left">Whether to shed vorticity from unsteady loading</td></tr><tr><td style="text-align: center"><code>treat_wake</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: left">Treat wake to avoid instabilities</td></tr><tr><td style="text-align: center"><code>vlm_vortexsheet_overlap</code></td><td style="text-align: center"><code>2.125/10</code></td><td style="text-align: center"><code>2.125/10</code></td><td style="text-align: center"><code>2.125/10</code></td><td style="text-align: center"><code>2.125</code></td><td style="text-align: left">Particle overlap in ASM vortex sheet</td></tr><tr><td style="text-align: center"><code>vpm_integration</code></td><td style="text-align: center"><code>vpm.euler</code></td><td style="text-align: center"><code>vpm.euler</code></td><td style="text-align: center">RK3<span>$^\star$</span></td><td style="text-align: center">RK3<span>$^\star$</span></td><td style="text-align: left">VPM time integration scheme</td></tr><tr><td style="text-align: center"><code>vpm_SFS</code></td><td style="text-align: center">None<span>$^\dag$</span></td><td style="text-align: center">None<span>$^\dag$</span></td><td style="text-align: center">Dynamic<span>$^\ddag$</span></td><td style="text-align: center">Dynamic<span>$^\ddag$</span></td><td style="text-align: left">VPM LES subfilter-scale model</td></tr></table><ul><li><span>$^\star$</span><em>RK3:</em> <code>vpm_integration = vpm.rungekutta3</code></li><li><span>$^\dag$</span><em>None:</em> <code>vpm_SFS = vpm.SFS_none</code></li><li><span>$^\ddag$</span><em>Dynamic:</em> <code>vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter</code></li></ul><p>(Low fidelity settings may be inadequate for accurately capturing prop-on-wing interactions, but mid-low or higher should do well)</p><p>As a reference, high-fidelity looks like this (except that the video shows a tip-mounted configuration with ailerons):</p><div style="position:relative;padding-top:50%;">
    <iframe style="position:absolute;left:0;top:0;height:80%;width:72%;"
        src="https://www.youtube.com/embed/GfS3NoVrFfU?hd=1"
        title="YouTube video player" frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        allowfullscreen></iframe>
</div><pre><code class="language-julia hljs">#=##############################################################################
# DESCRIPTION
    Validation of prop-on-wing interactions with twin props mounted mid span
    blowing on a wing. This case simulates the PROWIM experiment in Leo
    Veldhuis&#39; dissertation (2005), “Propeller Wing Aerodynamic Interference.”

    In this simulation we use the actuator surface model for the wing in order
    to accurately capture prop-on-wing interactional effects. The rotors still
    use the actuator line model.

    The high-fidelity settings replicate the results presented in Alvarez &amp;
    Ning (2023), &quot;Meshless Large-Eddy Simulation of Propeller–Wing Interactions
    with Reformulated Vortex Particle Method,&quot; Sec. IV.B, also available in
    Alvarez (2022), &quot;Reformulated Vortex Particle Method and Meshless Large Eddy
    Simulation of Multirotor Aircraft,&quot; Sec. 8.4.

# ABOUT
  * Author          : Eduardo J. Alvarez (edoalvarez.com)
  * Email           : Edo.AlvarezR@gmail.com
  * Created         : January 2024
  * Last updated    : January 2024
  * License         : MIT
=###############################################################################


import FLOWUnsteady as uns
import FLOWUnsteady: vlm, vpm

run_name        = &quot;prowim&quot;                  # Name of this simulation
save_path       = run_name*&quot;-example2&quot;       # Where to save this simulation
prompt          = true                      # Whether to prompt the user
paraview        = true                      # Whether to visualize with Paraview

add_wing        = true                      # Whether to add wing to simulation
add_rotors      = true                      # Whether to add rotors to simulation

# ----------------- GEOMETRY PARAMETERS ----------------------------------------
# Wing geometry
b               = 2*0.64                    # (m) span length
ar              = 5.33                      # Aspect ratio b/c_tip
tr              = 1.0                       # Taper ratio c_tip/c_root
twist_root      = 0.0                       # (deg) twist at root
twist_tip       = 0.0                       # (deg) twist at tip
lambda          = 0.0                       # (deg) sweep
gamma           = 0.0                       # (deg) dihedral
thickness_w     = 0.15                      # Thickness t/c of wing airfoil

# Rotor geometry
rotor_file      = &quot;beaver.csv&quot;              # Rotor geometry
data_path       = uns.def_data_path         # Path to rotor database
read_polar      = vlm.ap.read_polar2        # What polar reader to use
pitch           = 2.5                       # (deg) collective pitch of blades
xfoil           = false                     # Whether to run XFOIL
ncrit           = 6                         # Turbulence criterion for XFOIL

# Read radius of this rotor and number of blades
R, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]

# Vehicle assembly
AOAwing         = 0.0                       # (deg) wing angle of attack
spanpos         = [-0.46875, 0.46875]       # Semi-span position of each rotor, 2*y/b
xpos            = [-0.8417, -0.8417]        # x-position of rotors relative to LE, x/c
zpos            = [0.0, 0.0]                # z-position of rotors relative to LE, z/c
CWs             = [false, true]             # Rotation direction of each rotor: outboard up
# CWs             = [true, false]           # Rotation direction of each rotor: inboard up
nrotors         = length(spanpos)           # Number of rotors

# Discretization
n_wing          = 50                        # Number of spanwise elements per side
r_wing          = 2.0                       # Geometric expansion of elements
# n_rotor         = 20                        # Number of blade elements per blade
n_rotor         = 12
r_rotor         = 1/10                      # Geometric expansion of elements

# Check that we declared all the inputs that we need for each rotor
@assert nrotors==length(spanpos)==length(xpos)==length(zpos)==length(CWs) &quot;&quot;*
    &quot;Invalid rotor inputs! Check that spanpos, xpos, zpos, and CWs have the same length&quot;

# ----------------- SIMULATION PARAMETERS --------------------------------------
# Freestream
magVinf         = 49.5                      # (m/s) freestream velocity
AOA             = 4.0                       # (deg) vehicle angle of attack
rho             = 1.225                     # (kg/m^3) air density
mu              = 1.79e-5                   # (kg/ms) air dynamic viscosity
speedofsound    = 342.35                    # (m/s) speed of sound
qinf            = 0.5*rho*magVinf^2         # (Pa) reference static pressure
Vinf(X, t)      = magVinf*[cosd(AOA), 0, sind(AOA)]  # Freestream function

# Rotor operation
J               = 0.85                      # Advance ratio Vinf/(nD)
RPM             = 60*magVinf/(J*2*R)        # RPM

# Reference non-dimensional parameters
Rec             = rho * magVinf * (b/ar) / mu       # Chord-based wing Reynolds number
ReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based rotor Reynolds number
Mtip            = 2*pi*RPM/60 * R / speedofsound    # Tip Mach number

println(&quot;&quot;&quot;
    Vinf:   $(round(magVinf, digits=1)) m/s
    RPM:    $(RPM)
    Mtip:   $(round(Mtip, digits=3))
    ReD:    $(round(ReD, digits=0))
    Rec:    $(round(Rec, digits=0))
&quot;&quot;&quot;)


# NOTE: Modify the variable `AOA` in order to change the angle of attack.
#       `AOAwing` will only change the angle of attack of the wing (while
#       leaving the propellers unaffected), while `AOA` changes the angle of
#       attack of the freestream (affecting both wing and props).

# ----------------- SOLVER PARAMETERS ------------------------------------------

# Aerodynamic solver
VehicleType     = uns.UVLMVehicle           # Unsteady solver
# VehicleType     = uns.QVLMVehicle         # Quasi-steady solver
const_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the
                                                # solution is constant or not
# Time parameters
nrevs           = 8                         # Number of revolutions in simulation
nsteps_per_rev  = 36                        # Time steps per revolution
nsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps
ttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time

# VPM particle shedding
# p_per_step      = 5                         # Sheds per time step
p_per_step      = 2
shed_starting   = false                     # Whether to shed starting vortex (NOTE: starting vortex might make simulation unstable with AOA&gt;8)
shed_unsteady   = false                     # Whether to shed vorticity from unsteady loading
unsteady_shedcrit = 0.001                   # Shed unsteady loading whenever circulation
                                            #  fluctuates by more than this ratio
treat_wake      = true                      # Treat wake to avoid instabilities
max_particles   = 1                         # Maximum number of particles
max_particles   += add_rotors * (nrotors*((2*n_rotor+1)*B)*nsteps*p_per_step)
max_particles   += add_wing * (nsteps+1)*(2*n_wing*(p_per_step+1) + p_per_step)

# Regularization
sigma_vlm_surf  = b/200                     # VLM-on-VPM smoothing radius (σLBV of wing)
sigma_rotor_surf= R/80                      # Rotor-on-VPM smoothing radius (σ of rotor)
lambda_vpm      = 2.125                     # VPM core overlap
                                            # VPM smoothing radius (σ of wakes)
sigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)

# Rotor solver
vlm_rlx         = 0.3                       # VLM relaxation &lt;-- this also applied to rotors
hubtiploss_correction = ( (0.75, 10, 0.5, 0.05), (1, 1, 1, 1.0) ) # Hub/tip correction
# VPM solver
# vpm_integration = vpm.rungekutta3           # VPM temporal integration scheme
vpm_integration = vpm.euler

vpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme
                                            # Uncomment this to make it viscous
# vpm_viscous   = vpm.CoreSpreading(-1, -1, vpm.zeta_fmm; beta=100.0, itmax=20, tol=1e-1)

vpm_SFS       = vpm.SFS_none              # VPM LES subfilter-scale model
# vpm_SFS         = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;
                                  # alpha=0.999, maxC=1.0,
                                  # clippings=[vpm.clipping_backscatter])

# NOTE: By default we make this simulation inviscid since at such high Reynolds
#       number the viscous effects in the wake are actually negligible.
#       Notice that while viscous diffusion is negligible, turbulent diffusion
#       is important and non-negigible, so we have activated the subfilter-scale
#       (SFS) model.

if VehicleType == uns.QVLMVehicle
    # Mute warnings regarding potential colinear vortex filaments. This is
    # needed since the quasi-steady solver will probe induced velocities at the
    # lifting line of the blade
    uns.vlm.VLMSolver._mute_warning(true)
end

println(&quot;&quot;&quot;
    Resolving wake for $(round(ttot*magVinf/b, digits=1)) span distances
&quot;&quot;&quot;)





# ----------------- ACTUATOR SURFACE MODEL PARAMETERS (WING) -------------------

# ---------- Vortex sheet parameters ---------------
vlm_vortexsheet = true                      # Spread wing circulation as a vortex sheet (activates the ASM)
vlm_vortexsheet_overlap = 2.125/10          # Particle overlap in vortex sheet
vlm_vortexsheet_distribution = uns.g_pressure   # Distribution of the vortex sheet

vlm_vortexsheet_sigma_tbv = thickness_w*(b/ar) / 128 # Smoothing radius of trailing bound vorticity, σTBV for VLM-on-VPM

vlm_vortexsheet_maxstaticparticle = 10^6    # Particles to preallocate for vortex sheet

if add_wing &amp;&amp; vlm_vortexsheet
    max_particles += vlm_vortexsheet_maxstaticparticle
end


# ---------- Force calculation parameters ----------
KJforce_type                = &quot;regular&quot;     # KJ force evaluated at middle of bound vortices
# KJforce_type              = &quot;averaged&quot;    # KJ force evaluated at average vortex sheet
# KJforce_type              = &quot;weighted&quot;    # KJ force evaluated at strength-weighted vortex sheet

include_trailingboundvortex = false         # Include trailing bound vortices in force calculations

include_freevortices        = false         # Include free vortices in force calculation
include_freevortices_TBVs   = false         # Include trailing bound vortex in free-vortex force

include_unsteadyforce       = true          # Include unsteady force
add_unsteadyforce           = false         # Whether to add the unsteady force to Ftot or to simply output it

include_parasiticdrag       = true          # Include parasitic-drag force
add_skinfriction            = true          # If false, the parasitic drag is purely form, meaning no skin friction
calc_cd_from_cl             = true          # Whether to calculate cd from cl or effective AOA
# calc_cd_from_cl             = false

# NOTE: We use a polar at a low Reynolds number (100k as opposed to 600k from
#       the experiment) as this particular polar better resembles the drag of
#       the tripped airfoil used in the experiment
wing_polar_file             = &quot;xf-n64015a-il-100000-n5.csv&quot;    # Airfoil polar for parasitic drag (from airfoiltools.com)


if include_freevortices &amp;&amp; Threads.nthreads()==1
    @warn(&quot;Free-vortex force calculation requested, but Julia was initiated&quot;*
          &quot; with only one CPU thread. This will be extremely slow!&quot;*
          &quot; Initate Julia with `-t num` where num is the number of cores&quot;*
          &quot; availabe to speed up the computation.&quot;)
end





# ----------------- WAKE TREATMENT ---------------------------------------------

wake_treatments = []

# Remove particles by particle strength: remove particles neglibly weak, remove
# particles potentially blown up
rmv_strngth = 2.0 * magVinf*(b/ar)/2 * magVinf*ttot/nsteps/p_per_step  # Reference strength (maxCL=2.0)
minmaxGamma = rmv_strngth*[0.0001, 10.0]    # Strength bounds (removes particles outside of these bounds)
wake_treatment_strength = uns.remove_particles_strength( minmaxGamma[1]^2, minmaxGamma[2]^2; every_nsteps=1)

if treat_wake
    push!(wake_treatments, wake_treatment_strength)
end





# ----------------- 1) VEHICLE DEFINITION --------------------------------------

# -------- Generate components
println(&quot;Generating geometry...&quot;)

# Generate wing
wing = vlm.simpleWing(b, ar, tr, twist_root, lambda, gamma;
                                    twist_tip=twist_tip, n=n_wing, r=r_wing);

# Pitch wing to its angle of attack
O = [0.0, 0.0, 0.0]                                 # New position
Oaxis = uns.gt.rotation_matrix2(0, -AOAwing, 0)     # New orientation
vlm.setcoordsystem(wing, O, Oaxis)

# Generate rotors
rotors = vlm.Rotor[]
for ri in 1:nrotors

    # Generate rotor
    rotor = uns.generate_rotor(rotor_file;
                                pitch=pitch,
                                n=n_rotor, CW=CWs[ri], blade_r=r_rotor,
                                altReD=[RPM, J, mu/rho],
                                xfoil=xfoil,
                                ncrit=ncrit,
                                data_path=data_path,
                                read_polar=read_polar,
                                verbose=true,
                                verbose_xfoil=false,
                                plot_disc=false
                                );

    # Simulate only one rotor if the wing is not in the simulation
    if !add_wing
        push!(rotors, rotor)
        break
    end

    # Determine position along wing LE
    y = spanpos[ri]*b/2
    x = abs(y)*tand(lambda) + xpos[ri]*b/ar
    z = abs(y)*tand(gamma) + zpos[ri]*b/ar

    # Account for angle of attack of wing
    nrm = sqrt(x^2 + z^2)
    x = (x==0 ? 1 : sign(x))*nrm*cosd(AOAwing)
    z = -(z==0 ? 1 : sign(z))*nrm*sind(AOAwing)

    # Translate rotor to its position along wing
    O_r = [x, y, z]                                     # New position
    Oaxis_r = uns.gt.rotation_matrix2(0, 0, 0)          # New orientation
    vlm.setcoordsystem(rotor, O_r, Oaxis_r; user=true)

    push!(rotors, rotor)
end


# -------- Generate vehicle
println(&quot;Generating vehicle...&quot;)

# System of all FLOWVLM objects
system = vlm.WingSystem()

if add_wing
    vlm.addwing(system, &quot;Wing&quot;, wing)
end

if add_rotors
    for (ri, rotor) in enumerate(rotors)
        vlm.addwing(system, &quot;Rotor$(ri)&quot;, rotor)
    end
end

# System solved through VLM solver
vlm_system = vlm.WingSystem()
add_wing ? vlm.addwing(vlm_system, &quot;Wing&quot;, wing) : nothing

# Systems of rotors
rotor_systems = add_rotors ? (rotors, ) : NTuple{0, Array{vlm.Rotor, 1}}()

# System that will shed a VPM wake
wake_system = vlm.WingSystem()              # System that will shed a VPM wake
add_wing ? vlm.addwing(wake_system, &quot;Wing&quot;, wing) : nothing
                                            # NOTE: Do NOT include rotor when using the quasi-steady solver
if VehicleType != uns.QVLMVehicle &amp;&amp; add_rotors
    for (ri, rotor) in enumerate(rotors)
        vlm.addwing(wake_system, &quot;Rotor$(ri)&quot;, rotor)
    end
end

# Pitch vehicle to its angle of attack (0 in this case since we have tilted the freestream instead)
O = [0.0, 0.0, 0.0]                                 # New position
Oaxis = uns.gt.rotation_matrix2(0, 0, 0)            # New orientation
vlm.setcoordsystem(system, O, Oaxis)

vehicle = VehicleType(   system;
                            vlm_system=vlm_system,
                            rotor_systems=rotor_systems,
                            wake_system=wake_system
                         );






# ------------- 2) MANEUVER DEFINITION -----------------------------------------
# Non-dimensional translational velocity of vehicle over time
Vvehicle(t) = [-1, 0, 0]        # &lt;---- Vehicle is traveling in the -x direction

# Angle of the vehicle over time
anglevehicle(t) = zeros(3)

# RPM control input over time (RPM over `RPMref`)
RPMcontrol(t) = 1.0

angles = ()                                 # Angle of each tilting system (none)
RPMs = add_rotors ? (RPMcontrol, ) : ()     # RPM of each rotor system

maneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)






# ------------- 3) SIMULATION DEFINITION ---------------------------------------

Vref = 0.0                                  # Reference velocity to scale maneuver by
RPMref = RPM                                # Reference RPM to scale maneuver by
Vinit = Vref*Vvehicle(0)                    # Initial vehicle velocity
Winit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity

simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;
                                                    Vinit=Vinit, Winit=Winit);





# ------------- *) AERODYNAMIC FORCES ------------------------------------------
# Here we define the different components of aerodynamic of force that we desire
# to capture with the wing using the actuator surface model

forces = []

# Calculate Kutta-Joukowski force
kuttajoukowski = uns.generate_aerodynamicforce_kuttajoukowski(KJforce_type,
                                sigma_vlm_surf, sigma_rotor_surf,
                                vlm_vortexsheet, vlm_vortexsheet_overlap,
                                vlm_vortexsheet_distribution,
                                vlm_vortexsheet_sigma_tbv;
                                vehicle=vehicle)
push!(forces, kuttajoukowski)

# Free-vortex force
if include_freevortices
    freevortices = uns.generate_calc_aerodynamicforce_freevortices(
                                            vlm_vortexsheet_maxstaticparticle,
                                            sigma_vlm_surf,
                                            vlm_vortexsheet,
                                            vlm_vortexsheet_overlap,
                                            vlm_vortexsheet_distribution,
                                            vlm_vortexsheet_sigma_tbv;
                                            Ffv=uns.Ffv_direct,
                                            include_TBVs=include_freevortices_TBVs
                                            )
    push!(forces, freevortices)
end

# Force due to unsteady circulation
if include_unsteadyforce
    unsteady(args...; optargs...) = uns.calc_aerodynamicforce_unsteady(args...;
                                      add_to_Ftot=add_unsteadyforce, optargs...)

    push!(forces, unsteady)
end

# Parasatic-drag force (form drag and skin friction)
if include_parasiticdrag
    parasiticdrag = uns.generate_aerodynamicforce_parasiticdrag(
                            wing_polar_file;
                            read_path=joinpath(data_path, &quot;airfoils&quot;),
                            calc_cd_from_cl=calc_cd_from_cl,
                            add_skinfriction=add_skinfriction,
                            Mach=speedofsound!=nothing ? magVinf/speedofsound : nothing
                            )

    push!(forces, parasiticdrag)
end


# Stitch all the forces into one function
function calc_aerodynamicforce_fun(vlm_system, args...; per_unit_span=false, optargs...)

    # Delete any previous force field
    fieldname = per_unit_span ? &quot;ftot&quot; : &quot;Ftot&quot;
    if fieldname in keys(vlm_system.sol)
        pop!(vlm_system.sol, fieldname)
    end

    Ftot = nothing

    for (fi, force) in enumerate(forces)
        Ftot = force(vlm_system, args...; per_unit_span=per_unit_span, optargs...)
    end

    return Ftot
end






# ------------- 4) MONITORS DEFINITIONS ----------------------------------------

# Generate wing monitor
L_dir = [-sind(AOA), 0, cosd(AOA)]          # Direction of lift
D_dir = [ cosd(AOA), 0, sind(AOA)]          # Direction of drag

monitor_wing = uns.generate_monitor_wing(wing, Vinf, b, ar,
                                            rho, qinf, nsteps;
                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,
                                            include_trailingboundvortex=include_trailingboundvortex,
                                            L_dir=L_dir,
                                            D_dir=D_dir,
                                            save_path=save_path,
                                            run_name=run_name*&quot;-wing&quot;,
                                            figname=&quot;wing monitor&quot;,
                                            )

# Generate rotors monitor
monitor_rotors = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;
                                            t_scale=RPM/60,        # Scaling factor for time in plots
                                            t_lbl=&quot;Revolutions&quot;,   # Label for time axis
                                            save_path=save_path,
                                            run_name=run_name*&quot;-rotors&quot;,
                                            figname=&quot;rotors monitor&quot;,
                                            )

# Generate monitor of flow enstrophy (indicates numerical stability)
monitor_enstrophy = uns.generate_monitor_enstrophy(;
                                            save_path=save_path,
                                            run_name=run_name,
                                            figname=&quot;enstrophy monitor&quot;
                                            )

# Generate monitor of SFS model coefficient Cd
monitor_Cd = uns.generate_monitor_Cd(;      save_path=save_path,
                                            run_name=run_name,
                                            figname=&quot;Cd monitor&quot;
                                            )


# Concatenate monitors
all_monitors = [monitor_enstrophy, monitor_Cd]

add_wing ? push!(all_monitors, monitor_wing) : nothing
add_rotors ? push!(all_monitors, monitor_rotors) : nothing

monitors = uns.concatenate(all_monitors...)

# Concatenate user-defined runtime function
extra_runtime_function = uns.concatenate(monitors, wake_treatments...)



# ------------- 5) RUN SIMULATION ----------------------------------------------
println(&quot;Running simulation...&quot;)


# Run simulation
uns.run_simulation(simulation, nsteps;

                    # ----- SIMULATION OPTIONS -------------
                    Vinf=Vinf,
                    rho=rho, mu=mu, sound_spd=speedofsound,

                    # ----- SOLVERS OPTIONS ----------------
                    vpm_integration=vpm_integration,
                    vpm_viscous=vpm_viscous,
                    vpm_SFS=vpm_SFS,

                    p_per_step=p_per_step,
                    max_particles=max_particles,

                    sigma_vpm_overwrite=sigma_vpm_overwrite,
                    sigma_rotor_surf=sigma_rotor_surf,
                    sigma_vlm_surf=sigma_vlm_surf,

                    vlm_rlx=vlm_rlx,
                    vlm_vortexsheet=vlm_vortexsheet,
                    vlm_vortexsheet_overlap=vlm_vortexsheet_overlap,
                    vlm_vortexsheet_distribution=vlm_vortexsheet_distribution,
                    vlm_vortexsheet_sigma_tbv=vlm_vortexsheet_sigma_tbv,
                    max_static_particles=vlm_vortexsheet_maxstaticparticle,

                    hubtiploss_correction=hubtiploss_correction,

                    shed_starting=shed_starting,
                    shed_unsteady=shed_unsteady,
                    unsteady_shedcrit=unsteady_shedcrit,

                    extra_runtime_function=extra_runtime_function,

                    # ----- OUTPUT OPTIONS ------------------
                    save_path=save_path,
                    run_name=run_name,
                    prompt=prompt,
                    save_wopwopin=false,  # &lt;--- Generates input files for PSU-WOPWOP noise analysis if true

                    );






# ----------------- 6) VISUALIZATION -------------------------------------------
if paraview
    println(&quot;Calling Paraview...&quot;)

    # Files to open in Paraview
    files = joinpath(save_path, run_name*&quot;_pfield...xmf;&quot;)

    if add_rotors
        for ri in 1:nrotors
            for bi in 1:B
                global files *= run_name*&quot;_Rotor$(ri)_Blade$(bi)_loft...vtk;&quot;
            end
        end
    end

    if add_wing
        files *= run_name*&quot;_Wing_vlm...vtk;&quot;
    end

    # Call Paraview
    run(`paraview --data=$(files)`)

end</code></pre><span style="font-size: 0.9em; color:gray;"><i>
    Low fidelity run time: 13 minutes a Dell Precision 7760 laptop. <br>
    Mid-low fidelity run time: 25 minutes a Dell Precision 7760 laptop. <br>
    Mid-high fidelity run time: 70 minutes a Dell Precision 7760 laptop. <br>
    High fidelity runtime: ~2 days on a 16-core AMD EPYC 7302 processor.
</i></span>
<br><br><center>
    <br><br>
    <b>Mid-High Fidelity</b>
    <br>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//prowimblown-compexp-midfi-composed.png" alt="Pic here" style="width: 100%;"/>
    <br><br><br><br>
    <b>High Fidelity</b>
    <br>
    <img src="https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//prowimblown-compexp-hifi-composed.png" alt="Pic here" style="width: 100%;"/>
    <br><br><br>
</center><p>The favorable comparison with the experiment at <span>$\alpha=0^\circ$</span> and <span>$4^\circ$</span> confirms that ASM accurately predicts prop-on-wing interactions up to a moderate angle of attack. At <span>$\alpha=10^\circ$</span> we suspect that the wing is mildly stalled in the experiment, leading to a larger discrepancy (further discussed in <a href="https://scholarsarchive.byu.edu/etd/9589">Alvarez&#39; Dissertation</a><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> and <a href="https://arc.aiaa.org/doi/abs/10.2514/1.C037279">Alvarez &amp; Ning, 2023</a><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>).</p><div class="admonition is-info"><header class="admonition-header">Source file</header><div class="admonition-body"><p>Full example available under <a href="https://github.com/byuflowlab/FLOWUnsteady/blob/master/examples/prowim">examples/prowim/</a>.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>E. J. Alvarez (2022), &quot;Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,&quot; <em>Doctoral Dissertation, Brigham Young University</em>. <a href="https://www.nas.nasa.gov/pubs/ams/2022/08-09-22.html"><strong>[VIDEO]</strong></a> <a href="https://scholarsarchive.byu.edu/etd/9589/"><strong>[PDF]</strong></a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>E. J. Alvarez and A. Ning (2023), &quot;Meshless Large-Eddy Simulation of Propeller–Wing Interactions with Reformulated Vortex Particle Method,&quot; <em>Journal of Aircraft</em>. <a href="https://arc.aiaa.org/doi/abs/10.2514/1.C037279"><strong>[DOI]</strong></a><a href="https://scholarsarchive.byu.edu/facpub/6902/"><strong>[PDF]</strong></a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../blownwing-asm/">« Actuator Surface Model</a><a class="docs-footer-nextpage" href="../vahana-vehicle/">Vehicle Definition »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 22 January 2024 07:45">Monday 22 January 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
