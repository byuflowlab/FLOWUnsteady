var documenterSearchIndex = {"docs":
[{"location":"api/flowunsteady-vehicle-asm/#Actuator-surface-model","page":"Actuator surface model","title":"Actuator surface model","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-asm/","page":"Actuator surface model","title":"Actuator surface model","text":"FLOWUnsteady.g_uniform\nFLOWUnsteady.g_linear\nFLOWUnsteady.g_piecewiselinear\nFLOWUnsteady.g_pressure","category":"page"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_uniform","page":"Actuator surface model","title":"FLOWUnsteady.g_uniform","text":"Uniform vortex-sheet distribution for actuator surface model. See Alvarez' dissertation, Sec. 6.3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_linear","page":"Actuator surface model","title":"FLOWUnsteady.g_linear","text":"Linear vortex-sheet distribution for actuator surface model. See Alvarez' dissertation, Sec. 6.3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_piecewiselinear","page":"Actuator surface model","title":"FLOWUnsteady.g_piecewiselinear","text":"Alias for FLOWUnsteady.g_linear.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_pressure","page":"Actuator surface model","title":"FLOWUnsteady.g_pressure","text":"Pressure-like vortex-sheet distribution for actuator surface model. See Alvarez' dissertation, Sec. 6.3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/flowvpm-utils/","page":"Utilities","title":"Utilities","text":"FLOWUnsteady.vpm.run_vpm!\nFLOWUnsteady.vpm.save\nFLOWUnsteady.vpm.read\nFLOWUnsteady.vpm.save_settings\nFLOWUnsteady.vpm.read_settings","category":"page"},{"location":"api/flowvpm-utils/#FLOWVPM.run_vpm!","page":"Utilities","title":"FLOWVPM.run_vpm!","text":"run_vpm!(pfield, dt, nsteps; runtime_function=nothing, save_path=nothing, run_name=\"pfield\", nsteps_save=1, verbose=true, prompt=true)\n\nSolves nsteps of the particle field with a time step of dt.\n\nOptional Arguments\n\nruntime_function::Function   : Give it a function of the form                           myfun(pfield, t, dt). On each time step it                           will call this function. Use this for adding                           particles, deleting particles, etc.\nstatic_particles_function::Function   : Give it a function of the form                           myfun(pfield, t, dt) to add static particles                           representing solid boundaries to the solver. This                           function is called at every time step right before                           solving the governing equations, and any new                           particles added by this function are immediately                           removed.\nsave_path::String   : Give it a string for saving VTKs of the particle                           field. Creates the given path.\nrun_name::String    : Name of output files.\nnsteps_save::Int64  : Saves vtks every this many time steps.\nprompt::Bool        : If save_path already exist, it will prompt the                           user before overwritting the folder if true; it will                           directly overwrite it if false.\nverbose::Bool       : Prints progress of the run to the terminal.\nverbose_nsteps::Bool: Number of time steps between verbose.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-utils/#FLOWVPM.save","page":"Utilities","title":"FLOWVPM.save","text":"save(pfield, file_name; path=\"\")\n\nSaves the particle field in HDF5 format and a XDMF file especifying its the attributes. This format can be opened in Paraview for post-processing and visualization.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-types/#vehicle_types","page":"Vehicle types","title":"Vehicle types","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-types/","page":"Vehicle types","title":"Vehicle types","text":"FLOWUnsteady.UVLMVehicle\nFLOWUnsteady.VLMVehicle\nFLOWUnsteady.QVLMVehicle","category":"page"},{"location":"api/flowunsteady-vehicle-types/#FLOWUnsteady.UVLMVehicle","page":"Vehicle types","title":"FLOWUnsteady.UVLMVehicle","text":"UVLMVehicle{N, M, R}(system; tilting_systems, rotors_systems,\n                                        vlm_system, wake_system, grids)\n\nType handling all geometries and subsystems that define a vehicle made out of FLOWVLM components (Wing, WingSystem, Rotor).\n\nARGUMENTS\n\nsystem::FLOWVLM.WingSystem:        System of all FLOWVLM objects. This system                                   is considered as the entire vehicle. Not all                                   components in this system will be solved,                                   but they will all be rotated and translated                                   according to the maneuver.\n\nOPTIONAL ARGUMENTS\n\ntilting_systems::NTuple{N, FLOWVLM.WingSystem}:   Tuple of all FLOWVLM                                   tilting objects, where tilting_systems[i]                                   contains the i-th FLOWVLM system of lifting                                   surfaces and rotors that tilt together.\nrotors_systems::NTuple{M, Array{vlm.Rotor}}:   Tuple of groups of Rotors                                   that share a common RPM.\nvlm_system::FLOWVLM.WingSystem:    System of all FLOWVLM objects to be solved                                   through the VLM solver.\nwake_system::FLOWVLM.WingSystem:   System of all FLOWVLM objects that will                                   shed a VPM wake.\ngrids::Array{gt.GridTypes}:         Array of grids that will be translated and                                   rotated along with system.\n\nState variables\n\nV::Vector                   : Current vehicle velocity\nW::Vector                   : Current vehicle angular velocity\nprev_data::Array{Any}       : Information about previous step\ngrid_O::Vector{Vector}       : Origin of every grid\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-vehicle-types/#FLOWUnsteady.VLMVehicle","page":"Vehicle types","title":"FLOWUnsteady.VLMVehicle","text":"Alias for FLOWUnsteady.UVLMVehicle\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-vehicle-types/#FLOWUnsteady.QVLMVehicle","page":"Vehicle types","title":"FLOWUnsteady.QVLMVehicle","text":"QVLMVehicle{N, M, R}(system; optargs...)\n\nSame than FLOWUnsteady.UVLMVehicle but replacing the VPM wake with a semi-infinite rigid VLM wake, making the simulation quasi-ssteady.\n\nNOTE: For the solver to work correctly, all components in wake_system (if any) need to be also components of vlm_system.\n\nNOTE 2: It is recommended that wake_system doesn't include any Rotor object. Otherwise, blades will generate a wake going straight out of every blade trailing edge pointing oposite to the direction of rotation instead of generating a streamtube.\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-postprocessing-noise/#Aeroacoustic-Noise","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"","category":"section"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"FLOWUnsteady.run_noise_wopwop\nFLOWUnsteady.run_noise_bpm","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/#FLOWUnsteady.run_noise_wopwop","page":"Aeroacoustic Noise","title":"FLOWUnsteady.run_noise_wopwop","text":"Given the path of a FLOWUnsteady simulation read_path, it runs the noise analysis on the rotors of the simulation. It uses PSU-WOPWOP to calculate the tonal noise from thickness and loading sources on the geometry and aerodynamic loading.\n\nrun_noise_wopwop(\n    read_path::String,              # Path from where to read aerodynamic solution (FLOWUnsteady simulation)\n    run_name,                       # Run name (prefix of rotor files to read)\n    RPM::Real,                      # Reference RPM to convert `nrevs` to simulation time\n    rho::Real, speedofsound::Real,  # Air density and speed of sound\n    rotorsystems,                   # `rotorsystems[i][j]` is the number of blades of the j-th rotor in the i-th system\n    ww_nrevs,                       # Run PSU-WOPWOP for this many revolutions\n    ww_nsteps_per_rev,              # Number of steps per revolution to use in WW\n    save_path::String,              # Where to save PSU-WOPWOP results\n    wopwopbin;                      # Path to PSU-WOPWOP binary\n    nrevs           = nothing,      # Number of revolutions to read (defaults to `ww_nrevs`)\n    nsteps_per_rev  = nothing,      # Number of steps per revolution to read (default to `ww_nsteps_per_rev`)\n\n    # ---------- OBSERVERS ---------------------------------------\n    Vobserver   = nothing,          # (m/s) velocity of observer (vector)\n    sph_R       = 1.5*6.5,          # (m) sphere radius\n    sph_nR      = 0,                # Number of cells in radial direction\n    sph_ntht = 24, sph_nphi = 24,   # Number of cells in polar and azimuthal directions\n    sph_thtmin = 5, sph_thtmax = 175,   # (deg) Bounds of polar direction\n    sph_phimax  = 180,              # (deg) maximum azimuthal angle (use 180 to make a hemisphere)\n    sph_rotation= [0, 90, 0],       # (degs) rotate the sphere by these angles\n    sph_C       = zeros(3),         # (m) center of sphere\n    microphoneX = nothing,          # If given, replaces sphere with one observer at this position\n    highpass = nothing, lowpass = nothing, # Low and high pass filters\n    windowing   = nothing,          # Windowing method\n    output_octaves = true,          # Whether to output octave bands\n    Noctave     = 3,                # Number of octave bands\n\n    # ---------- SIMULATION OPTIONS -----------------------------\n    periodic    = true,             # Whether rotor loading and translation in aerodynamic solution is periodic\n\n    # ---------- INPUT OPTIONS ----------------------------------\n    num_min     = 0,                # Start reading loading files from this number\n    const_geometry = false,         # Whether to run PSW on a constant geometry, obtained from num_min\n    axisrot     = \"automatic\",      # Axis of rotation to use for constant geometry (defaults to [1,0,0])\n    CW          = true,             # Clockwise or counter-clockwise rotation of constant geometry\n\n    # ---------- OUTPUT OPTIONS ---------------------------------\n    prompt      = true,             # Whether to prompt the user\n    verbose     = true,             # Whether to verbose\n    v_lvl       = 0,                # Indentation level when printing verbose\n    debug_paraview = false,         # Whether to visualize the grid of observers in Paraview before running\n    debuglvl    = 1,                # PSU-WOPWOP debug level\n    observerf_name = \"observergrid\",# .xyz file with observer grid\n    case_name   = \"runcase\",        # Name of case to create and run\n)\n\nNOTE: This function will call the PSU-WOPWOP binary indicated through wopwopbin. This binary is not included with FLOWUnsteady and must be provided by the user. This method has been tested on PSU-WOPWOP v3.4.2.\n\nNOTE 2: Make sure that the simulation was run with nsteps_save=1, otherwise the time in PSU-WOPWOP will get messed up.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-noise/#FLOWUnsteady.run_noise_bpm","page":"Aeroacoustic Noise","title":"FLOWUnsteady.run_noise_bpm","text":"Calculates broadband rotor noise through the Brooks, Pope, and Marcolini method using the BPM.jl package.\n\nThis writes the results to a file in the same format than PSU-WOPWOP, which can be read afterwards with FLOWNoise.readwopwopoutput(). It writes three files: SPL (non-weighted), A-weighted SPL, and OASPL.\n\nThis method assumes steady conditions and that all rotors have the same RPM.\n\nfunction run_noise_bpm(\n    rotors::Array{vlm.Rotor, 1},    # Rotors\n    RPM::Real,                      # RPM of rotors\n    Vinf::Function,                 # Freestream\n    rho::Real, mu::Real, speedofsound::Real, # Air density, dynamic viscosity, and speed of sound\n    save_path::String;              # Where to save results\n\n    # ---------- OBSERVERS --------------------------------------\n    sph_R       = 1.5*6.5,          # (m) sphere radius\n    sph_nR      = 0,                # Number of cells in radial direction\n    sph_ntht = 24, sph_nphi = 24,   # Number of cells in polar and azimuthal directions\n    sph_thtmin = 5, sph_thtmax = 175,   # (deg) Bounds of polar direction\n    sph_phimax  = 180,              # (deg) maximum azimuthal angle (use 180 to make a hemisphere)\n    sph_rotation= [0, 90, 0],       # (degs) rotate the sphere by these angles\n    sph_C       = zeros(3),         # (m) center of sphere\n    microphoneX = nothing,          # If given, replaces sphere with one observer at this position\n\n    # ---------- BPM OPTIONS ------------------------------------\n    noise_correction = 0.5,         # Broadband calibration correction\n    TE_thickness::Union{Float64, Array{Float64, 1}}=16.15,  # Trailing edge thickness (in degrees)\n    freq_bins   = BPM.default_f,    # Frequency bins\n    db_offset   = BPM.default_AdB,  # dB offset of every frequency for A-weighting\n\n    # ---------- OUTPUT OPTIONS ---------------------------------\n    prompt      = true,             # Whether to prompt the user\n    verbose     = true,             # Whether to verbose\n    v_lvl       = 0,                # Indentation level when printing verbose\n)\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#Particle-Field","page":"Particle Field","title":"Particle Field","text":"","category":"section"},{"location":"api/flowvpm-particle/","page":"Particle Field","title":"Particle Field","text":"FLOWUnsteady.vpm.Particle\nFLOWUnsteady.vpm.ParticleField\nFLOWUnsteady.vpm.ClassicVPM\nFLOWUnsteady.vpm.ReformulatedVPM\nFLOWUnsteady.vpm.add_particle\nFLOWUnsteady.vpm.get_particle\nFLOWUnsteady.vpm.remove_particle\nFLOWUnsteady.vpm.get_np\nFLOWUnsteady.vpm.iterate\nFLOWUnsteady.vpm.get_particleiterator","category":"page"},{"location":"api/flowvpm-particle/#FLOWVPM.Particle","page":"Particle Field","title":"FLOWVPM.Particle","text":"`Particle{T}`\n\nVortex particle data structure\n\nState variables\n\nX::Array{T, 1}                : Position (3-elem array)\nGamma::Array{T, 1}            : Vectorial circulation (3-elem array)\nsigma::Array{T, 1}            : Smoothing radius (1-elem array)\nvol::Array{T, 1}              : Volume (1-elem array)\ncirculation::Array{T, 1}      : Scalar circulation (1-elem array)\n\nPublic calculations\n\nU::Array{T, 1}                : Velocity at particle (3-elem array)\nJ::Array{T, 2}                : Jacobian at particle J[i,j]=dUi/dxj (9-elem array)\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-particle/#FLOWVPM.add_particle","page":"Particle Field","title":"FLOWVPM.add_particle","text":"add_particle(self::ParticleField, X, Gamma, sigma; vol=0, index=np)\n\nAdd a particle to the field.\n\n\n\n\n\nadd_particle(self::ParticleField, P::Particle)\n\nAdd a copy of Particle P to the field.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.get_particle","page":"Particle Field","title":"FLOWVPM.get_particle","text":"`get_particle(pfield::ParticleField, i)`\n\nReturns the i-th particle in the field.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.remove_particle","page":"Particle Field","title":"FLOWVPM.remove_particle","text":"remove_particle(pfield::ParticleField, i)\n\nRemove the i-th particle in the field. This is done by moving the last particle that entered the field into the memory slot of the target particle. To remove particles sequentally, you will need to go from the last particle back to the first one (see documentation of get_particleiterator for an example).\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.get_np","page":"Particle Field","title":"FLOWVPM.get_np","text":"`get_np(pfield::ParticleField)`\n\nReturns current number of particles in the field.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.iterate","page":"Particle Field","title":"FLOWVPM.iterate","text":"Alias for get_particleiterator\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.get_particleiterator","page":"Particle Field","title":"FLOWVPM.get_particleiterator","text":"`get_particleiterator(pfield::ParticleField; start_i=1, end_i=np)`\n\nReturn an iterator over particles that can be used as follows\n\njulia> # Initiate particle field\n       pfield = FLOWVPM.ParticleField(10);\n\njulia> # Add particles\n       for i in 1:4\n           FLOWVPM.add_particle(pfield, (i*10^0, i*10^1, i*10^2), zeros(3), 1.0)\n       end\n\njulia> # Iterate over particles\n       for P in FLOWVPM.get_particleiterator(pfield)\n           println(P.X)\n       end\n[1.0, 10.0, 100.0]\n[2.0, 20.0, 200.0]\n[3.0, 30.0, 300.0]\n[4.0, 40.0, 400.0]\n\n\n\n\n\n","category":"function"},{"location":"theory/publications/#Publications","page":"Publications","title":"Publications","text":"","category":"section"},{"location":"theory/publications/","page":"Publications","title":"Publications","text":"The following is a compilation of studies that have used FLOWUnsteady","category":"page"},{"location":"theory/publications/","page":"Publications","title":"Publications","text":"Sarojini D., et al, (2024) “Review of Computational Models for Large-Scale MDAO of Urban Air Mobility Concepts,” AIAA SCITECH Forum.   [DOI]\nS. Shahjahan, A. Gong, A. Moore, D. Verstraete, (2024) “Optimisation of   proprotors for tilt-wing eVTOL aircraft,” Aerospace Science and   Technology.   [PDF]\nE. J. Alvarez, C. Joseph, & A. Ning (2023), \"Vortex Particle Method for   Electric Ducted Fan in Non-Axisymmetric Flow,\" AIAA AVIATION Forum.   [PDF]\nAnderson, R., Ning, A., Xiang, R., Schie, S. P. C. van, Sperry, M., Sarojini,   D., Kamensky, D., & Hwang, J. T., (2023) “Aerostructural Predictions Combining   FEniCS and a Viscous Vortex Particle Method,” AIAA SCITECH Forum.   [PDF]\nE. J. Alvarez & A. Ning (2023), \"Meshless Large Eddy Simulation of   Propeller-Wing Interactions Through the Reformulated Vortex Particle   Method,\" Journal of Aircraft.   [PDF]\nE. J. Alvarez & A. Ning (2023), \"Stable Vortex Particle Method Formulation   for Meshless Large-Eddy Simulation,\" AIAA Journal.   [PDF]\nE. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless   Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham   Young University. [PDF]\nJ. Mehr, E. J. Alvarez, & A. Ning (2022), \"Interactional Aerodynamics   Analysis of a Multi-Rotor Energy Kite,\" (in review).\nE. J. Alvarez, J. Mehr, & A. Ning (2022), \"FLOWUnsteady: An Interactional   Aerodynamics Solver for Multirotor Aircraft and Wind Energy,\"   AIAA AVIATION Forum. [VIDEO]   [PDF]\nR. M. Erhard & J. J. Alonso (2022), \"Comparison of Propeller Wake Models   for Distributed Electric Propulsion and eVTOL Aircraft in Complex Flow   Conditions,\" AIAA SciTech Forum.   [PDF]\nE. J. Alvarez & A. Ning (2020), \"High-Fidelity Modeling of Multirotor   Aerodynamic Interactions for Aircraft Design,\" AIAA Journal.   [DOI]   [PDF]\nJ. Mehr, E. J. Alvarez, & A. Ning (2020), \"Unsteady Aerodynamic Analysis of   Wind Harvesting Aircraft,\" AIAA AVIATION Forum.   [VIDEO]   [PDF]\nE. J. Alvarez, A. Schenk, T. Critchfield, & A. Ning (2020), “Rotor-on-Rotor   Aeroacoustic Interactions of Multirotor in Hover,” VFS 76th Forum.   [PDF]\nE. J. Alvarez & A. Ning (2019), \"Modeling Multirotor Aerodynamic   Interactions Through the Vortex Particle Method,\" AIAA AVIATION Forum.   [PDF]\nE. J. Alvarez & A. Ning (2018). \"Development of a Vortex Particle Code for   the Modeling of Wake Interaction in Distributed Propulsion,\" AIAA AVIATION   Forum.   [PDF]","category":"page"},{"location":"theory/publications/","page":"Publications","title":"Publications","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/light/vorticitytake01-smallreducedslower02-2.gif\"\n              alt=\"Vid here\" style=\"width:50%;\"/>","category":"page"},{"location":"installation/general/#installation","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"FLOWUnsteady is developed in the Julia programming language, which is a modern, high-level, dynamic programming language for high-performance computing. For visualization and postprocessing, FLOWUnsteady uses ParaView, which is an open-source software for scientific and HPC visualization.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"The following instructions walk you through how to install Julia, ParaView, and FLOWUnsteady.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: Windows Users\nOn Windows please follow these instructions first to set up Windows Subsystem for Linux.","category":"page"},{"location":"installation/general/#Julia","page":"Installation","title":"Julia","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Download and install Julia: julialang.org (currently we are only supporting up to Julia v1.8.5, so we recommend using   v1.8.5 or   v1.6.7 LTS   )\nAdd Julia to user-level bin folder\nsudo ln -s /[user-specific-path/Julia-1.x.x]/bin/julia /usr/local/bin/julia\nReplace /[user-specific-path/Julia-1.x.x]/ with the path where Julia got installed. For instance, in MacOS the full path looks like this: /Applications/Julia-1.8.app/Contents/Resources/julia/bin/julia","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you were successfull, typing the following in the terminal will launch the Julia REPL:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"julia","category":"page"},{"location":"installation/general/#paraview","page":"Installation","title":"ParaView","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Download and install ParaView: paraview.org\nAdd ParaView to user-level bin folder\nsudo ln -s /[user-specific-path/ParaView-5.x.x]/paraview /usr/local/bin/paraview\nReplace /[user-specific-path/ParaView-5.x.x]/ with the path where ParaView got installed. For instance, in MacOS the full path looks like this: /Applications/ParaView-5.11.0.app/Contents/MacOS/paraview","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you were successfull, typing the following in the terminal will launch the ParaView:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"paraview","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"To test that ParaView is correctly installed, run one of the examples of the GeometricTools package as follows (copy/paste this in the Julia REPL):","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"# Install GeometricTools\nimport Pkg; Pkg.add(\"GeometricTools\")\n\nimport GeometricTools as gt\n\n# Load example\nexamplepath = joinpath(dirname(pathof(gt)), \"..\", \"examples\", \"example_simple.jl\")\ninclude(examplepath)\n\n# Run example: it will pull up paraview with a good-looking cube\nsimple_box2()","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"ParaView will then pull up with a rendering of a cube (click the Apply button under Properties to make it visible).","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"<p align=\"center\">\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/simple_cube.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</p>","category":"page"},{"location":"installation/general/#pycall","page":"Installation","title":"PyCall","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"One of the dependencies (AirfoilPrep.jl) is a wrapper of Python code that is written in Python v3.8+. For this reason, make sure that your Python version linked to PyCall is 3.8 or higher. You can do that as follows:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"# Install PyCall\nimport Pkg; Pkg.add(\"PyCall\")\n\n# Point environment to your Python 3.8 (or higher)\nENV[\"PYTHON\"] = \"path/to/your/python3\"\n\n# Rebuild PyCall\nPkg.build(\"PyCall\")","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Then close and reopen the Julia REPL, and run:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import PyCall\nPyCall.pyversion","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"which should reveal your Python version:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"v\"3.8\"","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Since PyCall now relies on a custom install of Python3, make sure that:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"matplotlib, mpmath, and scipy are installed in that Python,\npip3 install matplotlib mpmath scipy --user\nFor optimal experience, verify that matplotlib uses the Qt5Agg backend. Useful instructions can be found here and here.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you run into errors with PyPlot while running FLOWUnsteady, they are likely related to one of those two items.","category":"page"},{"location":"installation/general/#FLOWVPM","page":"Installation","title":"FLOWVPM","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"FLOWVPM uses a fast multipole code called ExaFMM that accelerates the computation of particle interactions. ExaFMM is written in C++ and we have developed a Julia wrapper for it: FLOWExaFMM.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Before installing FLOWVPM, first you will have to install FLOWExaFMM and compile ExaFMM, as follows.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Make sure you have CMake, GCC, and OpenMP. On Linux, type to following to install them\nsudo apt-get update\nsudo apt-get install cmake g++ mpich\n[Julia REPL] Install CxxWrap:\nimport Pkg\nPkg.add(name=\"CxxWrap\", version=\"0.11.2\")\n[Terminal] Clone FLOWExaFMM:\ngit clone https://github.com/byuflowlab/FLOWExaFMM path/to/FLOWExaFMM\n(replace path/to/FLOWExaFMM with your preferred path in your local)","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Compile ExaFMM running the script build.sh:\ncd path/to/FLOWExaFMM\nsh build.sh\nor in MacOS:\ncd path/to/FLOWExaFMM\nsh build_macos.sh\nThis should have generated the file fmm.so (or fmm.dylib in MacOS) under src/, which is a binary library containing ExaFMM.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Now that ExaFMM is compiled, you can add FLOWExaFMM to your Julia environment as a development package pointing directly to where you compiled the package and add FLOWVPM:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Add FLOWExaFMM:\n# In the Julia REPL\n] develop path/to/FLOWExaFMM","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"[Optional] Test FLOWExaFMM:\n] test FLOWExaFMM\nThis will return a heart-warming \"Hello world!\" if ExaFMM was correctly compiled.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Add FLOWVPM:\n] add https://github.com/byuflowlab/FLOWVPM.jl","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"[Optional] Test FLOWVPM:\n] test FLOWVPM","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you run into any issues, please try the following:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Test that you can correctly compile C++ code wrapped for Julia following these instructions: LINK\nMac users, take a look at this thread: LINK\nInstructions for BYU Fulton supercomputer: LINK","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If issues persist, please check the resolved issues in the FLOWExaFMM repo, the discussion forum in the FLOWUnsteady repo, and feel free to open a new issue or discussion for help.","category":"page"},{"location":"installation/general/#Other-Packages","page":"Installation","title":"Other Packages","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Run the following commands in the Julia REPL to add some dependencies that are not in the official Julia registry:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import Pkg\n\nurl = \"https://github.com/byuflowlab/\"\n\npackages = ((\"AirfoilPrep.jl\", \"v2.1.2\"), (\"FLOWVLM\", \"v2.1.2\"),\n            (\"BPM.jl\", \"v2.0.1\"), (\"FLOWNoise\", \"v2.3.2\"), (\"VSPGeom.jl\", nothing))\n\nPkg.add([ Pkg.PackageSpec(; url=url*name, rev=v) for (name, v) in packages ])","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: Troubleshooting\nSome things you might need to look out for:(MacOS users) Make sure your Homebrew (in Julia) is up to date. You may need to run the following in order to update your Homebrew: using Homebrew; Homebrew.brew(`update-reset`)\nMake sure that things are in place in your Julia settings. Having things like Conda, HDF5, etc. on your machine doesn't necessarily mean that the Julia implementation has them as well.","category":"page"},{"location":"installation/general/#Add-FLOWUnsteady","page":"Installation","title":"Add FLOWUnsteady","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"You are now ready to install the FLOWUnsteady package. Type this in the Julia REPL:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"] add https://github.com/byuflowlab/FLOWUnsteady","category":"page"},{"location":"installation/general/#Test-FLOWUnsteady","page":"Installation","title":"Test FLOWUnsteady","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"In order to test that FLOWUnsteady and all dependencies were successfully installed, try running some of the examples under FLOWUnsteady/examples/.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"For instance, you can run the Simple Wing example as follows:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import FLOWUnsteady as uns\n\ninclude(joinpath(uns.examples_path, \"wing\", \"wing.jl\"))","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"or you can run the Tethered Wing example:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import FLOWUnsteady as uns\n\ninclude(joinpath(uns.examples_path, \"tetheredwing.jl\"))","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"This will pull up Paraview visualizing the simulation. Kick off your shoes, sit back, and enjoy the simulation that you have just run.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"<br><br>\n\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/tetheredwing-example-00small.gif\" alt=\"Vid here\" style=\"width: 80%;\"/>\n</center>\n\n<br><br><br><br>\n<br><br><br><br>","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: 2D View\nWhen opening a simulation with a flat surface (like wing.jl), ParaView automatically activates its 2D view mode. Disable the 2D view by clicking these two buttons: (Image: pic)","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: CPU Parallelization\nIf any of the examples is taking longer than 10 to 20 minutes to run, it is possible that ExaFMM was compiled without OpenMP, thus running in only one core as opposed to parallelizing the computation across all your CPU cores.To confirm that ExaFMM is successfully parallelized, pull up whatever CPU monitor is available in your operative system and confirm that Julia is using all the cores as the simulation is running. For instance, the Resources tab of the Task Manager in Windows should look like this: (Image: pic) and htop in the terminal (Linux and MacOS) should look like this: (Image: pic)","category":"page"},{"location":"api/flowvpm-time/#Time-Integration","page":"Time Integration","title":"Time Integration","text":"","category":"section"},{"location":"api/flowvpm-time/","page":"Time Integration","title":"Time Integration","text":"FLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.rungekutta3\nFLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.euler","category":"page"},{"location":"api/flowvpm-time/#FLOWVPM.euler","page":"Time Integration","title":"FLOWVPM.euler","text":"Steps the field forward in time by dt in a first-order Euler integration scheme.\n\n\n\n\n\nSteps the field forward in time by dt in a first-order Euler integration scheme using the VPM reformulation. See notebook 20210104.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-time/#FLOWVPM.rungekutta3","page":"Time Integration","title":"FLOWVPM.rungekutta3","text":"Steps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme. See Notebook entry 20180105.\n\n\n\n\n\nSteps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme using the VPM reformulation. See Notebook entry 20180105 (RK integration) and notebook 20210104 (reformulation).\n\n\n\n\n\n","category":"function"},{"location":"examples/propeller-jsweep/#J-Sweep","page":"J Sweep","title":"J Sweep","text":"","category":"section"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"Using the same rotor from the previous section, we now run a sweep of     the advance ratio J = fracu_inftyn d to characterize the     performance of the propeller.","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"#=##############################################################################\n# DESCRIPTION\n    Advance ratio sweep on APC 10 x7 propeller\n=###############################################################################\n\ncase_name       = \"propeller-Jsweep-example\"# Name of this sweep case\nsave_path       = case_name                 # Where to save this sweep\n\nJs              = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.775] # Advance ratios Vinf/(nD)\n\n# Create path where to save sweep\nuns.gt.create_path(save_path, true)\n\n# ----------------- J SWEEP ----------------------------------------------------\nfor J in Js\n\n    println(\"\\n\\n Running J = $(J)\")\n\n    magVinf         = J*RPM/60*(2*R)\n    Vinf(X, t)      = magVinf*[cosd(AOA), sind(AOA), 0] # (m/s) freestream velocity vector\n\n    # ------------- 1) VEHICLE DEFINITION ---------\n    println(\"\\tGenerating geometry...\")\n\n    # Generate rotor\n    rotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                            n=n, CW=CW, blade_r=r,\n                                            altReD=[RPM, J, mu/rho],\n                                            xfoil=xfoil,\n                                            ncrit=ncrit,\n                                            data_path=data_path,\n                                            verbose=false,\n                                            verbose_xfoil=false,\n                                            plot_disc=false\n                                            );\n\n\n    # Generate vehicle\n    system = vlm.WingSystem()                   # System of all FLOWVLM objects\n    vlm.addwing(system, \"Rotor\", rotor)\n\n    rotors = [rotor];                           # Defining this rotor as its own system\n    rotor_systems = (rotors, );                 # All systems of rotors\n\n    wake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                                # NOTE: Do NOT include rotor when using the quasi-steady solver\n    if VehicleType != uns.QVLMVehicle\n        vlm.addwing(wake_system, \"Rotor\", rotor)\n    end\n\n    vehicle = VehicleType(  system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                            );\n\n    # ------------- 2) MANEUVER DEFINITION --------\n    # No changes\n\n    # ------------- 3) SIMULATION DEFINITION ------\n    simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                     Vinit=Vinit, Winit=Winit);\n\n    # ------------- 4) MONITOR DEFINITION ---------\n    monitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                                t_scale=RPM/60,\n                                                t_lbl=\"Revolutions\",\n                                                save_path=save_path,\n                                                run_name=\"J$(ceil(Int, J*100))\",\n                                                disp_conv=false,\n                                                figname=\"rotor monitor J=$(J)\",\n                                                )\n\n    # ------------- 5) RUN SIMULATION -------------\n    println(\"\\tRunning simulation...\")\n\n    uns.run_simulation(simulation, nsteps;\n                        # ----- SIMULATION OPTIONS -------------\n                        Vinf=Vinf,\n                        rho=rho, mu=mu, sound_spd=speedofsound,\n                        # ----- SOLVERS OPTIONS ----------------\n                        p_per_step=p_per_step,\n                        max_particles=max_particles,\n                        vpm_viscous=vpm_viscous,\n                        sigma_vlm_surf=sigma_rotor_surf,\n                        sigma_rotor_surf=sigma_rotor_surf,\n                        sigma_vpm_overwrite=sigma_vpm_overwrite,\n                        vlm_rlx=vlm_rlx,\n                        shed_unsteady=shed_unsteady,\n                        shed_starting=shed_starting,\n                        extra_runtime_function=monitor_rotor,\n                        # ----- OUTPUT OPTIONS ------------------\n                        save_path=nothing,\n                        v_lvl=1, verbose_nsteps=24\n                        );\nend\n","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~12 minutes on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"Check examples/propeller/propeller_jsweep.jl to postprocess and plot the results as shown below.","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"<center>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-Jsweep-example.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/wing-4p2aoa/#simple_wing","page":"Basics","title":"Simple Wing","text":"","category":"section"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-particles06.png\" alt=\"Pic here\" style=\"width: 49%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-n100-00.png\" alt=\"Pic here\" style=\"width: 49%;\"/>\n</center>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"In this example we simulate a 45^circ swept-back wing at an angle of attack of 42^circ. In the process we exemplify the basic structure of simulations, which is always the same, no matter how complex the simulation might be. The structure consists of six steps:","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(1) Vehicle Definition: Generate the geometry of the vehicle and declare each vehicle subsystem in a FLOWUnsteady.VLMVehicle object","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(2) Maneuver Definition: Generate functions that prescribe the kinematics of the vehicle and specify the control inputs for tilting and rotor subsystems in a FLOWUnsteady.KinematicManeuver object","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(3) Simulation Definition: A FLOWUnsteady.Simulation object is generated stating the vehicle, maneuver, and total time and speed at which to perform the maneuver","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(4) Monitors Definitions: Functions are generated for calculating, monitoring, and outputting different metrics throughout the simulation","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(5) Run Simulation: Call to FLOWUnsteady.run_simulation","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(6) Viz and Postprocessing: The simulation is visualized in Paraview and results are postprocessed","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"While in this example we show the basic structure without much explanation, in subsequent examples we will dive into the details and options of each step (which are also listed in the API Guide).","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"#=##############################################################################\n# DESCRIPTION\n    45° swept-back wing at an angle of attack of 4.2°. This wing has an aspect\n    ratio of 5.0, a RAE 101 airfoil section with 12% thickness, and no dihedral,\n    twist, nor taper. This test case matches the experimental setup of Weber,\n    J., and Brebner, G., “Low-Speed Tests on 45-deg Swept-Back Wings, Part I,”\n    Tech. rep., 1951. The same case is used in a VLM calculation in Bertin's\n    Aerodynamics for Engineers, Example 7.2, pp. 343.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Feb 2023\n  * Last updated    : Feb 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\nrun_name        = \"wing-example\"            # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\nAOA             = 4.2                       # (deg) angle of attack\nmagVinf         = 49.7                      # (m/s) freestream velocity\nrho             = 0.93                      # (kg/m^3) air density\nqinf            = 0.5*rho*magVinf^2         # (Pa) static pressure\n\nVinf(X, t)      = magVinf*[cosd(AOA), 0.0, sind(AOA)]  # Freestream function\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\nb               = 2.489                     # (m) span length\nar              = 5.0                       # Aspect ratio b/c_tip\ntr              = 1.0                       # Taper ratio c_tip/c_root\ntwist_root      = 0.0                       # (deg) twist at root\ntwist_tip       = 0.0                       # (deg) twist at tip\nlambda          = 45.0                      # (deg) sweep\ngamma           = 0.0                       # (deg) dihedral\n\n# Discretization\nn               = 50                        # Number of spanwise elements per side\nr               = 10.0                      # Geometric expansion of elements\ncentral         = false                     # Whether expansion is central\n\n# NOTE: A geometric expansion of 10 that is not central means that the last\n#       element is 10 times wider than the first element. If central, the\n#       middle element is 10 times wider than the peripheral elements.\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Time parameters\nwakelength      = 2.75*b                    # (m) length of wake to be resolved\nttot            = wakelength/magVinf        # (s) total simulation time\nnsteps          = 200                       # Number of time steps\n\n# VLM and VPM parameters\np_per_step      = 1                         # Number of particle sheds per time step\n\nlambda_vpm      = 2.0                       # VPM core overlap\nsigma_vpm_overwrite = lambda_vpm * magVinf * (ttot/nsteps)/p_per_step # Smoothing core size\nsigma_vlm_solver= -1                        # VLM-on-VLM smoothing radius (deactivated with <0)\nsigma_vlm_surf  = 0.05*b                    # VLM-on-VPM smoothing radius\n\nshed_starting   = true                      # Whether to shed starting vortex\nvlm_rlx         = 0.7                       # VLM relaxation\n\n\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate wing\nwing = vlm.simpleWing(b, ar, tr, twist_root, lambda, gamma;\n                        twist_tip=twist_tip, n=n, r=r, central=central);\n\n# NOTE: `FLOWVLM.simpleWing` is an auxiliary function in FLOWVLM for creating a\n#       VLM wing with constant sweep, dihedral, and taper ratio, and a linear\n#       twist between the root and the wing tips\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Wing\", wing)\n\nvlm_system = system;                        # System solved through VLM solver\nwake_system = system;                       # System that will shed a VPM wake\n\nvehicle = uns.VLMVehicle(   system;\n                            vlm_system=vlm_system,\n                            wake_system=wake_system\n                         );\n\n# NOTE: `FLOWUnsteady.VLMVehicle` creates a vehicle made out of multiple VLM and\n#       rotor subsystems. The argument `system` represents the vehicle as a\n#       whole which will be translated and rotated with the kinematics\n#       prescribed by the maneuver. The subsystem `vlm_system` will be solved\n#       with the VLM solver. The subsystems `rotor_systems` are solved with\n#       blade elements (none in this case). The subsystem `wake_system` will\n#       shed the VPM wake.\n\n\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n\nVvehicle(t) = zeros(3)                      # Translational velocity of vehicle over time\nanglevehicle(t) = zeros(3)                  # Angle of the vehicle over time\n\nangle = ()                                  # Angle of each tilting system (none)\nRPM = ()                                    # RPM of each rotor system (none)\n\nmaneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time\n#       (a vector with inclination angles with respect to each axis of the\n#       global coordinate system). `angle` defines the tilting angle of each\n#       tilting system over time (none in this case). `RPM` defines the RPM of\n#       each rotor system over time (none in this case).\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled up by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n\n\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = 0.0                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\n                                            # Maximum number of particles\nmax_particles = (nsteps+1)*(vlm.get_m(vehicle.vlm_system)*(p_per_step+1) + p_per_step)\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\n# NOTE: Monitors are functions that are called at every time step to perform\n#       some secondary computation after the solution of that time step has been\n#       obtained. In this case, the wing monitor uses the circulation and\n#       induced velocities to compute aerodynamic forces and decompose them\n#       into lift and drag. The monitor then plots these forces at every time\n#       step while also saving them under a CSV file in the simulation folder.\n\n# Generate function that calculates aerodynamic forces\n# NOTE: We exclude skin friction since we want to compare to the experimental\n#       data reported in Weber 1951 that was measured with pressure taps\ncalc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                    add_parasiticdrag=true,\n                                    add_skinfriction=false,\n                                    airfoilpolar=\"xf-rae101-il-1000000.csv\"\n                                    )\n\nD_dir = [cosd(AOA), 0.0, sind(AOA)]         # Direction of drag\nL_dir = uns.cross(D_dir, [0,1,0])           # Direction of lift\n\nfigs, figaxs = [], []                       # Figures generated by monitor\n\n# Generate wing monitor\nmonitor_wing = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"wing monitor\",\n                                            );\n\n\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    sigma_vlm_solver=sigma_vlm_solver,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_vlm_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    shed_starting=shed_starting,\n                    vlm_rlx=vlm_rlx,\n                    extra_runtime_function=monitor_wing,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_Wing_vlm...vtk\")\n    files *= \";\"*run_name*\"_pfield...xmf;\"\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~3 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (n and steps) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"As the simulation runs, you will see the monitor (shown below) plotting the lift and drag coefficients over time along with the loading distribution. For comparison, here we have also added the experimental measurements reported by Weber and Brebner, 1951.","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-simmonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":" Experimental FLOWUnsteady Error\nC_L 0.238 0.23506 1.234%\nC_D 0.005 0.00501 0.143%","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"info: Paraview visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...). To open in Paraview: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"visualization/#Visualization-Guide","page":"Visualization","title":"Visualization Guide","text":"","category":"section"},{"location":"visualization/#What-*NOT*-to-do","page":"Visualization","title":"What NOT to do","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Unfortunately, the first thing that ParaView shows when you open a particle field is a \"scatter plot\" full of confusing colors like this:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-rainbow00-bad00.jpg\"\n    alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Not surprisingly, the VPM literature is full of these visualizations, which provide very little information about the simulation. Poor colormap aside, why is this a bad visualization? Even though we are coloring the strengths of the particles, one must remember that the particle strength boldsymbolGamma is the integral of the vorticity over the volume that is discretized by the particle, boldsymbolGamma = intlimits_mathrmVol boldsymbolomega mathrmdV. This is equivalent to the average vorticity times the volume, boldsymbolGamma = overlineboldsymbolomega mathrmVol, which means that the particle strength is proportional to the volume that it discretizes. Thus, the particle strength has no physical significance, but is purely a numerical artifact. (In fact, boldsymbolGamma are nothing more than the coefficients of the radial basis function that reconstructs the vorticity field as overlineboldsymbolomegaleft( mathbfxright) approx sumlimits_p boldsymbolGamma_p zeta_sigma_p(mathbfx-mathbfx_p).)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Another VPM visualization that is commonly found in the literature simply shows the position of the particles:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-dots00-bad00.jpg\"\n    alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Why is this a bad visualization? Even though its intent is to depict the flow field by taking advantage of the fact that particles follow streamlines and vortical structures, what is actually visualized is the spatial discretization. After all, we are just looking at the position of the computational elements. Here is an equivalent visualization of the computational elements in a mesh-based simulation of the same rotor in hover:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-mesh00.png\"\n    alt=\"Pic here\" style=\"width: 40%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Not very insightful, is it?","category":"page"},{"location":"visualization/#What-we-recommend","page":"Visualization","title":"What we recommend","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In order to correctly visualize the flow field that is predicted by the VPM solver, one must reconstruct the vorticity field using the particles as a radial basis function and compute the velocity field using the Biot-Savart law. This can be computationally intensive and is not a streamlined process.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Alternatively, a quick visualization that sheds insights into both the flow field and the discretization is to make glyphs that point in the direction of boldsymbolGamma (arrows scaled by magnitude), thus forming the vortex lines:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-glyph02.jpg\"\n    alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-glyph01.jpg\"\n    alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This type of visualization has four advantages:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"It clearly reveals the vortical structure (vortex lines) in a quick glimpse\nOne can envision the velocity field around the vortex lines using the right hand rule (Biot-Savart law shown below)\nAdding small points at the position of each particle gives us an idea of the spatial resolution around vortices\nOne can easily spot if the simulation is becoming numerically unstable since blown-up particles become giant arrows","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-particle01.png\"\n    alt=\"Pic here\" style=\"width: 80%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"info: Glyph Visualization\nA .pvsm file with a glyph visualization of the particle field is available here: LINK (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"visualization/#Fluid-domain","page":"Visualization","title":"Fluid domain","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"While the \"glyph\" visualization shown above uses the native variables that are computed and outputted by the VPM (boldsymbolGamma_p and mathbfx_p), the full fluid domain can be computed from the particle field in postprocessing. This is done using the particles as a radial basis function to construct a continuous and analytical vorticity field boldsymbolomega(mathbfx), and the Biot-Savart law is used to obtain a continuous and analytical velocity field mathbfu(mathbfx). Since boldsymbolomega(mathbfx) and mathbfu(mathbfx) are analytical functions, their values and their derivatives can be calculated anywhere in space.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"FLOWUnsteady provides the function uns.computefluiddomain that reads a simulation and processes it to generate its fluid domain. See the Rotor in Hover tutorial for an example on how to use uns.computefluiddomain.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Whenever reporting results, we recommend showing the vortex elements (glyph visualization) and the fluid domain side by side to give a clear idea of the spatial resolution and the resulting flow field (see example below), which is custom in conventional mesh-based CFD.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-highfidelity00.png\"\n    alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-meshbased00.png\"\n      alt=\"Pic here\" style=\"width: 85%;\"/>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<br><br>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Here is an example of a simulation superimposing the particle field and the resulting fluid domain:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/Bf4pIt7oi5k?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"info: Volume Rendering\nA .pvsm file with a volume rendering of the vorticity field is   available here:   LINK   (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then   select \"Search files under specified directory\" and point it to the   folder where the simulation was saved.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"tip: Practice Dataset and Template\nTo help you practice in ParaView, we have uploaded the particle field   and fluid domain of the DJI 9443 rotor case of   mid-high fidelity and high fidelity simulations:High fidelity: LINK\nMid-high fidelity: LINKWe have also added a .pvsm ParaView state file that you can use as a   template for visualizing your particle field with glyphs and processing the   fluid domain.   To open in ParaView: File → Load State → (select .pvsm file) then   select \"Search files under specified directory\" and point it to the   folder with your simulation results.","category":"page"},{"location":"examples/propeller-J040/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//apc10x7ccblongwake_J035_00cont03_img1_00.gif\" alt=\"Vid here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"In this example we first simulate an APC Thin-Electric 10x7 propeller operating in cruise conditions. Along the way, we demonstrate the basics of how to set up and run a rotor simulation.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"Rotors are generated through the function FLOWUnsteady.generate_rotor, which can receive either a set of parameters that define the rotor geometry (like twist/chord/sweep distributions, etc), or it can read the rotor geometry from a file. FLOWunsteady provides a prepopulated database of airfoil and rotor geometries to automate the generation of rotors, which is found under database/. This database can be accessed through the variable FLOWUnsteady.default_database. Alternatively, users can define their own database with custom rotors and airfoils.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"The following slides describe the structure of the database, using a DJI rotor as an example:","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"    <div style=\"position:relative;padding-top:50%;\">\n        <iframe style=\"position:absolute;left:0;top:0;height:100%;width:80%;\" src=\"https://docs.google.com/presentation/d/e/2PACX-1vRsYbuuMFQdc05NRrQ3Db0RT4XKKoxEYDiUi0MpW58W6A-pp0sDHQI9mVqNFagPtQ/embed?start=true&loop=true&delayms=3000\" frameborder=\"0\" width=\"100%\" height=\"100%\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n    </div>\n    <br><br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"In this simulation we exemplify the following:","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"How to generate a rotor with uns.generate_rotor\nHow to generate a rotor monitor with uns.generate_monitor_rotors\nHow to set up and run a rotor simulation.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of an APC Thin-Electric 10x7 propeller (two-bladed rotor, 10-inch\n    diameter).\n\n    This example replicates the experiment and simulation described in McCrink &\n    Gregory (2017), \"Blade Element Momentum Modeling of Low-Reynolds Electric\n    Propulsion Systems.\"\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\nimport FLOWVPM as vpm\n\nrun_name        = \"propeller-example\"       # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n\n# Rotor geometry\nrotor_file      = \"apc10x7.csv\"             # Rotor geometry\ndata_path       = uns.def_data_path         # Path to rotor database\npitch           = 0.0                       # (deg) collective pitch of blades\nCW              = false                     # Clock-wise rotation\nxfoil           = true                      # Whether to run XFOIL\nncrit           = 9                         # Turbulence criterion for XFOIL\n\n# NOTE: If `xfoil=true`, XFOIL will be run to generate the airfoil polars used\n#       by blade elements before starting the simulation. XFOIL is run\n#       on the airfoil contours found in `rotor_file` at the corresponding\n#       local Reynolds and Mach numbers along the blade.\n#       Alternatively, the user can provide pre-computer airfoil polars using\n#       `xfoil=false` and pointing to polar files through `rotor_file`.\n\n# Discretization\nn               = 20                        # Number of blade elements per blade\nr               = 1/5                       # Geometric expansion of elements\n\n# NOTE: Here a geometric expansion of 1/5 means that the spacing between the\n#       tip elements is 1/5 of the spacing between the hub elements. Refine the\n#       discretization towards the blade tip like this in order to better\n#       resolve the tip vortex.\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n\n# Operating conditions\nRPM             = 9200                      # RPM\nJ               = 0.4                       # Advance ratio Vinf/(nD)\nAOA             = 0                         # (deg) Angle of attack (incidence angle)\n\nrho             = 1.225                     # (kg/m^3) air density\nmu              = 1.81e-5                   # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\n\nmagVinf         = J*RPM/60*(2*R)\nVinf(X, t)      = magVinf*[cosd(AOA), sind(AOA), 0] # (m/s) freestream velocity vector\n\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number\nMatip           = 2*pi*RPM/60*R / speedofsound      # Tip Mach number\n\nprintln(\"\"\"\n    RPM:    $(RPM)\n    Vinf:   $(Vinf(zeros(3), 0)) m/s\n    Matip:  $(round(Matip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n\"\"\")\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n# VehicleType   = uns.QVLMVehicle           # Quasi-steady solver\nconst_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the\n                                                # solution is constant or not\n# Time parameters\nnrevs           = 4                         # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\np_per_step      = 2                         # Sheds per time step\nshed_starting   = true                      # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nmax_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles\n\n# Regularization\nsigma_rotor_surf= R/40                      # Rotor-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\n\n# Rotor solver\nvlm_rlx         = 0.7                       # VLM relaxation <-- this also applied to rotors\nhubtiploss_correction = vlm.hubtiploss_nocorrection # Hub and tip loss correction\n\n# VPM solver\nvpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme\n\n# NOTE: In most practical situations, open rotors operate at a Reynolds number\n#       high enough that viscous diffusion in the wake is negligible.\n#       Hence, it does not make much of a difference whether we run the\n#       simulation with viscous diffusion enabled or not.\n\n\nif VehicleType == uns.QVLMVehicle\n    # NOTE: If the quasi-steady solver is used, this mutes warnings regarding\n    #       potential colinear vortex filaments. This is needed since the\n    #       quasi-steady solver will probe induced velocities at the lifting\n    #       line of the blade\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate rotor\nrotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                        n=n, CW=CW, blade_r=r,\n                                        altReD=[RPM, J, mu/rho],\n                                        xfoil=xfoil,\n                                        ncrit=ncrit,\n                                        data_path=data_path,\n                                        verbose=true,\n                                        verbose_xfoil=false,\n                                        plot_disc=true\n                                        );\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Rotor\", rotor)\n\nrotors = [rotor];                           # Defining this rotor as its own system\nrotor_systems = (rotors, );                 # All systems of rotors\n\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle\n    vlm.addwing(wake_system, \"Rotor\", rotor)\nend\n\nvehicle = VehicleType(   system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n# NOTE: Through the `rotor_systems` keyword argument to `uns.VLMVehicle` we\n#       have declared any systems (groups) of rotors that share a common RPM.\n#       We will later declare the control inputs to each rotor system when we\n#       define the `uns.KinematicManeuver`.\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = zeros(3)\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = (RPMcontrol, )                       # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time.\n#       `angle` defines the tilting angle of each tilting system over time.\n#       `RPM` defines the RPM of each rotor system over time.\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\n\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\nfigs, figaxs = [], []                       # Figures generated by monitor\n\n# Generate rotor monitor\nmonitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                            t_scale=RPM/60,        # Scaling factor for time in plots\n                                            t_lbl=\"Revolutions\",   # Label for time axis\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"rotor monitor\",\n                                            )\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho, mu=mu, sound_spd=speedofsound,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    vpm_viscous=vpm_viscous,\n                    sigma_vlm_surf=sigma_rotor_surf,\n                    sigma_rotor_surf=sigma_rotor_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    vlm_rlx=vlm_rlx,\n                    hubtiploss_correction=hubtiploss_correction,\n                    shed_unsteady=shed_unsteady,\n                    shed_starting=shed_starting,\n                    extra_runtime_function=monitor_rotor,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_pfield...xmf;\")\n    for bi in 1:B\n        global files\n        files *= run_name*\"_Rotor_Blade$(bi)_loft...vtk;\"\n        files *= run_name*\"_Rotor_Blade$(bi)_vlm...vtk;\"\n    end\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~2 minutes on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"As the simulation runs, you will see the monitor shown below plotting the blade loading along with thrust and torque coefficients and propulsive efficiency.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-example-simmonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/rotorhover-acoustics/#rotorhovernoise","page":"Aeroacoustics","title":"Aeroacoustic Noise","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443_ccblade01_1.gif\" alt=\"Pic here\" style=\"width:75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Using the aerodynamic solution obtained in the previous section, we can now feed the time-resolved loading and blade motion to PSU-WOPWOP and BPM.jl to compute aeroacoustic noise. PSU-WOPWOP is a Ffowcs Williams-Hawkings acoustic analogy using the time-domain integral Farassat 1A formulation to compute tonal noise from loading and thickness sources (FLOWUnsteady uses a compact representation for the loading source, while using the actual 3D loft of the blade for the thickness source). BPM.jl is an implementation of the semi-empirical methodology developed by Brooks, Pope, and Marcolini to predict broadband noise. The methodology models five self-noise mechanisms due to boundary-layer phenomena: boundary-layer turbulence passing the trailing edge, separated boundary-layer and stalled-airfoil flow, vortex shedding due to laminar-boundary-layer instabilities, vortex shedding from blunt trailing edges, and turbulent flow due to vortex tip formation.","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"In the following code we exemplify the following:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"How to define observers (microphones) to probe the aeroacoustic noise\nHow to call PSU-WOPWOP through uns.run_noise_wopwop\nHow to call BPM.jl through uns.run_noise_bpm\nHow to add the tonal and broadband noise together and postprocess","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"As a reference, this is the orientation of the rotor and microphone array used in this example:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//ransnoise_dji9443_single_new01_00_2.gif\" alt=\"Pic here\" style=\"width:50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"info: PSU-WOPWOP\nPSU-WOPWOP is a closed-source code that is not included in FLOWUnsteady, but is graciously made available as a binary by its developers at Penn State University upon inquiry. We recommend contacting them directly to obtain a binary.FLOWUnsteady has been tested with PSU-WOPWOP v3.4.4.","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"","category":"page"},{"location":"examples/rotorhover-acoustics/#Preamble","page":"Aeroacoustics","title":"Preamble","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"We load FLOWUnsteady and the FLOWUnsteady.noise module:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"import FLOWUnsteady as uns\nimport FLOWUnsteady: gt, vlm, noise\n\n# Path where to read and save simulation data\nsims_path = \"/media/edoalvar/T7/simulationdata202304\"\n","category":"page"},{"location":"examples/rotorhover-acoustics/#Tonal-Noise","page":"Aeroacoustics","title":"Tonal Noise","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"First, we calculate the tonal noise from loading and thickness sources. The loading of each blade is read from each time step of the the aerodynamic solution, which is an unsteady loading. The thickness is computed from the 3D lofted geometry that is also outputted by the aero solution.","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"These files are read calling uns.run_noise_wopwop, which converts the outputs of the aero solution into a PSU-WOPWOP case. The PSU-WOPWOP binary is then called to read the case and propagate the noise to a set of observers (microphones). The PSU-WOPWOP solution is then written to the same case folder.","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"# Path from where to read aerodynamic solution\nread_path       = joinpath(sims_path, \"rotorhover-example-midhigh00\") # <-- This must point to you aero simulation\n\n# Path where to save PSU-WOPWOP outputs\nsave_ww_path    = read_path*\"-pww/\"\n\n# Path to PSU-WOPWOP binary (not included in FLOWUnsteady)\nwopwopbin       = \"/home/edoalvar/Dropbox/WhisperAero/OtherCodes/PSU-WOPWOP_v3.4.4/wopwop3_linux_serial\"\n\n# Run name (prefix of rotor files to read)\nrun_name        = \"singlerotor\"\n\n# Make this `true` if the aero simulation used the quasi-steady solver. If so,\n# PSU-WOPWOP will assume that the blade loading and geometry stays constant\n# and will read only one step out of the aero solution\nconst_solution  = false\n\n# ------------ PARAMETERS ------------------------------------------------------\n# NOTE: Make sure that these parameters match what was used in the\n#       aerodynamic solution\n\n# Rotor geometry\nrotor_file      = \"DJI9443.csv\"        # Rotor geometry\ndata_path       = uns.def_data_path    # Path to rotor database\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\nrotorsystems    = [[B]]                # rotorsystems[si][ri] is the number of blades of the ri-th rotor in the si-th system\n\n# Simulation parameters\nRPM             = 5400                 # RPM here is a reference value to go from nrevs to simulation time\nCW              = false                # Clock-wise rotation of constant geometry (used if const_solution=true)\nrho             = 1.071778             # (kg/m^3) air density\nspeedofsound    = 342.35               # (m/s) speed of sound\n\n# Aero input parameters\nnrevs           = 2                    # Number of revolutions to read\nnrevs_min       = 6                    # Start reading from this revolution\nnsteps_per_rev  = 72                   # Number of steps per revolution in aero solution\nnum_min         = ceil(Int, nrevs_min*nsteps_per_rev) # Start reading aero files from this step number\n\nif const_solution                       # If constant solution, it overrides to read only the first time step\n    nrevs       = nothing\n    nsteps_per_rev = nothing\n    num_min     = 1\nend\n\n\n# PSU-WOPWOP parameters\nww_nrevs        = 18                     # Number of revolutions in PSU-WOPWOP (18 revs at 5400 RPM gives fbin = 5 Hz)\nww_nsteps_per_rev = max(120, 2*nsteps_per_rev) # Number of steps per revolution in PSU-WOPWOP\nconst_geometry  = const_solution       # Whether to run PSU-WOPWOP on constant geometry read from num_min\nperiodic        = true                 # Periodic aerodynamic solution\nhighpass        = 0.0                  # High pass filter (set this to >0 to get rid of 0th freq in OASPL)\n\n# NOTE: `periodic=true` assumes that the aero solution is periodic, which allows\n#       PSU-WOPWOP to simulate more revolutions (`ww_nrevs`) that what is\n#       read from the aero simulation (`nrevs`). This is a good assumption for\n#       an unsteady simulation as long as the loading is somewhat periodic after\n#       the initial transient state (even with small unsteady fluctuations),\n#       but set it to `false` in simulations with complex control inputs\n#       (e.g., maneuvering aircraft, variable RPM, etc). If the outputs of\n#       PSU-WOPWOP seem nonsensical, try setting this to false and increasing\n#       the number of revolutions in the aero solution (`nrevs`).\n\n\n# Observer definition: Circular array of microphones\nsph_R           = 1.905                # (m) radial distance from rotor hub\nsph_nR          = 0                    # Number of microphones in the radial direction\nsph_nphi        = 0                    # Number of microphones in the zenith direction\nsph_ntht        = 72                   # Number of microphones in the azimuthal direction\nsph_thtmin      = 0                    # (deg) first microphone's angle\nsph_thtmax      = 360                  # (deg) last microphone's angle\nsph_phimax      = 180\nsph_rotation    = [90, 0, 0]           # Rotation of grid of microphones\n\n# NOTE: Here we have defined the microphone array as a circular array, but\n#       we could have defined a hemisphere instead by simply making `sph_nphi`\n#       different than zero, or a full volumetric spherical mesh making `sph_nR`\n#       different than zero\n\n# Alternative observer definition: Single microphone\nRmic            = 1.905                # (m) radial distance from rotor hub\nanglemic        = 90*pi/180            # (rad) microphone angle from plane of rotation (- below, + above)\n                                       # 0deg is at the plane of rotation, 90deg is upstream\nmicrophoneX     = nothing              # Comment and uncomment this to switch from array to single microphone\n# microphoneX   = Rmic*[-sin(anglemic), cos(anglemic), 0]\n\n\n# ------------ RUN PSU-WOPWOP ----------------------------------------------\n@time uns.run_noise_wopwop(read_path, run_name, RPM, rho, speedofsound, rotorsystems,\n                            ww_nrevs, ww_nsteps_per_rev, save_ww_path, wopwopbin;\n                            nrevs=nrevs, nsteps_per_rev=nsteps_per_rev,\n                            # ---------- OBSERVERS -------------------------\n                            sph_R=sph_R,\n                            sph_nR=sph_nR, sph_ntht=sph_ntht,\n                            sph_nphi=sph_nphi, sph_phimax=sph_phimax,\n                            sph_rotation=sph_rotation,\n                            sph_thtmin=sph_thtmin, sph_thtmax=sph_thtmax,\n                            microphoneX=microphoneX,\n                            # ---------- SIMULATION OPTIONS ----------------\n                            periodic=periodic,\n                            # ---------- INPUT OPTIONS ---------------------\n                            num_min=num_min,\n                            const_geometry=const_geometry,\n                            axisrot=\"automatic\",\n                            CW=CW,\n                            highpass=highpass,\n                            # ---------- OUTPUT OPTIONS --------------------\n                            verbose=true, v_lvl=0,\n                            prompt=true, debug_paraview=false,\n                            debuglvl=0,                     # PSU-WOPWOP debug level (verbose)\n                            observerf_name=\"observergrid\",  # .xyz file with observer grid\n                            case_name=\"runcase\",            # Name of case to create and run\n                            );\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~1 minute on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"info: Frequency bins\nThe length of the frequency bins in the SPL spectrum obtained from the FFT falls out from the following relationshipsbeginalign*\n        f_mathrmbin\n    =\n        fracf_mathrmsamplen_mathrmsamples\n    =\n        frac1n_mathrmsamples Delta t_mathrmsample\n    =\n        fracmathrmRPM60frac1n_mathrmrevs\nendalign*Thus, in order to obtain the desired frequency bin f_mathrmbin, the number of revolutions that PSU-WOPWOP needs to simulate (ww_nrevs) isbeginalign*\n        n_mathrmrevs\n    =\n        fracmathrmRPM60frac1f_mathrmbin\nendalign*","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"If you need to debug the aero→acoustics workflow, it is useful to convert the input files that we gave to PSU-WOPWOP back to VTK and visualize them in ParaView. This helps verify that we are passing the right things to PSU-WOPWOP. The following lines grab those input files that are formated for PSU-WOPWOP, converts them into VTK files, and opens them in ParaView:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"\nread_ww_path   = joinpath(save_ww_path, \"runcase\")      # Path to PWW's input files\nsave_vtk_path  = joinpath(read_ww_path, \"vtks\")         # Where to save VTK files\n\n# Generate VTK files\nvtk_str = noise.save_geomwopwop2vtk(read_ww_path, save_vtk_path)\n\nprintln(\"Generated the following files:\\n\\t$(vtk_str)\")\n\n# Call Paraview to visualize VTKs\nrun(`paraview --data=$(vtk_str)`)\n","category":"page"},{"location":"examples/rotorhover-acoustics/#Broadband-Noise","page":"Aeroacoustics","title":"Broadband Noise","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Now, we calculate the broadband noise from non-deterministic sources through BPM. This is done calling uns.run_noise_bpm as follows:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"# Path where to save BPM outputs\nsave_bpm_path   = joinpath(sims_path, \"rotorhover-example-midhigh00-bpm\")\n\n# ------------ PARAMETERS --------------------------------------------------\n# NOTE: Make sure that these parameters match what was used in the\n#       aerodynamic solution\n\n# Rotor geometry\nrotor_file      = \"DJI9443.csv\"        # Rotor geometry\ndata_path       = uns.def_data_path    # Path to rotor database\nread_polar      = vlm.ap.read_polar2   # What polar reader to use\npitch           = 0.0                  # (deg) collective pitch of blades\nn               = 50                   # Number of blade elements (this does not need to match the aero solution)\nCW              = false                # Clock-wise rotation\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# Simulation parameters\nRPM             = 5400                 # RPM\nJ               = 0.0001               # Advance ratio Vinf/(nD)\nAOA             = 0                    # (deg) Angle of attack (incidence angle)\n\nrho             = 1.071778             # (kg/m^3) air density\nmu              = 1.85508e-5           # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35               # (m/s) speed of sound\n\nmagVinf         = J*RPM/60*(2*R)\nVinf(X,t)       = magVinf*[cosd(AOA), sind(AOA), 0]  # (m/s) freestream velocity\n\n# BPM parameters\nTE_thickness    = 16.0                 # (deg) trailing edge thickness\nnoise_correction= 1.00                 # Calibration parameter (1 = no correction)\nfreq_bins       = uns.BPM.default_f    # Frequency bins (default is one-third octave band)\n\n# Observer definition: Circular array of microphones\nsph_R           = 1.905                # (m) radial distance from rotor hub\nsph_nR          = 0                    # Number of microphones in the radial direction\nsph_nphi        = 0                    # Number of microphones in the zenith direction\nsph_thtmin      = 0                    # (deg) first microphone's angle\nsph_thtmax      = 360                  # (deg) last microphone's angle\nsph_phimax      = 180\nsph_rotation    = [90, 0, 0]           # Rotation of grid of microphones\n\n# Alternative observer definition: Single microphone\nRmic            = 1.905                # (m) radial distance from rotor hub\nanglemic        = 90*pi/180            # (rad) microphone angle from plane of rotation (- below, + above)\n                                       # 0deg is at the plane of rotation, 90deg is upstream\nmicrophoneX     = nothing              # Comment and uncomment this to switch from array to single microphone\n# microphoneX   = Rmic*[-sin(anglemic), cos(anglemic), 0]\n\n# ------------ GENERATE GEOMETRY -------------------------------------------\n# Generate rotor\nrotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                        n=n, CW=CW, ReD=0.0,\n                                        verbose=false, xfoil=false,\n                                        data_path=data_path,\n                                        read_polar=read_polar,\n                                        plot_disc=false)\n\nrotors = vlm.Rotor[rotor]              # All rotors in the computational domain\n\n# ------------ RUN BPM -----------------------------------------------------\nuns.run_noise_bpm(rotors, RPM, Vinf, rho, mu, speedofsound,\n                                save_bpm_path;\n                                # ---------- OBSERVERS -------------------------\n                                sph_R=sph_R,\n                                sph_nR=sph_nR, sph_ntht=sph_ntht,\n                                sph_nphi=sph_nphi, sph_phimax=sph_phimax,\n                                sph_rotation=sph_rotation,\n                                sph_thtmin=sph_thtmin, sph_thtmax=sph_thtmax,\n                                microphoneX=microphoneX,\n                                # ---------- BPM OPTIONS -----------------------\n                                noise_correction=noise_correction,\n                                TE_thickness=TE_thickness,\n                                freq_bins=freq_bins,\n                                # ---------- OUTPUT OPTIONS --------------------\n                                prompt=true\n                                );\n","category":"page"},{"location":"examples/rotorhover-acoustics/#Results","page":"Aeroacoustics","title":"Results","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Finally, we add tonal and broadband noise together and plot the results","category":"page"},{"location":"examples/rotorhover-acoustics/#Read-datasets","page":"Aeroacoustics","title":"Read datasets","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"We start by reading the outputs from PSU-WOPWOP and BPM:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"# Dataset to read and associated information\ndataset_infos = [ # (label, PWW solution, BPM solution, line style, color)\n                    (\"FLOWUnsteady\",\n                        joinpath(sims_path, \"rotorhover-example-midhigh00-pww/runcase/\"),\n                        joinpath(sims_path, \"rotorhover-example-midhigh00-bpm\"),\n                        \"-\", \"steelblue\"),\n                ]\n\ndatasets_pww = Dict()     # Stores PWW data in this dictionary\ndatasets_bpm = Dict()     # Stores BPM data in this dictionary\n\n# Read datasets and stores them in dictionaries\nnoise.read_data(dataset_infos; datasets_pww=datasets_pww, datasets_bpm=datasets_bpm)\n\nprintln(\"Done!\")\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Also, we need to recreate the circular array of microphones that was used when generating the aeroacoustic solutions:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"# These parameters will be used for plotting\nRPM          = 5400                  # RPM of solution\nnblades      = 2                     # Number of blades\nBPF          = nblades*RPM/60        # Blade passing frequency\n\n# Make sure this grid is the same used as an observer by the aeroacoustic solution\nsph_R        = 1.905                 # (m) radial distance from rotor hub\nsph_nR       = 0\nsph_nphi     = 0\nsph_ntht     = 72                    # Number of microphones\nsph_thtmin   = 0                     # (deg) first microphone's angle\nsph_thtmax   = 360                   # (deg) last microphone's angle\nsph_phimax   = 180\nsph_rotation = [90, 0, 0]            # Rotation of grid of microphones\n\n# Create observer grid\ngrid = noise.observer_sphere(sph_R, sph_nR, sph_ntht, sph_nphi;\n                                thtmin=sph_thtmin, thtmax=sph_thtmax, phimax=sph_phimax,\n                                rotation=sph_rotation);\n\n# This function calculates the angle that corresponds to every microphone\npangle(i) = -180/pi*atan(gt.get_node(grid, i)[1], gt.get_node(grid, i)[2])\n","category":"page"},{"location":"examples/rotorhover-acoustics/#Pressure-waveform","page":"Aeroacoustics","title":"Pressure waveform","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Here we plot the pressure waveform at some of the microphones. This pressure waveform includes only the tonal component, as given by PSU-WOPWOP.","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"microphones  = [-45, 90]            # (deg) microphones to plot\n\nnoise.plot_pressure(dataset_infos, microphones, RPM, sph_ntht, pangle;\n                                datasets_pww=datasets_pww, xlims=[0, 5])\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_1.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_2.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/#SPL-Spectrum","page":"Aeroacoustics","title":"SPL Spectrum","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"We now compare the (sound pressure level) SPL spectrum at the microphone -45^circ below the plane of rotation with the experimental data reported by Zawodny et al.[1].","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"[1]: N. S. Zawodny, D. D. Boyd, Jr., and C. L. Burley, “Acoustic Characterization and Prediction of Representative, Small-scale Rotary-wing Unmanned Aircraft System Components,” in 72nd American Helicopter Society (AHS) Annual Forum (2016).","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"One-third octave band:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"microphones  = [-45]                # (deg) microphone to plot\nAweighted    = false                # Plot A-weighted SPL\nonethirdoctave = true               # Plot 1/3 octave band\n\n# Experimental data from Zawodny et al., Fig. 9\nzawodny_path = joinpath(uns.examples_path, \"..\", \"docs\", \"resources\", \"data\", \"zawodny2016\")\nexp_filename = joinpath(zawodny_path, \"zawodny_dji9443-fig9-OTO-5400.csv\")\nplot_experimental = [(exp_filename, \"Experimental\", \"o:k\", Aweighted, [])]\n\n# Plot SPL spectrum\nnoise.plot_spectrum_spl(dataset_infos, microphones, BPF, sph_ntht, pangle;\n                          datasets_pww=datasets_pww, datasets_bpm=datasets_bpm,\n                          Aweighted=Aweighted,\n                          onethirdoctave=onethirdoctave,\n                          plot_csv=plot_experimental,\n                          xBPF=false, xlims=[100, 3e4], ylims=[0, 80], BPF_lines=8)\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_3.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"A-weighted narrow band:","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Aweighted    = true                # Plot A-weighted SPL\n\n# Experimental data from Zawodny et al., Fig. 9\nexp_filename = joinpath(zawodny_path, \"zawodny_dji9443_spl_5400_01.csv\")\nplot_experimental = [(exp_filename, \"Experimental\", \"k\", Aweighted, [])]\n\n# Plot SPL spectrum\nnoise.plot_spectrum_spl(dataset_infos, microphones, BPF, sph_ntht, pangle;\n                          datasets_pww=datasets_pww, datasets_bpm=datasets_bpm,\n                          Aweighted=Aweighted,\n                          plot_csv=plot_experimental,\n                          xBPF=false, xlims=[100, 3e4], BPF_lines=21)","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_4.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"In the narrow band spectrum, keep in mind that the broadband output of BPM has been converted from 1/3 octaves into narrow band (5 hz bin) in order to plot it together with the tonal noise, but this is a very rough approximation (we lack enough information to interpolate from a coarse band to a narrow band besides just smearing the energy content). Hence, the broadband component seems to overpredict relative to the experimental, but this is an artifice of the 1/3 octave rightarrow narrow band conversion. In the OASPL directivity plots we will see that the A-weighted OASPL predicted with BPM actually matches the experimental values very well.","category":"page"},{"location":"examples/rotorhover-acoustics/#Tonal-noise","page":"Aeroacoustics","title":"Tonal noise","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Here we plot only the tonal component of noise associated with harmonics of the blade passing frequency (BPF),","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Tonal SPL spectrum","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Aweighted       = false\nadd_broadband   = false\n\n# Experimental data from Zawodny et al., Fig. 9\nexp_filename = joinpath(zawodny_path, \"zawodny_dji9443_spl_5400_01.csv\")\nplot_experimental = [(exp_filename, \"Experimental\", \"k\", Aweighted, [])]\n\n# Plot SPL spectrum\nnoise.plot_spectrum_spl(dataset_infos, microphones, BPF, sph_ntht, pangle;\n                          datasets_pww=datasets_pww, datasets_bpm=datasets_bpm,\n                          Aweighted=Aweighted,\n                          plot_csv=plot_experimental,\n                          add_broadband=add_broadband,\n                          xBPF=false, xlims=[100, 3e4], BPF_lines=21)\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_5.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Directivity of 1^mathrmst BPF","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"BPFi = 1                 # Multiple of blade-passing frequency to plot\n\n# Experimental and computational data reported by Zawodny et al., Fig. 14\nfilename1 = joinpath(zawodny_path, \"zawodny_fig14_topright_exp00.csv\")\nfilename2 = joinpath(zawodny_path, \"zawodny_fig14_topright_of00.csv\")\nfilename3 = joinpath(zawodny_path, \"zawodny_fig14_topright_pas00.csv\")\n\nplot_experimental = [(filename1, \"Experimental\", \"ok\", Aweighted, []),\n                     (filename2, \"OVERFLOW2\", \"-y\", Aweighted, [(:alpha, 0.8)])]\n\n# Plot SPL directivity of first blade-passing frequency\nnoise.plot_directivity_splbpf(dataset_infos, BPFi, BPF, pangle;\n                                    datasets_pww=datasets_pww,\n                                    datasets_bpm=datasets_bpm,\n                                    plot_csv=plot_experimental,\n                                    rticks=40:4:52, rlims=[40, 54], rorigin=36)\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_6.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Directivity of 2^mathrmnd BPF","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"BPFi = 2                 # Multiple of blade-passing frequency to plot\n\n# Experimental and computational data reported by Zawodny et al., Fig. 14\nfilename1 = joinpath(zawodny_path, \"zawodny_fig14_bottomright_exp00.csv\")\nfilename2 = joinpath(zawodny_path, \"zawodny_fig14_bottomright_of00.csv\")\nfilename3 = joinpath(zawodny_path, \"zawodny_fig14_bottomright_pas00.csv\")\n\nplot_experimental = [(filename1, \"Experimental\", \"ok\", Aweighted, []),\n                     (filename2, \"OVERFLOW2\", \"-y\", Aweighted, [(:alpha, 0.8)])]\n\n# Plot SPL directivity of first blade-passing frequency\nnoise.plot_directivity_splbpf(dataset_infos, BPFi, BPF, pangle;\n                                    datasets_pww=datasets_pww,\n                                    datasets_bpm=datasets_bpm,\n                                    plot_csv=plot_experimental,\n                                    rticks=15:5:30, rlims=[0, 32], rorigin=0)\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_7.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/#OASPL-directivity","page":"Aeroacoustics","title":"OASPL directivity","text":"","category":"section"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Unweighted overall SPL (OASPL)","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Aweighted = false\n\n# Experimental and computational data reported by Zawodny et al., Fig. 12\nexp_filename = joinpath(zawodny_path, \"zawodny_fig12_left_5400_00.csv\")\nplot_experimental = [(exp_filename, \"Experimental\", \"ok\", Aweighted, [])]\n\n# Plot OASPL directivity\nnoise.plot_directivity_oaspl(dataset_infos, pangle;\n                                    datasets_pww=datasets_pww,\n                                    datasets_bpm=datasets_bpm,\n                                    Aweighted=Aweighted,\n                                    plot_csv=plot_experimental,\n                                    rticks=40:10:70, rlims=[40, 72], rorigin=30)\n","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_8.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"A-weighted OASPL","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"Aweighted = true\n\n# Experimental and computational data reported by Zawodny et al., Fig. 12\nexp_filename = joinpath(zawodny_path, \"zawodny_fig12_right_5400_00.csv\")\nplot_experimental = [(exp_filename, \"Experimental\", \"ok\", Aweighted, [])]\n\n# Plot OASPL directivity\nnoise.plot_directivity_oaspl(dataset_infos, pangle;\n                                    datasets_pww=datasets_pww,\n                                    datasets_bpm=datasets_bpm,\n                                    Aweighted=Aweighted,\n                                    plot_csv=plot_experimental,\n                                    rticks=40:10:70, rlims=[40, 72], rorigin=30)","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"<center>\n<img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/rotorhover_noise_9.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-acoustics/","page":"Aeroacoustics","title":"Aeroacoustics","text":"","category":"page"},{"location":"examples/vahana-maneuver/#vahanamaneuver","page":"Maneuver Definition","title":"Maneuver Definition","text":"","category":"section"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"In this section we define a function that generates the eVTOL transition maneuver (a uns.KinematicManeuver object). This maneuver object contains the non-dimensional velocity and attitude of the aircraft over a non-dimensional time (where t=0 is the beginning of the maneuver and t=1 is the end), which prescribes the kinematics of the vehicle. It also contains the control inputs for the aircraft over time: tilting angles for each tilting system and RPM for each rotor system shown below.","category":"page"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"<table>\n    <tr>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-tiltingsystems00.png\" alt=\"Pic here\" style=\"width:90%;\"/>\n        </td>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-rotorsystems00.png\" alt=\"Pic here\" style=\"width:90%;\"/>\n        </td>\n    </tr>\n</table>","category":"page"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"The maneuver here defined contains five stages:","category":"page"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"Takeoff, climb, hover\nHover rightarrow cruise transition (powered lift to wing-borne flight)\nCruise\nCruise rightarrow hover transition (wing-borne flight to powered lift)\nHover, descend, landing","category":"page"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"Since the vehicle kinematics and control inputs used in the maneuver definition are non-dimensional, the maneuver can be performed as fast or as slow as desired when we define the total time, reference velocity, and reference RPM of uns.Simulation later in the next section, without needing to change the maneuver definition shown here.","category":"page"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"\"\"\"\n    Generates the eVTOL transition maneuver of Vahana aircraft\n\"\"\"\nfunction generate_maneuver_vahana(; disp_plot=false,    # If true, it will display a plot of the maneuver\n                                    add_rotors=true,    # Whether to add rotors contorl inputs to the maneuver\n                                    V0=0.0001           # Initial non-dimensional velocity (slightly different than zero to avoid instabilities)\n                                    )\n\n    # NOTE: The following parameters are non-dimensional and scaled between 0\n    #       and 1. Here, t=0 is the beginning of the maneuver and t=1 is the end.\n\n    # Define end time of each stage\n    #  Stage 1: [0,  t1] -> Take off\n    #  Stage 2: [t1, t2] -> Transition\n    #  Stage 3: [t2, t3] -> Cruise\n    #  Stage 4: [t3, t4] -> Transition\n    #  Stage 5: [t4, 1 ] -> Landing\n    t1, t2, t3, t4 = 0.2, 0.3, 0.5, 0.6\n\n    # Target velocity at each stage (ratio of cruise velocity)\n    V1 = 0.25\n    V2 = 0.10\n    V3 = 1.00\n    V4 = V2\n    V5 = 0.5*V1\n\n    # Target RPM at each stage (ratio of hover RPM)\n    RPM1 = 1.10\n    RPM2 = 1.50\n    RPM3 = 0.75\n    RPM3_stacked = 2/600\n    RPM4 = 1.00\n    RPM5 = 0.90\n\n    r_RPMh_stup = 3.50             # Ratio between stacked and main rotor RPM in hover\n    r_RPMh_tw = 0.75               # Ratio between tandem and main rotor RPM in hover\n\n    # NOTE: -x is in the direction of flight and +z is climb with ground at z=0\n\n\n    ############################################################################\n    # AIRCRAFT VELOCITY\n    ############################################################################\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the\n        non-dimensional velocity vector of the aircraft at that instant.\n    \"\"\"\n    function Vaircraft(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            # Weibull acceleration to target climb\n            if t<t1/2\n                val = t / (t1/2)\n                Vz = V0 + V1*(1-exp(-(2*val)^5))\n\n            # Weibull deceleration to hover\n            else\n                val = 1 - (t-t1/2) / (t1/2)\n                Vz = V1*(1-exp(-(2*val)^5))\n            end\n\n            return [0, 0, Vz]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n\n            # Weibull acceleration to cruise\n            val = 1.5 * (t-t1) / (t2-t1) + 0.25\n            Vx = V3*(1-exp(-(val)^5))\n\n            # Slight drop during transition\n            val = (1/0.8) * (t-t1) / (t2-t1)\n            Vz = 0.5 * (5 * val^4 * exp(-val^5))\n            Vz = 0.2*V3 * Vz\n\n            return [-Vx, 0, -Vz]\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n\n            return [-V3, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n\n            # Weibull deceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            Vx = V3*(1-exp(-(val)^5))\n\n            # Slight climb during transition\n            val = 2.0 * (t-t3) / (t4-t3)\n            Vz = 0.5 * (5 * val^4 * exp(-val^5))\n            Vz = 0.2*V3 * Vz\n\n            return [-Vx, 0, Vz]\n\n        # ------------ LANDING -------------------------------------------------\n        else\n\n            # Weibull acceleration to target descend\n            if (t-t4)<(1-t4)*0.35\n                val = (t-t4) / ((1-t4)*0.35)\n                Vz = V5*(1-exp(-(2*val)^5))\n            # Weibull deceleration to hover\n            else\n                val = 1 - ((t-t4) - (1-t4)*0.35) / ((1-t4)*(1-0.35))\n                Vz = V0 + V5*(1-exp(-(2*val)^10))\n            end\n\n            return [0, 0, -Vz]\n\n        end\n    end\n\n\n    ############################################################################\n    # AIRCRAFT ANGLES\n    ############################################################################\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the attitude\n        of the aircraft. The attitude is a vector indicating the angle of the\n        vehicle frame with respect to each global axis.\n    \"\"\"\n    function angleaircraft(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            return [0, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n            # Slightly pitching down during transition\n            val = 1.5 * (t-t1) / (t2-t1)\n            val3 = 1.5*val\n            val3 = (val3)^(val3 < 1 ? 3 : 1.5)\n            angle_aircraft = -15*(1.5/0.75 * val3^0.5 * exp(-(val3^1.5)))\n            return [0, angle_aircraft, 0]\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n            return [0, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n            # Weibull deceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            # Slight climb during transition\n            val = 2.0 * (t-t3) / (t4-t3)\n            angle_aircraft = 15 * 0.5 * (5 * val^4 * exp(-val^5))\n            return [0, angle_aircraft, 0]\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            return [0, 0, 0]\n        end\n    end\n\n\n    ############################################################################\n    # CONTROL INPUT: TILTING SYSTEMS\n    ############################################################################\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns a vector\n        with the angles of the main-wing system (in degrees) relative to the\n        aircraft frame.\n\n        This tilting system is made out of the tip-mounted tiltrotors on the\n        main wing and winglets.\n    \"\"\"\n    function angle_main(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            # Tiltrotors pointing up\n            return [0, 90, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n\n            # Tilt forward to cruise position\n            val = 1.5 * (t-t1) / (t2-t1)\n            val2 = val - 0.00\n            angle = 90 - 90*(1-exp(-(val2)^6))\n            return [0, angle, 0]\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n\n            # Tiltrotors pointing forward in propeller mode\n            return [0, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n\n            # Tilt back to hover position\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            angle = 90 - 90*(1-exp(-(val)^5))\n            return [0, angle, 0]\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            # Tiltrotors pointing up\n            return [0, 90, 0]\n        end\n    end\n\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns a vector\n        with the angles of the tandem-wing system (in degrees) relative to the\n        aircraft frame.\n\n        This tilting system is made out of the tandem wing and rotors.\n    \"\"\"\n    function angle_tandem(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            # System pointing up\n            return [0, 90, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n\n            # Tilt forward to cruise position\n            val = 2.0 * (t-t1) / (t2-t1)\n            val1 = val + 0.25\n            angle = 90 - 90*(1-exp(-(val1)^5))\n            return [0, angle, 0]\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n\n            # System pointing forward in cruise mode\n            return [0, 0, 0]\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n\n            # Tilt back to hover position\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            angle = 90 - 90*(1-exp(-(val)^5))\n            return [0, angle, 0]\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            # System pointing up\n            return [0, 90, 0]\n        end\n    end\n\n\n\n\n\n    ############################################################################\n    # ROTORS RPM\n    ############################################################################\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the RPM of\n        main-wing tiltrotors normalized by the hover RPM.\n    \"\"\"\n    function RPM_main(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            # Weibull acceleration to target climb\n            if t<t1/2\n                val = t / (t1/2)\n                RPM_w = RPM1*(1.05-exp(-(5*val)^2))\n\n            # Weibull deceleration to hover\n            else\n                val = 1 - (t-t1/2) / (t1/2)\n                RPM_w = 1.0 + (RPM1-1.0)*(1-exp(-(2*val)^5))\n            end\n\n            return RPM_w\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n\n            # Increase RPM to sustain forward flight and hover\n            if (t-t1)<(t2-t1)*0.25\n                val = (t-t1)/((t2-t1)*0.25)\n                RPM_w = 1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5))\n\n            # Decrease RPM as tiltrotors transition to propeller mode\n            else\n                val = 1 - ((t2-t)/(t2-t1)-0.25) / (1-0.25)\n                RPM_w = RPM2 + (RPM3-RPM2)*(1-exp(-(1.1*val)^5))\n            end\n\n            return RPM_w\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n\n            # Propeller mode\n            RPM_w = RPM3\n            return RPM_w\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n\n            # Weibull acceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            RPM_w = RPM4 + (RPM3-RPM4)*(1-exp(-(val)^3))\n            return RPM_w\n\n        # ------------ LANDING -------------------------------------------------\n        else\n\n            # Weibull deceleration to target descend\n            if (t-t4)<(1-t4)*0.55\n                val = (t-t4) / ((1-t4)*0.55)\n                RPM_w = RPM4 + (RPM5-RPM4)*(1-exp(-(3*val)^5))\n\n            # Weibull acceleration to hover\n            else\n                val = ((t-t4) - (1-t4)*0.55) / ((1-t4)*(1-0.55))\n                val = val + 0.60\n                RPM_w = RPM5*(3.0*(val)^(3.0-1)*exp(-(val)^5.0))/1.0\n            end\n\n            return RPM_w\n\n        end\n    end\n\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the RPM of\n        stacked upper rotors in main wing normalized by the hover RPM.\n    \"\"\"\n    function RPM_stacked_up(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            # Weibull acceleration to target climb\n            if t<t1/5\n                val = t / (t1/5)\n                RPM_w = RPM1*(1.05-exp(-(5*val)^2))\n\n            # Weibull deceleration to hover\n            else\n                val = 1 - (t-t1/5) / (1-t1/5)\n                RPM_w = 1.0 + (RPM1-1.0)*(1-exp(-(2*val)^5))\n            end\n\n            return r_RPMh_stup*RPM_w\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n\n            # Increase RPM to sustain forward flight and hover\n            if (t-t1)<(t2-t1)*0.65\n                val = (t-t1)/((t2-t1)*0.65)\n                RPM_tw = r_RPMh_tw*(1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5)))\n\n            # Decrease RPM as it transitions out of powered lift\n            else\n                val = 1 - (t2-t)/(t2-((t2-t1)*0.65 + t1))\n                RPM_tw = r_RPMh_tw*(RPM2 + val*(RPM3_stacked-RPM2))\n            end\n\n            return RPM_tw\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n\n            # Stopped rotor\n            return RPM3_stacked\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n\n            # Weibull acceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            RPM_w = RPM4 + (RPM3_stacked-RPM4)*(1-exp(-(val)^3))\n            return r_RPMh_stup*RPM_w\n\n        # ------------ LANDING -------------------------------------------------\n        else\n\n            # Weibull deceleration to target descend\n            if (t-t4)<(1-t4)*0.75\n                val = (t-t4) / ((1-t4)*0.75)\n                RPM_w = RPM4 + (RPM5-RPM4)*(1-exp(-(3*val)^5))\n\n            # Weibull acceleration to hover\n            else\n                val = ((t-t4) - (1-t4)*0.75) / ((1-t4)*(1-0.75))\n                val = val + 0.60\n                RPM_w = RPM5*(3.0*(val)^(3.0-1)*exp(-(val)^5.0))/1.0\n            end\n\n            return r_RPMh_stup*RPM_w\n        end\n    end\n\n\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the RPM of\n        stacked lower rotors in main wing normalized by the hover RPM.\n    \"\"\"\n    function RPM_stacked_low(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n            return RPM_stacked_up(t)\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n            return RPM_stacked_up(t)\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n            return RPM_stacked_up(t)\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n            return RPM_stacked_up(t)\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            return RPM_stacked_up(t)\n        end\n    end\n\n    \"\"\"\n        Receives a nondimensional time between 0 and 1, and returns the RPM of\n        tandem wing rotors normalized by the hover RPM.\n    \"\"\"\n    function RPM_tandem(t)\n\n        # ------------ TAKE OFF ------------------------------------------------\n        if t<t1\n\n            return r_RPMh_tw*RPM_main(t)\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t2\n\n            # Increases RPM to sustain forward flight and hover\n            if (t-t1)<(t2-t1)*0.65\n                val = (t-t1)/((t2-t1)*0.65)\n                RPM_tw = r_RPMh_tw*(1.0 + (RPM2-1.0)*(1-exp(-(2*val)^5)))\n\n            # Decrease RPM as rotors transition to propeller mode\n            else\n                val = 1 - (t2-t)/(t2-((t2-t1)*0.65 + t1))\n                RPM_tw = r_RPMh_tw*(RPM2 + val*(RPM3-RPM2))\n            end\n\n            return RPM_tw\n\n        # ------------ CRUISE --------------------------------------------------\n        elseif t<t3\n\n            return r_RPMh_tw*RPM_main(t)\n\n        # ------------ TRANSITION ----------------------------------------------\n        elseif t<t4\n\n            # Weibull acceleration to hover\n            val = 1.5 * (1 - (t-t3) / (t4-t3))\n            RPM_tw = r_RPMh_tw * (RPM4 + (RPM3-RPM4)*(1-exp(-(0.8*val)^8)))\n            return RPM_tw\n\n        # ------------ LANDING -------------------------------------------------\n        else\n            return r_RPMh_tw*RPM_main(t)\n        end\n    end\n\n\n\n    ############################################################################\n    # MANEUVER OBJECT\n    ############################################################################\n    # Angle function of each tilting system\n    angle = (angle_main, angle_tandem)\n\n    # RPM function of each rotor system\n    if add_rotors\n        RPM = (RPM_main, RPM_stacked_up, RPM_stacked_low, RPM_tandem)\n    else\n        RPM = ()\n    end\n\n    # Aircraft velocity and angles (attitude)\n    Vvehicle = Vaircraft\n    anglevehicle = angleaircraft\n\n    # Define non-dimensional maneuver\n    maneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)\n\n    # Plot maneuver for verification purposes\n    if disp_plot\n        uns.plot_maneuver(maneuver; tstages=[t1, t2, t3, t4])\n    end\n\n    return maneuver\nend","category":"page"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"<center>\n    <br><br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-kinematics.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n    <br><br><br><br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-controls.png\" alt=\"Pic here\" style=\"width:75%;\"/>\n</center>","category":"page"},{"location":"examples/vahana-maneuver/","page":"Maneuver Definition","title":"Maneuver Definition","text":"Notice that this plot shows four rotor systems instead of only three. This is because the system of stacked rotors was split into two (all upper stack rotors are grouped together, while all lower stack rotors are also grouped together). This way we could change the index angle of the stacked rotors throughout the simulation by modulating upper and lower RPMs independently. However, for simplicity, in this example we have kept upper and lower RPMs the same.","category":"page"},{"location":"api/flowvpm-uj/#UJ-Scheme","page":"UJ Scheme","title":"UJ Scheme","text":"","category":"section"},{"location":"api/flowvpm-uj/","page":"UJ Scheme","title":"UJ Scheme","text":"FLOWUnsteady.vpm.Kernel\nFLOWUnsteady.vpm.UJ_direct\nFLOWUnsteady.vpm.UJ_fmm\nFLOWUnsteady.vpm.FMM","category":"page"},{"location":"api/flowvpm-uj/#FLOWVPM.Kernel","page":"UJ Scheme","title":"FLOWVPM.Kernel","text":"Kernel(zeta, g, dgdr, g_dgdr, EXAFMM_P2P, EXAFMM_L2P)\n\nArguments\n\nzeta::Function        : Basis function zeta(r).\ng::Function           : Regularizing function g(r).\ndgdr::Function        : Derivative of g(r).\ng_dgdr::Function      : Efficient evaluation of g and dgdr.\nEXAFMM_P2P::Int       : Flag for the ExaFMM P2P function to call.\nEXAFMM_L2P::Int       : Flag for the ExaFMM L2P function to call.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-uj/#FLOWVPM.UJ_direct","page":"UJ Scheme","title":"FLOWVPM.UJ_direct","text":"UJ_direct(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself by direct particle-to-particle interaction, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\nUJ_direct(source, target)\n\nCalculates the velocity and Jacobian that the field source exerts on every particle of  field target, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-uj/#FLOWVPM.UJ_fmm","page":"UJ Scheme","title":"FLOWVPM.UJ_fmm","text":"UJ_fmm(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself through a fast-multipole approximation, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"function"},{"location":"examples/prowim-aero/#prowimaero","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"","category":"section"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//veldhuis2004-expsetup01.png\" alt=\"Pic here\" style=\"width: 49%;\"/>","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"<br><br>","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"In this example we use the actuator surface model (ASM) to more accurately predict the effects of props blowing on a wing. This case simulates the PROWIM experiment in Leo Veldhuis' dissertation (2005), and reproduces the validation study published in Alvarez & Ning (2023).","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"In this example you can vary the fidelity of the simulation setting the following parameters:","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"Parameter Low fidelity Mid-low fidelity Mid-high fidelity High fidelity Description\nn_wing 50 50 50 100 Number of wing elements per semispan\nn_rotor 12 12 20 50 Number of blade elements per blade\nnsteps_per_rev 36 36 36 72 Time steps per revolution\np_per_step 2 5 5 5 Particle sheds per time step\nshed_starting false false false true Whether to shed starting vortex\nshed_unsteady false false false true Whether to shed vorticity from unsteady loading\ntreat_wake true true true false Treat wake to avoid instabilities\nvlm_vortexsheet_overlap 2.125/10 2.125/10 2.125/10 2.125 Particle overlap in ASM vortex sheet\nvpm_integration vpm.euler vpm.euler RK3^star RK3^star VPM time integration scheme\nvpm_SFS None^dag None^dag Dynamic^ddag Dynamic^ddag VPM LES subfilter-scale model","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"^starRK3: vpm_integration = vpm.rungekutta3\n^dagNone: vpm_SFS = vpm.SFS_none\n^ddagDynamic: vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"(Low fidelity settings may be inadequate for accurately capturing prop-on-wing interactions, but mid-low or higher should do well)","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"As a reference, high-fidelity looks like this (except that the video shows a tip-mounted configuration with ailerons):","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/GfS3NoVrFfU?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"#=##############################################################################\n# DESCRIPTION\n    Validation of prop-on-wing interactions with twin props mounted mid span\n    blowing on a wing. This case simulates the PROWIM experiment in Leo\n    Veldhuis' dissertation (2005), “Propeller Wing Aerodynamic Interference.”\n\n    In this simulation we use the actuator surface model for the wing in order\n    to accurately capture prop-on-wing interactional effects. The rotors still\n    use the actuator line model.\n\n    The high-fidelity settings replicate the results presented in Alvarez &\n    Ning (2023), \"Meshless Large-Eddy Simulation of Propeller–Wing Interactions\n    with Reformulated Vortex Particle Method,\" Sec. IV.B, also available in\n    Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy\n    Simulation of Multirotor Aircraft,\" Sec. 8.4.\n\n# ABOUT\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : January 2024\n  * Last updated    : January 2024\n  * License         : MIT\n=###############################################################################\n\n\nimport FLOWUnsteady as uns\nimport FLOWUnsteady: vlm, vpm\n\nrun_name        = \"prowim\"                  # Name of this simulation\nsave_path       = run_name*\"-example2\"       # Where to save this simulation\nprompt          = true                      # Whether to prompt the user\nparaview        = true                      # Whether to visualize with Paraview\n\nadd_wing        = true                      # Whether to add wing to simulation\nadd_rotors      = true                      # Whether to add rotors to simulation\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n# Wing geometry\nb               = 2*0.64                    # (m) span length\nar              = 5.33                      # Aspect ratio b/c_tip\ntr              = 1.0                       # Taper ratio c_tip/c_root\ntwist_root      = 0.0                       # (deg) twist at root\ntwist_tip       = 0.0                       # (deg) twist at tip\nlambda          = 0.0                       # (deg) sweep\ngamma           = 0.0                       # (deg) dihedral\nthickness_w     = 0.15                      # Thickness t/c of wing airfoil\n\n# Rotor geometry\nrotor_file      = \"beaver.csv\"              # Rotor geometry\ndata_path       = uns.def_data_path         # Path to rotor database\nread_polar      = vlm.ap.read_polar2        # What polar reader to use\npitch           = 2.5                       # (deg) collective pitch of blades\nxfoil           = false                     # Whether to run XFOIL\nncrit           = 6                         # Turbulence criterion for XFOIL\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# Vehicle assembly\nAOAwing         = 0.0                       # (deg) wing angle of attack\nspanpos         = [-0.46875, 0.46875]       # Semi-span position of each rotor, 2*y/b\nxpos            = [-0.8417, -0.8417]        # x-position of rotors relative to LE, x/c\nzpos            = [0.0, 0.0]                # z-position of rotors relative to LE, z/c\nCWs             = [false, true]             # Rotation direction of each rotor: outboard up\n# CWs             = [true, false]           # Rotation direction of each rotor: inboard up\nnrotors         = length(spanpos)           # Number of rotors\n\n# Discretization\nn_wing          = 50                        # Number of spanwise elements per side\nr_wing          = 2.0                       # Geometric expansion of elements\n# n_rotor         = 20                        # Number of blade elements per blade\nn_rotor         = 12\nr_rotor         = 1/10                      # Geometric expansion of elements\n\n# Check that we declared all the inputs that we need for each rotor\n@assert nrotors==length(spanpos)==length(xpos)==length(zpos)==length(CWs) \"\"*\n    \"Invalid rotor inputs! Check that spanpos, xpos, zpos, and CWs have the same length\"\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n# Freestream\nmagVinf         = 49.5                      # (m/s) freestream velocity\nAOA             = 4.0                       # (deg) vehicle angle of attack\nrho             = 1.225                     # (kg/m^3) air density\nmu              = 1.79e-5                   # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\nqinf            = 0.5*rho*magVinf^2         # (Pa) reference static pressure\nVinf(X, t)      = magVinf*[cosd(AOA), 0, sind(AOA)]  # Freestream function\n\n# Rotor operation\nJ               = 0.85                      # Advance ratio Vinf/(nD)\nRPM             = 60*magVinf/(J*2*R)        # RPM\n\n# Reference non-dimensional parameters\nRec             = rho * magVinf * (b/ar) / mu       # Chord-based wing Reynolds number\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based rotor Reynolds number\nMtip            = 2*pi*RPM/60 * R / speedofsound    # Tip Mach number\n\nprintln(\"\"\"\n    Vinf:   $(round(magVinf, digits=1)) m/s\n    RPM:    $(RPM)\n    Mtip:   $(round(Mtip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n    Rec:    $(round(Rec, digits=0))\n\"\"\")\n\n\n# NOTE: Modify the variable `AOA` in order to change the angle of attack.\n#       `AOAwing` will only change the angle of attack of the wing (while\n#       leaving the propellers unaffected), while `AOA` changes the angle of\n#       attack of the freestream (affecting both wing and props).\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n# VehicleType     = uns.QVLMVehicle         # Quasi-steady solver\nconst_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the\n                                                # solution is constant or not\n# Time parameters\nnrevs           = 8                         # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\n# p_per_step      = 5                         # Sheds per time step\np_per_step      = 2\nshed_starting   = false                     # Whether to shed starting vortex (NOTE: starting vortex might make simulation unstable with AOA>8)\nshed_unsteady   = false                     # Whether to shed vorticity from unsteady loading\nunsteady_shedcrit = 0.001                   # Shed unsteady loading whenever circulation\n                                            #  fluctuates by more than this ratio\ntreat_wake      = true                      # Treat wake to avoid instabilities\nmax_particles   = 1                         # Maximum number of particles\nmax_particles   += add_rotors * (nrotors*((2*n_rotor+1)*B)*nsteps*p_per_step)\nmax_particles   += add_wing * (nsteps+1)*(2*n_wing*(p_per_step+1) + p_per_step)\n\n# Regularization\nsigma_vlm_surf  = b/200                     # VLM-on-VPM smoothing radius (σLBV of wing)\nsigma_rotor_surf= R/80                      # Rotor-on-VPM smoothing radius (σ of rotor)\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius (σ of wakes)\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\n\n# Rotor solver\nvlm_rlx         = 0.3                       # VLM relaxation <-- this also applied to rotors\nhubtiploss_correction = ( (0.75, 10, 0.5, 0.05), (1, 1, 1, 1.0) ) # Hub/tip correction\n# VPM solver\n# vpm_integration = vpm.rungekutta3           # VPM temporal integration scheme\nvpm_integration = vpm.euler\n\nvpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme\n                                            # Uncomment this to make it viscous\n# vpm_viscous   = vpm.CoreSpreading(-1, -1, vpm.zeta_fmm; beta=100.0, itmax=20, tol=1e-1)\n\nvpm_SFS       = vpm.SFS_none              # VPM LES subfilter-scale model\n# vpm_SFS         = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;\n                                  # alpha=0.999, maxC=1.0,\n                                  # clippings=[vpm.clipping_backscatter])\n\n# NOTE: By default we make this simulation inviscid since at such high Reynolds\n#       number the viscous effects in the wake are actually negligible.\n#       Notice that while viscous diffusion is negligible, turbulent diffusion\n#       is important and non-negigible, so we have activated the subfilter-scale\n#       (SFS) model.\n\nif VehicleType == uns.QVLMVehicle\n    # Mute warnings regarding potential colinear vortex filaments. This is\n    # needed since the quasi-steady solver will probe induced velocities at the\n    # lifting line of the blade\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\nprintln(\"\"\"\n    Resolving wake for $(round(ttot*magVinf/b, digits=1)) span distances\n\"\"\")\n\n\n\n\n\n# ----------------- ACTUATOR SURFACE MODEL PARAMETERS (WING) -------------------\n\n# ---------- Vortex sheet parameters ---------------\nvlm_vortexsheet = true                      # Spread wing circulation as a vortex sheet (activates the ASM)\nvlm_vortexsheet_overlap = 2.125/10          # Particle overlap in vortex sheet\nvlm_vortexsheet_distribution = uns.g_pressure   # Distribution of the vortex sheet\n\nvlm_vortexsheet_sigma_tbv = thickness_w*(b/ar) / 128 # Smoothing radius of trailing bound vorticity, σTBV for VLM-on-VPM\n\nvlm_vortexsheet_maxstaticparticle = 10^6    # Particles to preallocate for vortex sheet\n\nif add_wing && vlm_vortexsheet\n    max_particles += vlm_vortexsheet_maxstaticparticle\nend\n\n\n# ---------- Force calculation parameters ----------\nKJforce_type                = \"regular\"     # KJ force evaluated at middle of bound vortices\n# KJforce_type              = \"averaged\"    # KJ force evaluated at average vortex sheet\n# KJforce_type              = \"weighted\"    # KJ force evaluated at strength-weighted vortex sheet\n\ninclude_trailingboundvortex = false         # Include trailing bound vortices in force calculations\n\ninclude_freevortices        = false         # Include free vortices in force calculation\ninclude_freevortices_TBVs   = false         # Include trailing bound vortex in free-vortex force\n\ninclude_unsteadyforce       = true          # Include unsteady force\nadd_unsteadyforce           = false         # Whether to add the unsteady force to Ftot or to simply output it\n\ninclude_parasiticdrag       = true          # Include parasitic-drag force\nadd_skinfriction            = true          # If false, the parasitic drag is purely form, meaning no skin friction\ncalc_cd_from_cl             = true          # Whether to calculate cd from cl or effective AOA\n# calc_cd_from_cl             = false\n\n# NOTE: We use a polar at a low Reynolds number (100k as opposed to 600k from\n#       the experiment) as this particular polar better resembles the drag of\n#       the tripped airfoil used in the experiment\nwing_polar_file             = \"xf-n64015a-il-100000-n5.csv\"    # Airfoil polar for parasitic drag (from airfoiltools.com)\n\n\nif include_freevortices && Threads.nthreads()==1\n    @warn(\"Free-vortex force calculation requested, but Julia was initiated\"*\n          \" with only one CPU thread. This will be extremely slow!\"*\n          \" Initate Julia with `-t num` where num is the number of cores\"*\n          \" availabe to speed up the computation.\")\nend\n\n\n\n\n\n# ----------------- WAKE TREATMENT ---------------------------------------------\n\nwake_treatments = []\n\n# Remove particles by particle strength: remove particles neglibly weak, remove\n# particles potentially blown up\nrmv_strngth = 2.0 * magVinf*(b/ar)/2 * magVinf*ttot/nsteps/p_per_step  # Reference strength (maxCL=2.0)\nminmaxGamma = rmv_strngth*[0.0001, 10.0]    # Strength bounds (removes particles outside of these bounds)\nwake_treatment_strength = uns.remove_particles_strength( minmaxGamma[1]^2, minmaxGamma[2]^2; every_nsteps=1)\n\nif treat_wake\n    push!(wake_treatments, wake_treatment_strength)\nend\n\n\n\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\n\n# -------- Generate components\nprintln(\"Generating geometry...\")\n\n# Generate wing\nwing = vlm.simpleWing(b, ar, tr, twist_root, lambda, gamma;\n                                    twist_tip=twist_tip, n=n_wing, r=r_wing);\n\n# Pitch wing to its angle of attack\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0, -AOAwing, 0)     # New orientation\nvlm.setcoordsystem(wing, O, Oaxis)\n\n# Generate rotors\nrotors = vlm.Rotor[]\nfor ri in 1:nrotors\n\n    # Generate rotor\n    rotor = uns.generate_rotor(rotor_file;\n                                pitch=pitch,\n                                n=n_rotor, CW=CWs[ri], blade_r=r_rotor,\n                                altReD=[RPM, J, mu/rho],\n                                xfoil=xfoil,\n                                ncrit=ncrit,\n                                data_path=data_path,\n                                read_polar=read_polar,\n                                verbose=true,\n                                verbose_xfoil=false,\n                                plot_disc=false\n                                );\n\n    # Simulate only one rotor if the wing is not in the simulation\n    if !add_wing\n        push!(rotors, rotor)\n        break\n    end\n\n    # Determine position along wing LE\n    y = spanpos[ri]*b/2\n    x = abs(y)*tand(lambda) + xpos[ri]*b/ar\n    z = abs(y)*tand(gamma) + zpos[ri]*b/ar\n\n    # Account for angle of attack of wing\n    nrm = sqrt(x^2 + z^2)\n    x = (x==0 ? 1 : sign(x))*nrm*cosd(AOAwing)\n    z = -(z==0 ? 1 : sign(z))*nrm*sind(AOAwing)\n\n    # Translate rotor to its position along wing\n    O_r = [x, y, z]                                     # New position\n    Oaxis_r = uns.gt.rotation_matrix2(0, 0, 0)          # New orientation\n    vlm.setcoordsystem(rotor, O_r, Oaxis_r; user=true)\n\n    push!(rotors, rotor)\nend\n\n\n# -------- Generate vehicle\nprintln(\"Generating vehicle...\")\n\n# System of all FLOWVLM objects\nsystem = vlm.WingSystem()\n\nif add_wing\n    vlm.addwing(system, \"Wing\", wing)\nend\n\nif add_rotors\n    for (ri, rotor) in enumerate(rotors)\n        vlm.addwing(system, \"Rotor$(ri)\", rotor)\n    end\nend\n\n# System solved through VLM solver\nvlm_system = vlm.WingSystem()\nadd_wing ? vlm.addwing(vlm_system, \"Wing\", wing) : nothing\n\n# Systems of rotors\nrotor_systems = add_rotors ? (rotors, ) : NTuple{0, Array{vlm.Rotor, 1}}()\n\n# System that will shed a VPM wake\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\nadd_wing ? vlm.addwing(wake_system, \"Wing\", wing) : nothing\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle && add_rotors\n    for (ri, rotor) in enumerate(rotors)\n        vlm.addwing(wake_system, \"Rotor$(ri)\", rotor)\n    end\nend\n\n# Pitch vehicle to its angle of attack (0 in this case since we have tilted the freestream instead)\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0, 0, 0)            # New orientation\nvlm.setcoordsystem(system, O, Oaxis)\n\nvehicle = VehicleType(   system;\n                            vlm_system=vlm_system,\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n\n\n\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = [-1, 0, 0]        # <---- Vehicle is traveling in the -x direction\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = add_rotors ? (RPMcontrol, ) : ()     # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n\n\n\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n\n\n\n# ------------- *) AERODYNAMIC FORCES ------------------------------------------\n# Here we define the different components of aerodynamic of force that we desire\n# to capture with the wing using the actuator surface model\n\nforces = []\n\n# Calculate Kutta-Joukowski force\nkuttajoukowski = uns.generate_aerodynamicforce_kuttajoukowski(KJforce_type,\n                                sigma_vlm_surf, sigma_rotor_surf,\n                                vlm_vortexsheet, vlm_vortexsheet_overlap,\n                                vlm_vortexsheet_distribution,\n                                vlm_vortexsheet_sigma_tbv;\n                                vehicle=vehicle)\npush!(forces, kuttajoukowski)\n\n# Free-vortex force\nif include_freevortices\n    freevortices = uns.generate_calc_aerodynamicforce_freevortices(\n                                            vlm_vortexsheet_maxstaticparticle,\n                                            sigma_vlm_surf,\n                                            vlm_vortexsheet,\n                                            vlm_vortexsheet_overlap,\n                                            vlm_vortexsheet_distribution,\n                                            vlm_vortexsheet_sigma_tbv;\n                                            Ffv=uns.Ffv_direct,\n                                            include_TBVs=include_freevortices_TBVs\n                                            )\n    push!(forces, freevortices)\nend\n\n# Force due to unsteady circulation\nif include_unsteadyforce\n    unsteady(args...; optargs...) = uns.calc_aerodynamicforce_unsteady(args...;\n                                      add_to_Ftot=add_unsteadyforce, optargs...)\n\n    push!(forces, unsteady)\nend\n\n# Parasatic-drag force (form drag and skin friction)\nif include_parasiticdrag\n    parasiticdrag = uns.generate_aerodynamicforce_parasiticdrag(\n                            wing_polar_file;\n                            read_path=joinpath(data_path, \"airfoils\"),\n                            calc_cd_from_cl=calc_cd_from_cl,\n                            add_skinfriction=add_skinfriction,\n                            Mach=speedofsound!=nothing ? magVinf/speedofsound : nothing\n                            )\n\n    push!(forces, parasiticdrag)\nend\n\n\n# Stitch all the forces into one function\nfunction calc_aerodynamicforce_fun(vlm_system, args...; per_unit_span=false, optargs...)\n\n    # Delete any previous force field\n    fieldname = per_unit_span ? \"ftot\" : \"Ftot\"\n    if fieldname in keys(vlm_system.sol)\n        pop!(vlm_system.sol, fieldname)\n    end\n\n    Ftot = nothing\n\n    for (fi, force) in enumerate(forces)\n        Ftot = force(vlm_system, args...; per_unit_span=per_unit_span, optargs...)\n    end\n\n    return Ftot\nend\n\n\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\n# Generate wing monitor\nL_dir = [-sind(AOA), 0, cosd(AOA)]          # Direction of lift\nD_dir = [ cosd(AOA), 0, sind(AOA)]          # Direction of drag\n\nmonitor_wing = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            include_trailingboundvortex=include_trailingboundvortex,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            save_path=save_path,\n                                            run_name=run_name*\"-wing\",\n                                            figname=\"wing monitor\",\n                                            )\n\n# Generate rotors monitor\nmonitor_rotors = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                            t_scale=RPM/60,        # Scaling factor for time in plots\n                                            t_lbl=\"Revolutions\",   # Label for time axis\n                                            save_path=save_path,\n                                            run_name=run_name*\"-rotors\",\n                                            figname=\"rotors monitor\",\n                                            )\n\n# Generate monitor of flow enstrophy (indicates numerical stability)\nmonitor_enstrophy = uns.generate_monitor_enstrophy(;\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"enstrophy monitor\"\n                                            )\n\n# Generate monitor of SFS model coefficient Cd\nmonitor_Cd = uns.generate_monitor_Cd(;      save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"Cd monitor\"\n                                            )\n\n\n# Concatenate monitors\nall_monitors = [monitor_enstrophy, monitor_Cd]\n\nadd_wing ? push!(all_monitors, monitor_wing) : nothing\nadd_rotors ? push!(all_monitors, monitor_rotors) : nothing\n\nmonitors = uns.concatenate(all_monitors...)\n\n# Concatenate user-defined runtime function\nextra_runtime_function = uns.concatenate(monitors, wake_treatments...)\n\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\n\n# Run simulation\nuns.run_simulation(simulation, nsteps;\n\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho, mu=mu, sound_spd=speedofsound,\n\n                    # ----- SOLVERS OPTIONS ----------------\n                    vpm_integration=vpm_integration,\n                    vpm_viscous=vpm_viscous,\n                    vpm_SFS=vpm_SFS,\n\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    sigma_rotor_surf=sigma_rotor_surf,\n                    sigma_vlm_surf=sigma_vlm_surf,\n\n                    vlm_rlx=vlm_rlx,\n                    vlm_vortexsheet=vlm_vortexsheet,\n                    vlm_vortexsheet_overlap=vlm_vortexsheet_overlap,\n                    vlm_vortexsheet_distribution=vlm_vortexsheet_distribution,\n                    vlm_vortexsheet_sigma_tbv=vlm_vortexsheet_sigma_tbv,\n                    max_static_particles=vlm_vortexsheet_maxstaticparticle,\n\n                    hubtiploss_correction=hubtiploss_correction,\n\n                    shed_starting=shed_starting,\n                    shed_unsteady=shed_unsteady,\n                    unsteady_shedcrit=unsteady_shedcrit,\n\n                    extra_runtime_function=extra_runtime_function,\n\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    prompt=prompt,\n                    save_wopwopin=false,  # <--- Generates input files for PSU-WOPWOP noise analysis if true\n\n                    );\n\n\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_pfield...xmf;\")\n\n    if add_rotors\n        for ri in 1:nrotors\n            for bi in 1:B\n                global files *= run_name*\"_Rotor$(ri)_Blade$(bi)_loft...vtk;\"\n            end\n        end\n    end\n\n    if add_wing\n        files *= run_name*\"_Wing_vlm...vtk;\"\n    end\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Low fidelity run time: 13 minutes a Dell Precision 7760 laptop. <br>\n    Mid-low fidelity run time: 25 minutes a Dell Precision 7760 laptop. <br>\n    Mid-high fidelity run time: 70 minutes a Dell Precision 7760 laptop. <br>\n    High fidelity runtime: ~2 days on a 16-core AMD EPYC 7302 processor.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"<center>\n    <br><br>\n    <b>Mid-High Fidelity</b>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//prowimblown-compexp-midfi-composed.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n    <br><br><br><br>\n    <b>High Fidelity</b>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//prowimblown-compexp-hifi-composed.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n    <br><br><br>\n</center>","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"The favorable comparison with the experiment at alpha=0^circ and 4^circ confirms that ASM accurately predicts prop-on-wing interactions up to a moderate angle of attack. At alpha=10^circ we suspect that the wing is mildly stalled in the experiment, leading to a larger discrepancy (further discussed in Alvarez' Dissertation[1] and Alvarez & Ning, 2023[2]).","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"info: Source file\nFull example available under examples/prowim/.","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"[1]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [VIDEO] [PDF]","category":"page"},{"location":"examples/prowim-aero/","page":"Prop-on-Wing Interactions","title":"Prop-on-Wing Interactions","text":"[2]: E. J. Alvarez and A. Ning (2023), \"Meshless Large-Eddy Simulation of Propeller–Wing Interactions with Reformulated Vortex Particle Method,\" Journal of Aircraft. [DOI][PDF]","category":"page"},{"location":"theory/validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"The following is a compilation of validation studies found in the literature using FLOWUnsteady.","category":"page"},{"location":"theory/validation/#Wing","page":"Validation","title":"Wing","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Sources: E. J. Alvarez, 2022,[1] and E. J. Alvarez and A. Ning, 2023[2]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-particles06.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-n100-00.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: 45^circ swept-back wing at an angle of attack of 42^circ, aspect ratio of 5.0, RAE 101 airfoil section with 12% thickness, no dihedral, twist, nor taper. Freestream velocity of 497mathrmms, corresponding to a chord-based Reynolds number of 17 times 10^6. The high sweep of the wing causes non-negligible spanwise flow. The wing loads reported by Weber and Brebner (experimental) were integrated from pressure-tap measurements, hence the drag reported in this section includes induced and form drag while excluding skin friction drag.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: (Excerpt from E. J. Alvarez and A. Ning, 2022[2]) \"Fig. 9 shows the loading distribution and integrated lift and drag across AOA predicted with the actuator surface model (ASM), compared to the experimental measurements. The loading distribution shows satisfactory agreement with the experiment, validating that both the circulation solver and the force calculation... are accurate for predicting not only lift but also drag distribution across the span. The integrated lift and drag (Fig. 9, bottom) show excellent agreement with the experiment from 0^circ to 105^circ. We expect this to be the case only for mild AOAs before approaching stall conditions since our ASM does not capture the mechanisms of flow separation. Thus, through this swept-wing case, we gain confidence that our ASM yields accurate predictions in conditions with spanwise flow up to a moderate AOA.\"","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-val00.png\"\n                                          alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"theory/validation/#Rotor","page":"Validation","title":"Rotor","text":"","category":"section"},{"location":"theory/validation/#Hover-Case:-Aero","page":"Validation","title":"Hover Case: Aero","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez, 2022[1], and E. J. Alvarez and A. Ning, 2022[6]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-highfidelity00.png\"\n                                            alt=\"Pic here\" style=\"width: 80%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: DJI 9443 rotor in hover at 5400 RPM. This is a two-bladed rotor with a diameter of 9.4 inches. Validation case at Mach number of 0.2, mathrmRe_c = 6 times 10^4, and mathrmRe_07D = 7 times 10^5. Thrust and blade loading are compared to experiment and mesh-based CFD. Computational time is benchmarked against conventional mesh-based CFD.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: (Excerpt from E. J. Alvarez and A. Ning, 2020[6]) \"...the VPM simulation shows excellent agreement with the experiment, predicting a mean C_T value within 2% of the experimental mean value... Our meshless LES appears to be two orders of magnitude faster than a mesh-based LES with similar fidelity, while being one order of magnitude faster than a low-fidelity URANS simulation and three orders of magnitude than high-fidelity DES.\"","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-dji9443-aero00.png\"\n      alt=\"Pic here\" style=\"width: 49%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-dji9443-aero01.png\"\n      alt=\"Pic here\" style=\"width: 49%;\"/>\n  <br><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-dji9443-aero02.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Hover-Case:-Acoustics","page":"Validation","title":"Hover Case: Acoustics","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez, A. Schenk, T. Critchfield, and A. Ning, 2020[7]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Same DJI 9443 case in hover. FLOWUnsteady predictions (VPM) are compared against experiment and URANS (STAR-CCM+) and DES (OVERFLOW2).","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-dji9443-noise00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <br><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-dji9443-noise10.png\"\n      alt=\"Pic here\" style=\"width: 70%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"NOTE: The broadband results in E. J. Alvarez, A. Schenk, T. Critchfield, and A. Ning, 2020[7] contained a bug that ended up evaluating the microphone array in the wrong plane, which led to a large discrepancy in A-weighted OASPL. For updated results, see the Rotor in Hover tutorial.","category":"page"},{"location":"theory/validation/#Forward-Flight-Case","page":"Validation","title":"Forward Flight Case","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: R. M. Erhard and J. J. Alonso, 2022[8]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-erhard00.png\"\n                                            alt=\"Pic here\" style=\"width:100%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: TUD F29 rotor in forward flight at an incidence angle (edgewise flow). This is a four-bladed rotor. Thrust and power predicted by FLOWUnsteady (VPM) was compared to experiment and low-fidelity methods at  multiple incidence angles alpha and advance ratios J.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: Good agreement between FLOWUnsteady and experiment for incidence angles up to alpha=60^circ across advance ratio.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-erhard01.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Wind-Turbine","page":"Validation","title":"Wind Turbine","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: J. Mehr, E. J. Alvarez, and A. Ning, 2022[5]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine.png\" alt=\"Pic here\" style=\"width: 45%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Test series \"H\" from UAE study at US Department of Energy. Sweep on tip speed ratio lambda = fracomega Ru_infty.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: (Excerpt from J. Mehr, E. J. Alvarez, and A. Ning, 2020[5]) \"The torque coefficient outputs are also within 10% for tip speed ratios above, and within 25% for tip speed ratios under, lambda = 20; also notice that the absolute magnitudes of the torque coefficient are very small at low tip speed ratios, assuaging any concerns about the higher relative errors at those operational states.\"","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine-val00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Propeller","page":"Validation","title":"Propeller","text":"","category":"section"},{"location":"theory/validation/#APC-10x7-Case","page":"Validation","title":"APC 10x7 Case","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez and A. Ning, 2020[3]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apc10x7geom.png\" alt=\"Pic here\" style=\"width: 55%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: APC 10x7E propeller (2 blades, 10'' diameter, solidity 0.1) at a tip Mach number of 0.36, mathrmRe_c = 62 times 10^4, and mathrmRe_D = 65 times 10^5. Sweep on advance ratio J = fracu_inftyn d.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: (Excerpt from E. J. Alvarez and A. Ning, 2020[3]) \"... it is confirmed that the VPM propeller model is valid... across low and moderately high advance ratios.\"","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apc10x7val00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Beaver-Case","page":"Validation","title":"Beaver Case","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez, 2022[1], and E. J. Alvarez and A. Ning, 2023[2]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/prowim_isolatedprop-vortvol_3-shortsmall01.gif\"\n      alt=\"Vid here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Beaver propeller (4 blades, 0.237 m diameter) at mathrmRe_07D = 18times 10^6. Extensive validation with predicted thrust, torque, efficiency, blade loading, and flow field compared to experimental measurements.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <b>Sweep of advance ratio</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-beaver01.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n\n  <br>\n  <b>Sweep of incidence angle</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-beaver02.png\"\n      alt=\"Pic here\" style=\"width: 75%;\"/>\n\n  <br><br>\n  <b>Blade loading</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-beaver03.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n\n  <br>\n  <b>Wake structure</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-beaver04.png\"\n      alt=\"Pic here\" style=\"width: 80%;\"/>\n\n  <br><br>\n  <b>Flow field</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-beaver05.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-beaver06.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n\n  <br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/prowim_isolatedprop-vortvolslice_1-shortsmall00.gif\"\n      alt=\"Vid here\" style=\"width: 70%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/prowim_isolatedprop-vortslice_1-shortsmall00.gif\"\n      alt=\"Vid here\" style=\"width: 70%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Rotor-Rotor-Interactions","page":"Validation","title":"Rotor-Rotor Interactions","text":"","category":"section"},{"location":"theory/validation/#Side-by-Side-Rotors-in-Hover","page":"Validation","title":"Side-by-Side Rotors in Hover","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez and A. Ning, 2020[3]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-sidebyside00.png\" alt=\"Pic here\" style=\"width: 55%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Two side-by-side DJI rotors in hover. Two-bladed rotors with a diameter of 9.4 inches. Test at 4860 RPM, tip Mach number of 0.18, mathrmRe_c = 62times 10^4, and mathrmRe_07D = 65times 10^5. Aerodynamic interactions as the tip-to-tip spacing s between rotors is decreased.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: FLOWUnsteady accurately captures both the drop in thrust and the increase in fluctuations as rotors are brought closer together.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-sidebyside01.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Side-by-Side-and-Tandem-Propeller","page":"Validation","title":"Side-by-Side and Tandem Propeller","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: R. M. Erhard and J. J. Alonso, 2022[8]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-erhard02.png\"\n                                            alt=\"Pic here\" style=\"width:100%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Two TUD F29 propellers in side-by-side and tandem configurations at an multile incidence angles (edgewise flow). This is a four-bladed rotor. Thrust and power predicted by FLOWUnsteady (VPM) was compared to experiment and low-fidelity methods at  multiple incidence angles alpha and advance ratios J.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: Good agreement between FLOWUnsteady and experiment for incidence angles up to alpha=60^circ across advance ratio.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-erhard05.png\"\n    alt=\"Pic here\" style=\"width: 90%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-erhard04.png\"\n    alt=\"Pic here\" style=\"width: 70%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-erhard03.png\"\n      alt=\"Pic here\" style=\"width: 50%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-erhard06.png\"\n      alt=\"Pic here\" style=\"width: 47%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Rotor-Wing-Interactions","page":"Validation","title":"Rotor-Wing Interactions","text":"","category":"section"},{"location":"theory/validation/#Tailplane-w/-Tip-Mounted-Propellers","page":"Validation","title":"Tailplane w/ Tip-Mounted Propellers","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez, 2022[1], and E. J. Alvarez and A. Ning, 2023[2]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Horizontal stabilizer (tailplane) with tip-mounted Beaver propellers. Wing with low aspect ratio (bc=27), symmetric NACA 64_2-mathrmA015 profile, and elevator flap. Test at advance ratio J of 0.8 and inboard-up propeller rotation at a thrust setting of C_T = 00935. Flap deflection captured in the actuator surface model (ASM) through an equivalent twist. Effects of wake impingement on wing loading predicted by FLOWUnsteady are compared to experiment.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <b>Flat wing ($\\alpha = 0^\\circ$, $\\delta_e=0^\\circ$)</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane03.png\"\n      alt=\"Pic here\" style=\"width: 90%;\"/>\n\n  <br><br><br>\n  <b>Lift augmentation</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane02.png\"\n      alt=\"Pic here\" style=\"width: 35%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane08.png\"\n      alt=\"Pic here\" style=\"width: 50%;\"/>\n\n  <br><br><br>\n  <b>Wing wake and Streamtube</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane04.png\"\n      alt=\"Pic here\" style=\"width: 64%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane05.png\"\n      alt=\"Pic here\" style=\"width: 35%;\"/>\n\n  <br><br><br>\n  <b>Effects of swirl direction</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane06.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n\n  <br><br><br>\n  <b>Strong impingement</b><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-tailplane09.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Blown-Wing","page":"Validation","title":"Blown Wing","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez, 2022[1], and E. J. Alvarez and A. Ning, 2023[2]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-blown00.png\"\n      alt=\"Pic here\" style=\"width: 40%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Straight wing with Beaver propellers mounted mid-span. Wing of aspect ratio bc=533, symmetric NACA 64_2-mathrmA015 profile. Test at advance ratio J of 0.85 and inboard-up propeller rotation at a thrust setting of C_T = 0121. Effects of wake impingement on wing loading predicted by FLOWUnsteady are compared to experiment.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-blown01.png\"\n      alt=\"Pic here\" style=\"width: 80%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/val-blown02.png\"\n      alt=\"Pic here\" style=\"width: 80%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[1]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [PDF]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[2]: E. J. Alvarez & A. Ning (2023), \"Meshless Large Eddy Simulation of Propeller-Wing Interactions Through the Reformulated Vortex Particle Method,\" Journal of Aircraft. [DOI] [PDF]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[3]: E. J. Alvarez & A. Ning (2020), \"High-Fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design,\" AIAA Journal. [DOI] [PDF]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[5]: J. Mehr, E. J. Alvarez, & A. Ning (2022), \"Interactional Aerodynamics Analysis of a Multi-Rotor Energy Kite,\" (in review).","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[6]: E. J. Alvarez & A. Ning (2023), \"Stable Vortex Particle Method Formulation for Meshless Large-Eddy Simulation,\" AIAA Journal. [DOI] [PDF]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[7]: E. J. Alvarez, A. Schenk, T. Critchfield, and A. Ning (2020), “Rotor-on-Rotor Aeroacoustic Interactions of Multirotor in Hover,” VFS 76th Forum. [PDF]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[8]: R. M. Erhard and J. J. Alonso (2022), \"Comparison of Propeller Wake Models for Distributed Electric Propulsion and eVTOL Aircraft in Complex Flow Conditions,\" AIAA SciTech Forum. [PDF]","category":"page"},{"location":"api/flowunsteady-postprocessing-fdom/#fluid_domain","page":"Fluid Domain","title":"Fluid Domain","text":"","category":"section"},{"location":"api/flowunsteady-postprocessing-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"  FLOWUnsteady.computefluiddomain\n  FLOWUnsteady.generate_preprocessing_fluiddomain_pfield","category":"page"},{"location":"api/flowunsteady-postprocessing-fdom/#FLOWUnsteady.computefluiddomain","page":"Fluid Domain","title":"FLOWUnsteady.computefluiddomain","text":"computefluiddomain( pfield::FLOWVPM.ParticleField,\n                    grids::Array{<:GeometricTools.AbstractGrid};\n                    optargs...\n                    )\n\nEvaluate the velocity and vorticity field induced by the particle field pfield at all nodes in a set of grids grids. The fields are added as solution fields U and W in each grid. The analytic Jacobian of the velocity field can also be saved using the optional argument add_J=true.\n\nOPTIONAL ARGUMENTS\n\nProcessing options\n\nadd_J::Bool=false       : Add the solution fields J1, J2, and J3 to                               each grid, where Ji[j]=dUi/dxj.\nadd_Uinf::Bool=false    : It evaluates and adds the uniform freestream to                               the U field.\nadd_Wapprox::Bool=false : It evaluates and saves the RBF-approximated                               vorticity field under the field Wapprox.\nzeta::Function=FLOWVPM.zeta_fmm : Method for evaluating RBF-approximated vorticity                               (used only if add_Wapprox==true).\nscale_sigma::Real=1.0   : It rescales the smoothing radius of each particle                               by this factor before evaluating the particle                               field.\n\nOutput options\n\nsave_path::String       : If used, it will save the grids as XDMF files                               under this path.\nfile_pref::String       : Prefix for XDMF files.\ngrid_names::String      : Name of each grid for XDMF files. If not given, it                               will generate their names automatically.\nnum::Int                : If given, the name of the XDMF files will be                               \"$(file_pref)$(grid_names[i]).$(num).vtk\"\nverbose::Bool=true      : Activate/deactivate verbose.\nv_lvl::Int=0            : Indentation level for printing verbose.\n\nNOTE: The solution fields U, W, and Jacobian do not include the freestream         field, but rather they only include the fields induced by the particles.         To add the freestream to U, use the optional argument add_Uinf=true.\n\n\n\n\n\ncomputefluiddomain(pfield::vpm.ParticleField,\n                    nums::Vector{Int}, read_path::String, file_pref::String,\n                    grids;\n                    origin=nothing,\n                    orientation=nothing,\n                    other_read_paths=[],\n                    other_file_prefs=[],\n                    userfunction_pfield=(pfield, num, grids)->nothing,\n                    optargs...\n                    )\n\nEvaluate the fluid domain at each time step in nums that is induced by a particle field saved under read_path. file_pref indicates the prefix of the .h5 files to read.\n\nTo translate and re-orient the grids at each time step, the user can pass the new origin vector and orientation matrix through the functions origin and orientation, which will be called as origin(pfield, num) and orientation(pfield, num) at each time step.\n\npfield is a place holder for loading the particles that are read, so the user must make sure that sufficient memory has been preallocated to hold the number of particles of each time step that will be read, plus the number of nodes in the grids. The fluid domain will be evaluated using the UJ and FMM configuration of the given pfield particle field.\n\nTo read and add more than one particle field at each time step, pass a list of paths and prefixes through other_read_paths and other_file_prefs. This is useful for reading and incluiding a set of static particles, for example.\n\nGive it a function userfunction_pfield to pre-process the resulting particle field before evaluating the fluid domain (e.g., remove particles, resize core sizes, etc).\n\n\n\n\n\ncomputefluiddomain(maxparticles::Int, args...;\n                    UJ::Function=vpm.UJ_fmm,\n                    fmm::FLOWVPM.FMM=vpm.FMM(; p=4, ncrit=50, theta=0.4, phi=0.5),\n                    pfield_optargs=[]\n                    optargs...)\n\nLike the other computefluiddomain(args...; optargs...) methods, but automatically pre-allocating and initializing the particle field with the given maximum number of particles, UJ evaluation method, and FMM configuration (if FMM is used by UJ).\n\nUse pfield_optargs to pass any additional optional arguments to the particle field constructor.\n\n\n\n\n\ncomputefluiddomain(P_min, P_max, NDIVS, args...;\n                    spacetransform=nothing,\n                    O=zeros(3), Oaxis=Float64[i==j for i in 1:3, j in 1:3],\n                    optargs...)`\n\nLike the other computefluiddomain(args...; optargs...) methods, but automatically generating a fluid domain grid. The grid is generated as a Cartesian box with minimum and maximum corners P_min and P_max and NDIVS cells.\n\nFor instance, P_min=[-1, -1, -1], P_max=[-1, -1, -1], and NDIVS=[10, 10, 50] will grid the volumetric space between -1 and 1 in all directions, with 10 cells in both the x and y-direction, and 50 cells in the z-direction.\n\nEven though the grid is first generated as a Cartesian grid, this can be transformed into any other structured space through the argument spacetransform, which is a function that takes any vector and returns another vector of the same dimensions. For instance, P_min=[0.5, 0, 0], P_max=[1, 2*pi, 5], NDIVS=[10, 20, 30], spacetransform=GeometricTools.cylindrical3D will generate a cylindrical grid discretizing the radial annulus from 0.5 to 1 with 10 cells, the polar angle from 0 to 360deg with 20 cells, and the axial z-distance from 0 through 5 with 30 cells.\n\nAny number of dimensions can be used, but make sure that P_min, P_max, and NDIVS always have three dimensions and indicate the dimensions that are \"collapsed\" with a 0 in NDIVS. Even though the grid is defined in the Cartesian axes, the origin and orientation of the grid can be specified with the O and Oaxis optional arguments. For instance, P_min=[0, 0, 1], P_max=[2, 3.5, 1], NDIVS=[10, 10, 0] will generate a 2D surface laying in the xy-plane at z=1.0, spanning from (x,y)=(0,0) to (x,y)=(2,3.5). Use O=[0, 0, -1] to move the surface back to the xy-plane at z=0. Use Oaxis=[1 0 0; 0 0 -1; 0 1 0] to re-orient the surface to lay in the zx-plane. The same thing can be achieved with Oaxis=GeometricTools.rotation_matrix2(-90, 0, 0) which generates the rotation matrix corresponding to a -90deg rotation about the x-axis.\n\nNOTE: The order of operation is (1) Cartesian grid generation, (2) space transformation if any, and (3) translation and re-orientation to the given origin and orientation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-fdom/#FLOWUnsteady.generate_preprocessing_fluiddomain_pfield","page":"Fluid Domain","title":"FLOWUnsteady.generate_preprocessing_fluiddomain_pfield","text":"generate_preprocessing_fluiddomain_pfield(maxsigma, maxmagGamma;\n                                                verbose=true, v_lvl=1)\n\nGenerate function for pre-processing particle fields before generating fluid domain: shrink oversized particles and correct blown-up particles.\n\nPass the output function to FLOWUnsteady.computefluiddomain through the keyword argument userfunction_pfield. For example:\n\npreprocess_pfield = generate_preprocessing_fluiddomain_pfield(maxsigma, maxmagGamma;\n                                                                verbose=true, v_lvl=1)\n\ncomputefluiddomain( ... ; userfunction_pfield=preprocess_pfield, ...)\n\n\n\n\n\n","category":"function"},{"location":"installation/windows/#windows","page":"Windows Instructions","title":"Windows Instructions","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"(Tested on Windows 11)","category":"page"},{"location":"installation/windows/#Install-Windows-Subsystem-for-Linux-(WSL)","page":"Windows Instructions","title":"Install Windows Subsystem for Linux (WSL)","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Follow this guide to setup Ubuntu 22.04: LINK\nIf you run into issues, try the following:\nEnable bash for Windows LINK\nEnable virtualization LINK. For instance, here are instructions specific for a Dell Precision 7760: LINK1 LINK2 (make sure to check \"Hyper-V\")","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"To launch WSL, we recommend launching it from the Microsoft Store as opposed to the Programs Menu or the terminal, otherwise Windows' PATH will not be passed onto WSL.","category":"page"},{"location":"installation/windows/#Set-up-Environment","page":"Windows Instructions","title":"Set up Environment","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Once inside WSL, do the following","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Install system-level packages:\nsudo apt-get update\nsudo apt-get install cmake g++ mpich\nInstall python packages:\nsudo apt-get install python3-pip python3-tk\npip3 install matplotlib mpmath scipy --user\nCreate a folder where to install programs\nmkdir ~/Programs\ncd ~/Programs","category":"page"},{"location":"installation/windows/#Install-Julia","page":"Windows Instructions","title":"Install Julia","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Download Julia:\nwget -O julia.tar.gz \"https://julialang-s3.julialang.org/bin/linux/x64/1.8/julia-1.8.5-linux-x86_64.tar.gz\"\nDecompress Julia:\ntar -xvf julia.tar.gz -C ~/Programs/\nAdd Julia to user-level path:\nsudo ln -s ~/Programs/julia-1.8.5/bin/julia /usr/local/bin/","category":"page"},{"location":"installation/windows/#Install-ParaView","page":"Windows Instructions","title":"Install ParaView","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Donwload and install ParaView v5.9.1\nIdentify the location of paraview.exe (most likely, this is C:\\Program Files\\ParaView 5.9.1\\bin\\)\nAdd the path of ParaView (e.g., C:\\Program Files\\ParaView 5.9.1\\bin\\) to the system-level PATH: LINK\nCreate a paraview alias inside WSL typing this in the WSL terminal:\nwhich paraview.exe | xargs -I{} sudo ln -s {} /usr/local/bin/paraview","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"info: ParaView 5.10+ on Windows\nParaView versions 5.10 and newer on Windows cannot open XDMF files (like the particle field) from the WSL file system. Please copy them to a Windows file system or use Paraview 5.9.1.","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Now you can proceed with the general instructions (you can skip the Julia and ParaView since we already took care of that)","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/flowunsteady-logo-wide03.png\" alt=\"FLOWUnsteady logo\" style=\"width:100%\">","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"right\">\n  <span style=\"color:#2f6990;\">\n    <i>Interactional aerodynamics solver for multirotor aircraft and wind energy</i>\n  </span>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"right\">\n  <a href=\"https://github.com/byuflowlab/FLOWUnsteady\">\n    <img src=\"https://img.shields.io/badge/code-open%20source-brightgreen.svg\">\n  </a>\n  <a href=\"https://flow.byu.edu/FLOWUnsteady/\">\n    <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\">\n  </a>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"FLOWUnsteady is an open-source variable-fidelity framework for unsteady aerodynamics and aeroacoustics based on the reformulated vortex particle method (rVPM). This suite brings together various tools developed by the FLOW Lab at Brigham Young University: Vortex lattice method, strip theory, blade elements, 3D panel method, and rVPM. The suite also integrates an FW-H solver and a BPM code for tonal and broadband prediction of aeroacoustic noise. In the low end of fidelity, simulations are similar to a free-wake method, while in the high end simulations become meshless large eddy simulations.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Documentation: flow.byu.edu/FLOWUnsteady\nCode: github.com/byuflowlab/FLOWUnsteady","category":"page"},{"location":"#What-is-the-Reformulated-VPM?","page":"Intro","title":"What is the Reformulated VPM?","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"The reformulated VPM is a meshless CFD method solving the LES-filtered incompressible Navier-Stokes equations in their vorticity form,","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/vorticityns.png\" alt=\"img\" style=\"width:40%\">\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"It uses a Lagrangian (meshless) scheme, which not only avoids the hurdles of mesh generation, but it also conserves vortical structures over long distances with minimal numerical dissipation.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"The rVPM uses particles to discretize the Navier-Stokes equations, with the particles representing radial basis functions that construct a continuous vorticity/velocity field. The basis functions become the LES filter, providing a variable filter width and spatial adaptation as the particles are convected and stretched by the velocity field. The local evolution of the filter width provides an extra degree of freedom to reinforce conservation laws, which makes the reformulated VPM numerically stable (overcoming the numerical issues that plague the classic VPM).","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"This meshless LES has several advantages over conventional mesh-based CFD. In the absence of a mesh,   ","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"the rVPM does not suffer from the numerical dissipation introduced by a mesh\nintegrates over coarser discretizations without losing physical accuracy\nderivatives are calculated analytically rather than approximated through a stencil.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Furthermore, rVPM is highly efficient since it uses computational elements only where there is vorticity (rather than meshing the entire space), usually being ~100x faster than conventional mesh-based LES with comparable accuracy.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"While rVPM is well suited for resolving unbounded flows (wakes), complications arise when attempting to impose boundary conditions (solid boundaries) on the flow. This is because (1) the method is meshless, and (2) boundary conditions must be imposed on the Navier-Stokes equations in the form of vorticity. FLOWUnsteady is a framework designed to introduce solid boundaries into the rVPM using actuator models. Wings and rotors are introduced in the computational domain through actuator line and surface models that use low-fidelity aerodynamic methods (e.g., VLM, lifting line, panels, etc) to compute forces and embed the associated vorticity back into the LES domain.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/-6aR37Z6hig?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"#Variable-Fidelity","page":"Intro","title":"Variable Fidelity","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"rVPM considerably reduces engineering time by avoiding the hurdles of mesh generation. Furthermore, since it is not limited by the time-step and stability constraints of conventional mesh-based CFD, rVPM can be used across all levels of fidelity, all in the same framework by simply coarsening or refining the simulation. In the low end of fidelity, simulations are similar to a free-wake method, while in the high end simulations become meshless large eddy simulations. Thus, FLOWUnsteady can be used as a high-fidelity tool that is orders of magnitude faster than mesh-based CFD, or as a variable-fidelity tool for the different stages of design.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"left\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/flowunsteady-variablefidelity.jpg\" alt=\"img\" style=\"width:100%\">\n</p>","category":"page"},{"location":"#Capabilities","page":"Intro","title":"Capabilities","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Simulation: Tilting wings and rotors • Rotors with variable RPM and variable pitch • Asymmetric and stacked rotors • Maneuvering vehicle with prescribed kinematicsrVPM Solver: Fast-multipole acceleration through ExaFMM • CPU parallelization through OpenMP • Second-order spatial accuracy and third-order RK time integration • Numerically stable by reshaping particles subject to vortex stretching • Subfilter-scale (SFS) model of turbulence associated to vortex stretching • SFS model coefficient computed dynamically or prescribed • Viscous diffusion through core spreadingWing Models: Actuator line model through lifting line + VLM • Actuator surface model through vortex sheet + VLM • Parasitic drag through airfoil lookup tablesRotor Model: Actuator line model through blade elements • Airfoil lookup tables automatically generated through XFOIL • Aeroacoustic noise through FW-H (PSU-WOPWOP) and BPMGeometry: Simple lofts and bodies of revolution through FLOWUnsteady • Import complex geometry from OpenVSPUnder development (🤞coming soon): Advanced actuator surface models through 3D panel method (for ducts, wings, and fuselage) • Unstructured surface grids • Bluff bodies through vortex sheet methodLimitations: Viscous drag and separation is only captured through airfoil lookup tables, without attempting to shed separation wakes • Incompressible flow only (though wave drag can be captured through airfoil lookup tables) • CPU parallelization through OpenMP without support for distributed memory (no MPI, i.e., only single-node runs)Coded in the Julia language for Linux, MacOS, and Windows WSL.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"More about the models inside FLOWUnsteady:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <a href=\"https://www.nas.nasa.gov/pubs/ams/2022/08-09-22.html\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/nasaamsseminar2.png\" alt=\"https://www.nas.nasa.gov/pubs/ams/2022/08-09-22.html\" style=\"width:70%\">\n  </a>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Selected-Publications","page":"Intro","title":"Selected Publications","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"See the following publications for an in-depth dive into the theory and validation:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"E. J. Alvarez, J. Mehr, & A. Ning (2022), \"FLOWUnsteady: An Interactional Aerodynamics Solver for Multirotor Aircraft and Wind Energy,\" AIAA AVIATION Forum. [VIDEO] [PDF]\nE. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft.,\" Doctoral Dissertation, Brigham Young University. [VIDEO] [PDF]\nE. J. Alvarez & A. Ning (2023), \"Stable Vortex Particle Method Formulation for Meshless Large-Eddy Simulation,\" AIAA Journal. [PDF]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Examples-and-Tutorials","page":"Intro","title":"Examples and Tutorials","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Propeller: [Tutorial] [Validation]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/lUIytQybCpQ?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Rotor in Hover: [Tutorial] [Validation]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/u9SgYbYhPpU?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Blown Wing: [Tutorial] [Validation]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/GfS3NoVrFfU?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Ducted Fan: [Paper]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/BQpar3A0X-w?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Airborne-Wind-Energy Aircraft: [Video]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"left\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/circular-fdom-top02.jpg\" alt=\"img\" style=\"width:75%\">\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"eVTOL Transition: [Tutorial]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Mid-fidelity","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/d__wNtRIBY8?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"High-fidelity","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/-6aR37Z6hig?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Aeroacoustic Noise: [Tutorial] [Validation]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/ntQjP6KbZDk?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/cfdnoise_ningdji_multi_005D_03_20.gif\" alt=\"Vid\" style=\"width:60%\"/>\n</p>","category":"page"},{"location":"#Sponsors","page":"Intro","title":"Sponsors","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/sponsors01.png\" alt=\"img\" style=\"width:100%\">\n  <br><br><br>\n</p>","category":"page"},{"location":"#About","page":"Intro","title":"About","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"FLOWUnsteady is an open-source project jointly led by the FLOW Lab at Brigham Young University and Whisper Aero. All contributions are welcome.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"If you find FLOWUnsteady useful in your work, we kindly request that you cite the following paper [URL] [PDF]:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Alvarez, E. J., Mehr, J., and Ning, A., “FLOWUnsteady: An Interactional Aerodynamics Solver for Multirotor Aircraft and Wind Energy,” AIAA AVIATION 2022 Forum, Chicago, IL, 2022. DOI:10.2514/6.2022-3218.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"If you were to encounter any issues or have questions, please first read through the documentation, open/closed issues, and the discussion forum. If the issue still persists, please participate in the discussion forum and/or open a new issue.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Developers/contributors : Eduardo J. Alvarez (main), Cibin Joseph, Judd Mehr, Ryan Anderson, Eric Green\nCreated           : Sep 2017\nLicense           : MIT License","category":"page"},{"location":"examples/blownwing-acoustics/#Acoustic-Solution","page":"Acoustic Solution","title":"Acoustic Solution","text":"","category":"section"},{"location":"api/flowunsteady-monitor/#(4)-Monitors-Definitions","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"A monitor is a function that is passed to FLOWUnsteady.run_simulation as an extra runtime function that is called at every time step. Runtime functions are expected to return a Boolean that indicates the need of stopping the simulation, such that if extra_runtime_function ever returns true, the simulation will immediately be ended.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Multiple monitors can be concatenated with boolean logic as follows","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"import FLOWUnsteady as uns\n\nmonitor_states = uns.generate_monitor_statevariables()\nmonitor_enstrophy = uns.generate_monitor_enstrophy()\n\nmonitors(args...; optargs...) = monitor_states(args...; optargs...) || monitor_enstrophy(args...; optargs...)","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Then pass the monitor to the simulation as","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"uns.run_simulation(sim, nsteps; extra_runtime_function=monitors, ...)","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"compat: Monitor concatenation\nFLOWUnsteady facilitates the concatenation of monitors through the function FLOWUnsteady.concatenate. Using this function, the example above looks like this:monitor_states = uns.generate_monitor_statevariables()\nmonitor_enstrophy = uns.generate_monitor_enstrophy()\n\nallmonitors = [monitor_states, monitor_enstrophy]\n\nmonitors = uns.concatenate(monitors)\n\nuns.run_simulation(sim, nsteps; extra_runtime_function=monitors, ...)","category":"page"},{"location":"api/flowunsteady-monitor/#Monitor-Generators","page":"(4) Monitors Definitions","title":"Monitor Generators","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"The following are functions for generating the monitors that serve most use cases. See the source code of these monitors to get an idea of how to write your own user-defined monitors.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"FLOWUnsteady.generate_monitor_statevariables\nFLOWUnsteady.generate_monitor_wing\nFLOWUnsteady.generate_monitor_rotors\nFLOWUnsteady.generate_monitor_enstrophy\nFLOWUnsteady.generate_monitor_Cd\nFLOWUnsteady.concatenate","category":"page"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_statevariables","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_statevariables","text":"generate_monitor_statevariables(; save_path=nothing)\n\nGenerate a monitor plotting the state variables of the vehicle at every time step. The state variables are vehicle velocity, vehicle angular velocity, and vehicle position.\n\nUse save_path to indicate a directory where to save the plots.\n\nHere is an example of this monitor on a vehicle flying a circular path: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_wing","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_wing","text":"generate_monitor_wing(wing::Union{vlm.Wing, vlm.WingSystem},\n                        Vinf::Function, b_ref::Real, ar_ref::Real,\n                        rho_ref::Real, qinf_ref::Real, nsteps_sim::Int;\n                        L_dir=[0,0,1],      # Direction of lift component\n                        D_dir=[1,0,0],      # Direction of drag component\n                        calc_aerodynamicforce_fun=FLOWUnsteady.generate_calc_aerodynamicforce())\n\nGenerate a wing monitor computing and plotting the aerodynamic force and wing loading at every time step.\n\nThe aerodynamic force is integrated, decomposed, and reported as overall lift coefficient C_L = fracLfrac12rho u_infty^2 b c and drag coefficient C_D = fracDfrac12rho u_infty^2 b c. The wing loading is reported as the sectional lift and drag coefficients defined as c_ell = fracellfrac12rho u_infty^2 c and c_d = fracdfrac12rho u_infty^2 c, respectively.\n\nThe aerodynamic force is calculated through the function calc_aerodynamicforce_fun, which is a user-defined function. The function can also be automatically generated through, generate_calc_aerodynamicforce which defaults to incluiding the Kutta-Joukowski force, parasitic drag (calculated from a NACA 0012 airfoil polar), and unsteady-circulation force.\n\nb_ref       : Reference span length.\nar_ref      : Reference aspect ratio, used to calculate the equivalent chord c = fracbmathrmar.\nrho_ref     : Reference density.\nqinf_ref    : Reference dynamic pressure q_infty = frac12rho u_infty^2.\nnsteps_sim  : the number of time steps by the end of the simulation (used for generating the color gradient).\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with C_L and C_D.\n\nHere is an example of this monitor: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_rotors","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_rotors","text":"generate_monitor_rotors(rotors::Array{vlm.Rotor}, J_ref::Real,\n                            rho_ref::Real, RPM_ref::Real, nsteps_sim::Int;\n                            save_path=nothing)\n\nGenerate a rotor monitor plotting the aerodynamic performance and blade loading at every time step.\n\nThe aerodynamic performance consists of thrust coefficient C_T=fracTrho n^2 d^4, torque coefficient C_Q = fracQrho n^2 d^5, and propulsive efficiency eta = fracT u_infty2pi n Q.\n\nJ_ref and rho_ref are the reference advance ratio and air density used for calculating propulsive efficiency and coefficients. The advance ratio used here is defined as J=fracu_inftyn d with n = fracmathrmRPM60.\nRPM_ref is the reference RPM used to estimate the age of the wake.\nnsteps_sim is the number of time steps by the end of the simulation (used for generating the color gradient).\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with C_T, C_Q, and eta.\n\n(Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_enstrophy","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_enstrophy","text":"generate_monitor_enstrophy(; save_path=nothing)\n\nGenerate a monitor plotting the global enstrophy of the flow at every time step (computed through the particle field). This is calculated by integrating the local enstrophy defined as ξ = ω⋅ω / 2.\n\nEnstrophy is approximated as 0.5*Σ( Γ𝑝⋅ω(x𝑝) ). This is consistent with Winckelamns' 1995 CTR report, \"Some Progress in LES using the 3-D VPM\".\n\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with ξ.\n\nHere is an example of this monitor: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_Cd","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_Cd","text":"generate_monitor_Cd(; save_path=nothing)\n\nGenerate a monitor plotting the mean value of the SFS model coefficient C_d across the particle field at every time step. It also plots the ratio of C_d values that were clipped to zero (not included in the mean).\n\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with the statistics of C_d (particles whose coefficients have been clipped are ignored).\n\nHere is an example of this monitor: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.concatenate","page":"(4) Monitors Definitions","title":"FLOWUnsteady.concatenate","text":"concatenate(monitors::Array{Function})\nconcatenate(monitors::NTuple{N, Function})\nconcatenate(monitor1, monitor2, ...)\n\nConcatenates a collection of monitors into a pipeline, returning one monitor of the form\n\nmonitor(args...; optargs...) =\n    monitors[1](args...; optargs...) || monitors[2](args...; optargs...) || ...\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#Force-Calculators","page":"(4) Monitors Definitions","title":"Force Calculators","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"The following are some possible methods for calculating aerodynamic forces. Generator functions return a function that can be directly passed to FLOWUnsteady.generate_monitor_wing through the keyword argument calc_aerodynamicforce_fun.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"FLOWUnsteady.generate_calc_aerodynamicforce\nFLOWUnsteady.generate_aerodynamicforce_kuttajoukowski\nFLOWUnsteady.generate_aerodynamicforce_parasiticdrag\nFLOWUnsteady.calc_aerodynamicforce_unsteady","category":"page"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_calc_aerodynamicforce","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_calc_aerodynamicforce","text":"generate_calc_aerodynamicforce(; add_parasiticdrag=false,\n                                      add_skinfriction=true,\n                                      airfoilpolar=\"xf-n0012-il-500000-n5.csv\",\n                                      parasiticdrag_args=(),\n                                      )\n\nDefault method for calculating aerodynamic forces.\n\nPass the output of this function to generate_monitor_wing, or use this as an example on how to define your own costumized force calculations.\n\nThis function stitches together the outputs of generate_aerodynamicforce_kuttajoukowski and generate_aerodynamicforce_parasiticdrag, and calc_aerodynamicforce_unsteady. See Alvarez' dissertation, Sec. 6.3.3.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_aerodynamicforce_kuttajoukowski","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_aerodynamicforce_kuttajoukowski","text":"generate_aerodynamicforce_kuttajoukowski(KJforce_type::String,\n                            sigma_vlm_surf, sigma_rotor_surf,\n                            vlm_vortexsheet,\n                            vlm_vortexsheet_overlap,\n                            vlm_vortexsheet_distribution,\n                            vlm_vortexsheet_sigma_tbv;\n                            vehicle=nothing\n                            )\n\nCalculates the aerodynamic force at each element of a VLM system using its current Gamma solution and the Kutta-Joukowski theorem. It saves the force as the field vlm_system.sol[\"Ftot\"]\n\nThis force calculated through the Kutta-Joukowski theorem uses the freestream velocity, kinematic velocity, and wake-induced velocity on each bound vortex. See Alvarez' dissertation, Sec. 6.3.3.\n\nARGUMENTS\n\nvlm_vortexsheet::Bool   : If true, the bound vorticity is approximated with                               and actuator surface model through a vortex                               sheet. If false, it is approximated with an                               actuator line model with horseshoe vortex                               filaments.\nvlm_vortexsheet_overlap::Bool       : Target core overlap between particles                               representing the vortex sheet (if                               vlm_vortexsheet=true).\nvlm_vortexsheet_distribution::Function : Vorticity distribution in vortex                               sheet (see g_uniform, g_linear, and                               g_pressure).\nKJforce_type::String    : If vlm_vortexsheet=true, it specifies how to                               weight the force of each particle in the vortex                               sheet. If KJforce_type==\"averaged\", the KJ                               force is a chordwise average of the force                               experienced by the particles. If                               KJforce_type==\"weighted\", the KJ force                               is chordwise weighted by the strength of each                               particle. If KJforce_type==\"regular\", the                               vortex sheet is ignored, and the KJ force                               is calculated from the velocity induced                               at midpoint between the horseshoe filaments.\nvehicle::VLMVehicle     : If vlm_vortexsheet=true, it is expected that the                               vehicle object is passed through this argument.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_aerodynamicforce_parasiticdrag","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_aerodynamicforce_parasiticdrag","text":"generate_aerodynamicforce_parasiticdrag(polar_file::String;\n                                                read_path=FLOWUnsteady.default_database*\"/airfoils\",\n                                                calc_cd_from_cl=false,\n                                                add_skinfriction=true,\n                                                Mach=nothing)\n\nCalculates the parasitic drag along the wing using a lookup airfoil table. It adds this force to the field vlm_system.sol[\"Ftot\"].\n\nThe lookup table is read from the file polar_file under the directory read_path. The parasitic drag includes form drag, skin friction, and wave drag, assuming that each of these components are included in the lookup polar. polar_file can be any polar file downloaded from airfoiltools.com.\n\nTo ignore skin friction drag, use add_skinfriction=false.\n\nThe drag will be calculated from the local effective angle of attack, unless calc_cd_from_cl=true is used, which then will be calculated from the local lift coefficient given by the circulation distribution. cd from cl tends to be more accurate than from AOA, but the method might fail to correlate cd and cl depending on how noise the polar data is.\n\nIf Mach != nothing, it will use a Prandtl-Glauert correction to pre-correct the lookup cl. This will have no effects if calc_cd_from_cl=false.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.calc_aerodynamicforce_unsteady","page":"(4) Monitors Definitions","title":"FLOWUnsteady.calc_aerodynamicforce_unsteady","text":"calc_aerodynamicforce_unsteady(vlm_system::Union{vlm.Wing, vlm.WingSystem},\n                            prev_vlm_system, pfield, Vinf, dt, rho; t=0.0,\n                            per_unit_span=false, spandir=[0, 1, 0],\n                            include_trailingboundvortex=false,\n                            add_to_Ftot=false\n                            )\n\nForce from unsteady circulation.\n\nThis force tends to add a lot of numerical noise, which in most cases ends up cancelling out when the loading is time-averaged. Hence, add_to_Ftot=false will calculate the unsteady loading and save it under the field Funs-vector, but it will not be added to the Ftot vector that is used to calculate the wing's overall aerodynamic force.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#waketreatmentapi","page":"(4) Monitors Definitions","title":"Wake Treatment","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Since the full set of state variables is passed to extra_runtime_function, this function can also be used to alter the simulation on the fly. In some circumstances it is desirable to be able to remove or modify particles, which process we call \"wake treatment.\" Wake treatment is often used to reduce computational cost (for instance, by removing particle in regions of the flow that are not of interest), and it can also be used to force numerical stability (for instance, by removing or clipping particles with vortex strengths that grow beyond certain threshold).","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"These wake treatment methods can be added into the pipeline of extra_runtime_function as follows:","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"import FLOWUnsteady as uns\n\n# Define monitors\nmonitor_states = uns.generate_monitor_statevariables()\nmonitor_enstrophy = uns.generate_monitor_enstrophy()\n\n# Monitor pipeline\nmonitors = uns.concatenate(monitor_states, monitor_enstrophy)\n\n# Define wake treatment\nwake_treatment = uns.remove_particles_sphere(1.0, 1; Xoff=zeros(3))\n\n# Extra runtime function pipeline\nextra_runtime_function = uns.concatenate(monitors, wake_treatment)\n","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Then pass this pipeline to the simulation as","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"uns.run_simulation(sim, nsteps; extra_runtime_function=extra_runtime_function, ...)","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Below we list a few generator functions that return common wake treatment methods.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"FLOWUnsteady.remove_particles_sphere\nFLOWUnsteady.remove_particles_box\nFLOWUnsteady.remove_particles_lowstrength\nFLOWUnsteady.remove_particles_strength\nFLOWUnsteady.remove_particles_sigma","category":"page"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_sphere","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_sphere","text":"remove_particles_sphere(Rsphere2, step::Int; Xoff::Vector=zeros(3))\n\nReturns an extra_runtime_function that every step steps removes all particles that are outside of a sphere of radius sqrt(Rsphere2) centered around the vehicle or with an offset Xoff from the center of the vehicle.\n\nUse this wake treatment to avoid unnecesary computation by removing particles that have gone beyond the region of interest.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_box","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_box","text":"remove_particles_box(Pmin::Vector, Pmax::Vector, step::Int)\n\nReturns an extra_runtime_function that every step steps removes all particles that are outside of a box of minimum and maximum vertices Pmin and Pmax.\n\nUse this wake treatment to avoid unnecesary computation by removing particles that have gone beyond the region of interest.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_lowstrength","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_lowstrength","text":"remove_particles_lowstrength(critGamma2, step)\n\nReturns an extra_runtime_function that removes all particles with a vortex strength magnitude that is smaller than sqrt(critGamma2). Use this wake treatment to avoid unnecesary computation by removing particles that have negligibly-low strength.\n\nstep indicates every how many steps to remove particles.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_strength","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_strength","text":"remove_particles_strength(minGamma2, maxGamma2; every_nsteps=1)\n\nReturns an extra_runtime_function that removes all particles with a vortex strength magnitude that is larger than sqrt(maxGamma2) or smaller than sqrt(minGamma2). Use every_nsteps to indicate every how many steps to remove particles.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_sigma","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_sigma","text":"remove_particles_sigma(minsigma, maxsigma; every_nsteps=1)\n\nReturns an extra_runtime_function that removes all particles with a smoothing radius that is larger than maxsigma or smaller than minsigma. Use every_nsteps to indicate every how many steps to remove particles.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-relaxation/#Relaxation-Scheme","page":"Relaxation Scheme","title":"Relaxation Scheme","text":"","category":"section"},{"location":"api/flowvpm-relaxation/","page":"Relaxation Scheme","title":"Relaxation Scheme","text":"FLOWUnsteady.vpm.FMM\nFLOWUnsteady.vpm.Relaxation\nFLOWUnsteady.vpm.relax_pedrizzetti\nFLOWUnsteady.vpm.relax_correctedpedrizzetti","category":"page"},{"location":"api/flowvpm-relaxation/#FLOWVPM.FMM","page":"Relaxation Scheme","title":"FLOWVPM.FMM","text":"`FMM(; p::Int=4, ncrit::Int=50, theta::Real=0.4, phi::Real=0.3)`\n\nParameters for FMM solver.\n\nArguments\n\np       : Order of multipole expansion (number of terms).\nncrit   : Maximum number of particles per leaf.\ntheta   : Neighborhood criterion. This criterion defines the distance               where the far field starts. The criterion is that if θ*r < R1+R2               the interaction between two cells is resolved through P2P, where               r is the distance between cell centers, and R1 and R2 are each               cell radius. This means that at θ=1, P2P is done only on cells               that have overlap; at θ=0.5, P2P is done on cells that their               distance is less than double R1+R2; at θ=0.25, P2P is done on               cells that their distance is less than four times R1+R2; at               θ=0, P2P is done on cells all cells.\nphi     : Regularizing neighborhood criterion. This criterion avoid               approximating interactions with the singular-FMM between               regularized particles that are sufficiently close to each other               across cell boundaries. Used together with the θ-criterion, P2P               is performed between two cells if φ < σ/dx, where σ is the               average smoothing radius in between all particles in both cells,               and dx is the distance between cell boundaries               ( dx = r-(R1+R2) ). This means that at φ = 1, P2P is done on               cells with boundaries closer than the average smoothing radius;               at φ = 0.5, P2P is done on cells closer than two times the               smoothing radius; at φ = 0.25, P2P is done on cells closer than               four times the smoothing radius.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-relaxation/#FLOWVPM.Relaxation","page":"Relaxation Scheme","title":"FLOWVPM.Relaxation","text":"`Relaxation(relax, nsteps_relax, rlxf)`\n\nDefines a relaxation method implemented in the function relax(rlxf::Real, p::Particle) where rlxf is the relaxation factor between 0 and 1, with 0 == no relaxation, and 1 == full relaxation. The simulation is relaxed every nsteps_relax steps.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-relaxation/#FLOWVPM.relax_pedrizzetti","page":"Relaxation Scheme","title":"FLOWVPM.relax_pedrizzetti","text":"`relax_Pedrizzetti(rlxf::Real, p::Particle)`\n\nRelaxation scheme where the vortex strength is aligned with the local vorticity.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-relaxation/#FLOWVPM.relax_correctedpedrizzetti","page":"Relaxation Scheme","title":"FLOWVPM.relax_correctedpedrizzetti","text":"`relax_correctedPedrizzetti(rlxf::Real, p::Particle)`\n\nRelaxation scheme where the vortex strength is aligned with the local vorticity. This version fixes the error in Pedrizzetti's relaxation that made the strength to continually decrease over time. See notebook 20200921 for derivation.\n\n\n\n\n\n","category":"function"},{"location":"examples/wing-aoasweep/#AOA-Sweep","page":"AOA Sweep","title":"AOA Sweep","text":"","category":"section"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"Using the same vehicle, maneuver, and simulation defined in the     previous section, we now run a sweep of the angle of attack.","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"#=##############################################################################\n# DESCRIPTION\n    AOA sweep on 45° swept-back wing\n=###############################################################################\nimport FLOWUnsteady: cross, dot, norm, plt, @L_str\n\nAOAs        = [0, 2.1, 4.2, 6.3, 8.4, 10.5, 12] # (deg) angles of attack\nXac         = [0.25*b/ar, 0, 0]             # (m) aerodynamic center for moment calculation\n\n# Results are stored in these arrays\nCLs, CDs    = [], []                        # Lift and drag at each angle of attack\nrolls, pitchs, yaws = [], [], []            # Rolling, pitching, and yawing moment\n\nls, ds      = [], []                        # Load and drag distributions\nspanposs    = []                            # Spanwise positions for load distributions\n\n\n# ----------------- AOA SWEEP --------------------------------------------------\nfor AOA in AOAs\n\n    println(\"\\n\\n Running AOA = $(AOA) deg\")\n\n    # ------------- RUN SIMULATION ----------------\n\n    # Freestream function\n    Vinf(X, t) = magVinf*[cosd(AOA), 0.0, sind(AOA)]\n\n    # Define wing monitor with new reference freestream direction\n    Shat = [0, 1, 0]                            # Spanwise direction\n    Dhat = [cosd(AOA), 0.0, sind(AOA)]          # Direction of drag\n    Lhat = cross(Dhat, Shat)                    # Direction of lift\n\n    # Generate wing monitor\n    monitor = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                                rho, qinf, nsteps;\n                                                calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                                L_dir=Lhat,\n                                                D_dir=Dhat,\n                                                save_path=nothing,\n                                                disp_plot=false\n                                                )\n\n    # Run simulation\n    pfield = uns.run_simulation(simulation, nsteps;\n                                    # SIMULATION OPTIONS\n                                    Vinf=Vinf,\n                                    rho=rho,\n                                    # SOLVERS OPTIONS\n                                    p_per_step=p_per_step,\n                                    max_particles=max_particles,\n                                    sigma_vlm_solver=sigma_vlm_solver,\n                                    sigma_vlm_surf=sigma_vlm_surf,\n                                    sigma_rotor_surf=sigma_vlm_surf,\n                                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                                    shed_starting=shed_starting,\n                                    extra_runtime_function=monitor,\n                                    # OUTPUT OPTIONS\n                                    save_path=nothing,\n                                    v_lvl=1, verbose_nsteps=60\n                                    )\n\n    # ------------- POST-PROCESSING ---------------\n\n    # Integrate total lift and drag\n    L = sum(wing.sol[\"L\"])\n    D = sum(wing.sol[\"D\"])\n\n    # Lift and drag coefficients\n    CL = norm(L) / (qinf*b^2/ar)\n    CD = norm(D) / (qinf*b^2/ar)\n\n    # Control point of each element\n    Xs = [vlm.getControlPoint(wing, i) for i in 1:vlm.get_m(wing)]\n\n    # Force of each element\n    Fs = wing.sol[\"Ftot\"]\n\n    # Integrate the total moment with respect to aerodynamic center\n    M = sum( cross(X - Xac, F) for (X, F) in zip(Xs, Fs) )\n\n    # Integrated moment decomposed into rolling, pitching, and yawing moments\n    lhat = Dhat                   # Rolling direction\n    mhat = Shat                   # Pitching direction\n    nhat = Lhat                   # Yawing direction\n\n    roll = dot(M, lhat)\n    pitch = dot(M, mhat)\n    yaw = dot(M, nhat)\n\n    # Sectional loading (in vector form) at each control point\n    fs = wing.sol[\"ftot\"]\n\n    # Decompose vectors into lift and drag distribution\n    l = [ dot(f, Lhat) for f in fs ]\n    d = [ dot(f, Dhat) for f in fs ]\n\n    # Span position of each control point\n    spanpos = [ dot(X, Shat) / (b/2) for X in Xs ]\n\n    # Store results\n    push!(CLs, CL)\n    push!(CDs, CD)\n\n    push!(rolls, roll)\n    push!(pitchs, pitch)\n    push!(yaws, yaw)\n\n    push!(spanposs, spanpos)\n    push!(ls, l)\n    push!(ds, d)\n\nend\n\n","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~15 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (n and steps) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"Check examples/wing/wing_aoasweep.jl to see how to postprocess and plot the results as shown below.","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<center>\n    <br><b>Spanwise loading distribution</b>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-sweep-loading.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Vehicle lift and drag</b>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-sweep-CLCD.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Pitching moment</b><br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-sweep-Cm.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-fdom/#rotorfdom","page":"Fluid Domain","title":"Fluid Domain","text":"","category":"section"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-fdom00.jpeg\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"<br>","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"The full fluid domain can be computed in a postprocessing step from the particle field. This is possible because the particle field is a radial basis function that constructs the vorticity field, and the velocity field can be recovered from vorticity through the Biot-Savart law.","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"Here we show how to use uns.computefluiddomain to read a simulation and process it to generate its fluid domain.","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"#=##############################################################################\n    Computes the fluid domain of DJI 9443 simulation using a volumetric domain.\n    This is done probing the velocity and vorticity that the particle field\n    induces at each node of a Cartesian grids.\n\n    NOTE: The fluid domain generated here does not include the freestream\n            velocity, which needs to be added manually inside ParaView (if any).\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWUnsteady: vpm, gt, dot, norm\n\n# --------------- INPUTS AND OUTPUTS -------------------------------------------\n# INPUT OPTIONS\nsimulation_name = \"rotorhover-example-midhigh00\"               # Simulation to read\nread_path       = \"/home/edoalvar/simulationdata202330/\"*simulation_name # Where to read simulation from\n\npfield_prefix   = \"singlerotor_pfield\"      # Prefix of particle field files to read\nstaticpfield_prefix = \"singlerotor_staticpfield\" # Prefix of static particle field files to read\n\nnums            = [719]              # Time steps to process\n\n# OUTPUT OPTIONS\nsave_path       = joinpath(read_path, \"..\", simulation_name*\"-fdom\")  # Where to save fluid domain\noutput_prefix   = \"singlerotor\"             # Prefix of output files\nprompt          = true                      # Whether to prompt the user\nverbose         = true                      # Enable verbose\nv_lvl           = 0                         # Verbose indentation level\n\n\n# -------------- PARAMETERS ----------------------------------------------------\n# Simulation information\nR               = 0.12                      # (m) rotor radius\nAOA             = 0.0                       # (deg) angle of attack or incidence angle\n\n# Grid\nL               = R                         # (m) reference length\ndx, dy, dz      = L/50, L/50, L/50          # (m) cell size in each direction\nPmin            = L*[-0.50, -1.25, -1.25]   # (m) minimum bounds\nPmax            = L*[ 2.00,  1.25,  1.25]   # (m) maximum bounds\nNDIVS           = ceil.(Int, (Pmax .- Pmin)./[dx, dy, dz])  # Number of cells in each direction\nnnodes          = prod(NDIVS .+ 1)          # Total number of nodes\n\nOaxis           = gt.rotation_matrix2(0, 0, AOA)    # Orientation of grid\n\n# VPM settings\nmaxparticles    = Int(1.0e6 + nnodes)         # Maximum number of particles\nfmm             = vpm.FMM(; p=4, ncrit=50, theta=0.4, phi=0.3) # FMM parameters (decrease phi to reduce FMM noise)\nscale_sigma     = 1.00                      # Shrink smoothing radii by this factor\nf_sigma         = 0.5                       # Smoothing of node particles as sigma = f_sigma*meansigma\n\nmaxsigma        = L/10                      # Particles larger than this get shrunk to this size (this helps speed up computation)\nmaxmagGamma     = Inf                       # Any vortex strengths larger than this get clipped to this value\n\ninclude_staticparticles = true              # Whether to include the static particles embedded in the solid surfaces\n\nother_file_prefs = include_staticparticles ? [staticpfield_prefix] : []\nother_read_paths = [read_path for i in 1:length(other_file_prefs)]\n\nif verbose\n    println(\"\\t\"^(v_lvl)*\"Fluid domain grid\")\n    println(\"\\t\"^(v_lvl)*\"NDIVS =\\t$(NDIVS)\")\n    println(\"\\t\"^(v_lvl)*\"Number of nodes =\\t$(nnodes)\")\nend\n\n# --------------- PROCESSING SETUP ---------------------------------------------\nif verbose\n    println(\"\\t\"^(v_lvl)*\"Getting ready to process $(read_path)\")\n    println(\"\\t\"^(v_lvl)*\"Results will be saved under $(save_path)\")\nend\n\n# Create save path\nif save_path != read_path\n    gt.create_path(save_path, prompt)\nend\n\n\n# Generate function to process the field clipping particle sizes\npreprocessing_pfield = uns.generate_preprocessing_fluiddomain_pfield(maxsigma, maxmagGamma;\n                                                                        verbose=verbose, v_lvl=v_lvl+1)\n\n# --------------- PROCESS SIMULATION -------------------------------------------\n\nnthreads        = 1                         # Total number of threads\nnthread         = 1                         # Number of this thread\ndnum = floor(Int, length(nums)/nthreads)    # Number of time steps per thread\nthreaded_nums = [view(nums, dnum*i+1:(i<nthreads-1 ? dnum*(i+1) : length(nums))) for i in 0:nthreads-1]\n\nfor these_nums in threaded_nums[nthread:nthread]\n\n     uns.computefluiddomain(    Pmin, Pmax, NDIVS,\n                                maxparticles,\n                                these_nums, read_path, pfield_prefix;\n                                Oaxis=Oaxis,\n                                fmm=fmm,\n                                f_sigma=f_sigma,\n                                save_path=save_path,\n                                file_pref=output_prefix, grid_names=[\"_fdom\"],\n                                other_file_prefs=other_file_prefs,\n                                other_read_paths=other_read_paths,\n                                userfunction_pfield=preprocessing_pfield,\n                                verbose=verbose, v_lvl=v_lvl)\n\nend","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~1 minute on a Dell Precision 7760 laptop.\n</i></span>\n\n<br><br>","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"<center>\n    <b>Mid-High Fidelity</b>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-midhigh00-wvol00.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-midhigh00-wy00.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-midhigh00-ux00.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n    <br><br><br>\n    <b>High Fidelity</b>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-wvol00.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-wy00.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-ux00.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"info: ParaView Visualization\nThe .pvsm files visualizing the fluid domain as shown above are available in the following linksHigh fidelity: LINK\nMid-high fidelity: LINK(right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"api/flowunsteady-vehicle-components/#Generating-components","page":"Generating components","title":"Generating components","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/#Rotor","page":"Generating components","title":"Rotor","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWunsteady uses a database of airfoil and rotor geometries to automate the generation of rotors. A prepopulated database is found in the directory under FLOWUnsteady.default_database. Alternatively, users can define their own database with custom rotors and airfoils.","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"The following slides describe the structure of the database, using the DJI 9443 rotor as an example:","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"<div style=\"position:relative;padding-top:60%;\">\n<iframe style=\"position:absolute;left:0;top:0;height:100%;width:100%;\" src=\"https://docs.google.com/presentation/d/e/2PACX-1vRsYbuuMFQdc05NRrQ3Db0RT4XKKoxEYDiUi0MpW58W6A-pp0sDHQI9mVqNFagPtQ/embed?start=true&loop=true&delayms=3000\" frameborder=\"0\" width=\"100%\" height=\"100%\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n</div>","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"Rotors can then be generated calling any of following functions:","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWUnsteady.generate_rotor(::String)\nFLOWUnsteady.generate_rotor(::Real, ::Real, ::Int, ::String)\nFLOWUnsteady.generate_rotor(::Real, ::Real, ::Int, ::Array{Float64,2},\n                            ::Array{Float64,2}, ::Array{Float64,2},\n                            ::Array{Float64,2},\n                            ::Array{Tuple{Float64,Array{Float64, 2},String},1})\nFLOWUnsteady.vlm.rotate","category":"page"},{"location":"api/flowunsteady-vehicle-components/#FLOWUnsteady.generate_rotor-Tuple{String}","page":"Generating components","title":"FLOWUnsteady.generate_rotor","text":"generate_rotor(rotor_file::String;\n                    data_path=FLOWUnsteady.default_database, optargs...)\n\nGenerates a FLOWVLM.Rotor reading the full rotor geometry from the rotor file rotor_file found in the database data_path.\n\n\n\n\n\n","category":"method"},{"location":"api/flowunsteady-vehicle-components/#FLOWUnsteady.generate_rotor-Tuple{Real, Real, Int64, String}","page":"Generating components","title":"FLOWUnsteady.generate_rotor","text":"generate_rotor(Rtip, Rhub, B, blade_file::String;\n                    data_path=FLOWUnsteady.default_database, optargs...)\n\nGenerates a FLOWVLM.Rotor reading the blade geometry from the blade file blade_file found in the database data_path.\n\n\n\n\n\n","category":"method"},{"location":"api/flowunsteady-vehicle-components/#FLOWUnsteady.generate_rotor-Tuple{Real, Real, Int64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Tuple{Float64, Matrix{Float64}, String}}}","page":"Generating components","title":"FLOWUnsteady.generate_rotor","text":"generate_rotor(Rtip, Rhub, B,\n                    chorddist, twistdist, sweepdist, heightdist,\n                    airfoil_contours;\n\n                    # MORE ROTOR PARAMETERS\n                    pitch=0.0,\n                    CW=true,\n\n                    # DISCRETIZATION SETTINGS\n                    n=10, blade_r=1.0,\n                    rediscretize_airfoils=true,\n                    rfl_n_lower=15, rfl_n_upper=15,\n                    spline_k=5, spline_s=0.001, spline_bc=\"extrapolate\",\n\n                    # AIRFOIL PROCESSING\n                    data_path=FLOWUnsteady.default_database,\n                    read_polar=vlm.ap.read_polar,\n                    xfoil=false,\n                    alphas=[i for i in -20:1.0:20], ncrit=9,\n                    ReD=5e5, altReD=nothing, Matip=0.0,\n\n                    # OUTPUT OPTIONS\n                    verbose=false, verbose_xfoil=false, v_lvl=1,\n                    plot_disc=true, save_polars=nothing)\n\nGenerates a FLOWVLM.Rotor from direct inputs.\n\nARGUMENTS\n\nRtip::Real      :   (m) rotor radius (from centerline to blade tip)\nRhub::Real      :   (m) hub radius (from centerline to blade root)\nB::Int          :   Number of blades\nchorddist::Matrix   : Chord distribution (chorddist[:, 1] = r/R, chorddist[:, 2] = c/R\ntwistdist::Matrix   : Twist distribution (twistdist[:, 1] = r/R, twistdist[:, 2] = degs\nsweepdist::Matrix   : LE sweep distribution (sweepdist[:, 1] = r/R, sweepdist[:, 2] = x/R\nheightdist::Matrix  : LE height distribution (heightdist[:, 1] = r/R, heightdist[:, 2] = z/R\nairfoil_contours::Array{ Tuple{Float64, Array{Float64, 2}, String} }    :                           Airfoil contours along the span. It must follow the                           pattern (pos, contour, polarfile) = airfoil_contours[i],                           where pos = (r-Rhub)/(Rtip-Rhub) is the spanwise                           position (with root=0, tip=1), contour is the                           airfoil profile (contour[:, 1] = x/c, contour[:, 2] = y/c),                           and polarfile is any file from                           airfoiltools.com with                           the airfoil lookup table (airfoil polar).\n\nThe function allows airfoil_contours::Array{ Tuple{Float64, String, String} }, following the pattern (pos, contourfile, polarfile) = airfoil_contours[i] where contourfile is a CSV file with columns x/c and y/c.\n\nKEYWORD ARGUMENTS\n\nExtra rotor parameters\n\npitch::Real         :   (deg) rotor collective pitch\nCW::Bool            :   Whether the rotor rotates in the clockwise (true)                           or counter-clockwise (false)\n\nDiscretization\n\nn::Int              :   Number of blade elements per blade.\nr::Real             :   Spacing between elements at the tip, divided by                           the spacing between elements at the root.\nspline_k::Int, spline_s::Real, spline_bc::String : To discretize the                           blade, the blade distributions are splined and                           re-discretize into n elements. These splines                           are done through the Dierckx package,                           with spline_k the order of the spline, spline_s                           the smoothing parameter, and spline_bc the                           boundary condition.\nrediscretize_airfoils   : If true, it will spline the airfoil contours and                               re-discretize them. It will discretize the lower                               side of the contour into rfl_n_lower panels,                               and the upper side into rfl_n_upper panels.                               This is necessary unless all the airfoil                               contours already have the same number of points.\n\nAirfoil processing\n\ndata_path::String   :   Path to database where to read the airfoil polars                           from.\nread_polar::Function :  Function used for parsing the airfoil files. Use                           vlm.ap.read_polar for files that are direct                           outputs from XFOIL. Use vlm.ap.read_polar2 for CSV                           files.\nxfoil::Bool         :   If true, the polar files will be ignored and XFOIL                           will be used to generate the polars instead. This                           will be done sweeping AOA as in alphas                           (in degrees) and ncrit for inflow turbulence                           parameter.\nReD::Real, Matip::Real, altReD::Tuple{Real, Real, Real}\n\nReD is the diameter Reynolds number based on rotational speed calculated as ReD = (omega*R)*(2*R)/nu, and Matip is the rotational+freestream Mach number at the tip. These number will be used for running XFOIL to compute airfoil polars, and will be ignored if airfoil polars are prescribed.\n\nGive it altReD = (RPM, J, nu), and it will calculate the chord-based Reynolds accounting for the effective velocity at every station, ignoring ReD (this is more accurate, but not needed).\n\nNOTE: If Matip is different than zero while running XFOIL, you must deactive compressibility corrections in run_simulation by using sound_spd=nothing. Otherwise, compressibility effects will be double accounted for.\n\nOutputs\n\nverbose::Bool       :   Whether to verbose while generating the rotor\nverbose_xfoil::Bool :   Whether to verbose while running XFOIL\nv_lvl::Int          :   Indentation level for printing the verbose\nplot_disc           :   If true, it will plot the discretization process                           of the blade, which is useful for verification and                           debugging. It will also plot the airfoil polars.\nsave_polars::String :   Give it a path to a directory and it will save the                           polars plot in that directory\n\n\n\n\n\n","category":"method"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.rotate","page":"Generating components","title":"FLOWVLM.rotate","text":"rotate(rotor::Rotor, degs::Real)\n\nRotates the rotor by degs degrees in the direction of rotation (rotor.CW).\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#VLM-Wing","page":"Generating components","title":"VLM Wing","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWUnsteady.vlm.simpleWing\nFLOWUnsteady.vlm.complexWing","category":"page"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.simpleWing","page":"Generating components","title":"FLOWVLM.simpleWing","text":"simpleWing(b, ar, tr, twist, lambda, gamma; twist_tip=twist, n=20, r=2.0)\n\nGenerates a simple wing with constant twist, sweep, dihedral, and taper ratio.\n\nArguments\n\nb       :   (float) span\nar      :   (float) aspect ratio (span / tip chord)\ntr      :   (float) taper ratio (tip chord / root chord)\ntwist   :   (float) twist of the root in degrees\nlambda  :   (float) sweep in degrees\ngamma   :   (float) dihedral in degrees\ntwist_tip : (float) twist of the tip (if different than root)\nn       :   (int)   number of horseshoes per semi-span\nr       :   (float) horseshoes' expansion ratio\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.complexWing","page":"Generating components","title":"FLOWVLM.complexWing","text":"complexWing(b, AR, tr, n, pos, twist, sweep, dihed; symmetric=true)\n\nGenerates a wing with an abritrary distribution of twist, sweep, dihedral, and chord length.\n\nArguments\n\nb::Float64          : Span\nAR::Float64         : Reference aspect ratio (span / tip chord)\nn::Int64            : Number of horseshoes per semi-span\npos::Array{Float64,1}   : Position of stations along the semi-span\nclen::Array{Float64,1}  : Chord length at each station (normalized by tip chord)\ntwist::Array{Float64,1} : (deg) twist at each station\nsweep::Array{Float64,1} : (deg) sweep between each station\ndihed::Array{Float64,1} : (deg) dihedral between each station\n\nOptional Arguments\n\nsymmetric::Bool=true    : If false, generates only a half-span\nchordalign::Float64=0.0 : Indicate position along chord length to align                             chords. Give it 0 for alignment about leading                             edge, 0.25 for alignment about quarter chord,                             and 1.0 for alignment about trailing edge.\n\nExample\n\n# Wing dimensions\nb = 1.0                     # (m) span\nAR = 12.0                   # Span over tip chord\nn = 50                      # Horseshoes per semi-span\n\n# Define chord, twist, sweep, and dihedral distributions\npos = [0, 0.25, 0.75, 1]    # Position of stations along semi-span\nclen = [2.0, 1.5, 1.5, 1]   # Normalized chord length at each station\ntwist = [0.0, 0.0, -2.0, -4.0]    # (deg) twist at each station\nsweep = [10.0, 15.0, 35.0]  # (deg) sweep between stations\ndihed = [2.0, 5.0, 7.5]     # (deg) dihedral between stations\n\n# Generate the wing\nwing = vlm.complexWing(b, AR, n, pos, clen, twist, sweep, dihed)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM-Systems","page":"Generating components","title":"FLOWVLM Systems","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWUnsteady.vlm.WingSystem\n\nFLOWUnsteady.vlm.addwing\nFLOWUnsteady.vlm.get_wing\nFLOWUnsteady.vlm.setcoordsystem\nFLOWUnsteady.vlm.get_m\nFLOWUnsteady.vlm.get_mBlade","category":"page"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.WingSystem","page":"Generating components","title":"FLOWVLM.WingSystem","text":"WingSystem(wings::Array{Union{Wing, WingSystem}}, wing_names::Array{String})\n\nInitiates a system of wings. All methods applicable to a Wing object are applicable to a WingSystem. When solved, it will calculate the interaction between wings.\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.addwing","page":"Generating components","title":"FLOWVLM.addwing","text":"addwing(self::WingSystem, wing_name::String, wing::Union{Wing, Rotor})\n\nAdds a wing (or rotor) to the system. The local reference frame of the wing then is then in relation to the local reference frame of the System.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.get_wing","page":"Generating components","title":"FLOWVLM.get_wing","text":"get_wing(self::WingSystem, wing_name::String)\n\nReturns the wing of name wing_name.\n\n\n\n\n\nget_wing(self::WingSystem, wing_i::Int)\n\nReturns the i-th wing.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.setcoordsystem","page":"Generating components","title":"FLOWVLM.setcoordsystem","text":"setcoordsystem(wing::Wing, O::Vector, Oaxis::Matrix)\n\nRedefines the local coordinate system of the wing, where O is the new origin and Oaxis is the matrix of unit vectors\n\n\n\n\n\nsetcoordsystem(system::WingSystem, O::Vector, Oaxis::Matrix; wings=String[])\n\nRedefines the local coordinate system of the system, where O is the new origin and Oaxis is the matrix of unit vectors. It transforms the coordinates of all wings in the system accordingly.\n\nTo change the local coordinate system of a specific wing relative to the system's coordinate system, give the name of the wing in an array under argument wings.\n\n\n\n\n\nsetcoordsystem(rotor::Rotor, O::Vector, Oaxis::Matrix; user=false)\n\nRedefines the local coordinate system of the rotor, where O is the new origin and Oaxis is the matrix of unit vectors. If the user is calling this function, give user=true, otherwise it will not do the automatic translation to blade coordinate system.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.get_m","page":"Generating components","title":"FLOWVLM.get_m","text":"get_m(wing::Wing)\n\nReturns the number of horseshoes in the wing\n\n\n\n\n\nget_m(system::WingSystem)\n\nReturns the total number of horseshoes in the system\n\n\n\n\n\nget_m(rotor::Rotor)\n\nReturns the total number of horseshoes in the rotor\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.get_mBlade","page":"Generating components","title":"FLOWVLM.get_mBlade","text":"get_mBlade(rotor::Rotor)\n\nReturns the number of horseshoes per blade\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-viscous/#Viscous-Scheme","page":"Viscous Scheme","title":"Viscous Scheme","text":"","category":"section"},{"location":"api/flowvpm-viscous/","page":"Viscous Scheme","title":"Viscous Scheme","text":"FLOWUnsteady.vpm.ViscousScheme\nFLOWUnsteady.vpm.Inviscid\nFLOWUnsteady.vpm.CoreSpreading\nFLOWUnsteady.vpm.ParticleStrengthExchange\nFLOWUnsteady.vpm.rbf_conjugategradient","category":"page"},{"location":"api/flowvpm-viscous/#FLOWVPM.ViscousScheme","page":"Viscous Scheme","title":"FLOWVPM.ViscousScheme","text":"`ViscousScheme{R}`\n\nType declaring viscous scheme.\n\nImplementations must have the following properties:     * nu::R                   : Kinematic viscosity.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-viscous/#FLOWVPM.rbf_conjugategradient","page":"Viscous Scheme","title":"FLOWVPM.rbf_conjugategradient","text":"Radial basis function interpolation of Gamma using the conjugate gradient method. This method only works on a particle field with uniform smoothing radius sigma.\n\nSee 20180818 notebook and https://en.wikipedia.org/wiki/Conjugategradientmethod#Theresultingalgorithm\n\n\n\n\n\n","category":"function"},{"location":"examples/vahana-vehicle/#vahanavehicle","page":"Vehicle Definition","title":"Vehicle Definition","text":"","category":"section"},{"location":"examples/vahana-vehicle/","page":"Vehicle Definition","title":"Vehicle Definition","text":"In this example we simulate the eVTOL transition maneuver of a tandem tilt-wing multirotor aircraft. The aircraft configuration resembles the Vahana eVTOL aircraft but with tilt and stacked rotors:","category":"page"},{"location":"examples/vahana-vehicle/","page":"Vehicle Definition","title":"Vehicle Definition","text":"<table>\n    <tr>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana2-vehicle00-cropped-small.png\" alt=\"Pic here\" style=\"width:90%;\"/>\n            <br>\n            <center><b>Takeoff and landing</b></center>\n        </td>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana2-vehicle02-cropped-small.png\" alt=\"Pic here\" style=\"width:90%;\"/>\n            <br>\n            <center><b>Cruise</b></center>\n        </td>\n    </tr>\n</table>","category":"page"},{"location":"examples/vahana-vehicle/","page":"Vehicle Definition","title":"Vehicle Definition","text":"Due to the complexity of this simulation, each step of the simulation setup is quite involved. Hence, we have broken down each step into a function that can be call when we setup the simulation.","category":"page"},{"location":"examples/vahana-vehicle/","page":"Vehicle Definition","title":"Vehicle Definition","text":"Below is the function that defines the vehicle for the simulation (uns.UVLMVehicle). Along with defining the vehicle geometry, it also defines two tilting systems (a tilting system is a set of components that tilt together) and three rotor systems (a rotor system is a set of rotors with a common RPM). Later in the next section we will define the control inputs for these tilting and rotor systems.","category":"page"},{"location":"examples/vahana-vehicle/","page":"Vehicle Definition","title":"Vehicle Definition","text":"<table>\n    <tr>\n        <td>\n            <center>\n                <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-tiltingsystems00.png\" alt=\"Pic here\" style=\"width:70%;\"/>\n            </center>\n        </td>\n        <td>\n            <center>\n                <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//vahana-rotorsystems00.png\" alt=\"Pic here\" style=\"width:70%;\"/>\n            </center>\n        </td>\n    </tr>\n</table>","category":"page"},{"location":"examples/vahana-vehicle/","page":"Vehicle Definition","title":"Vehicle Definition","text":"\"\"\"\n    Generates the geometry of Vahana aircraft\n\"\"\"\nfunction generate_vahana_vehicle(;\n                                    # VEHICLE OPTIONS\n                                    xfoil       = true,             # Whether to run XFOIL\n                                    n_factor::Int = 1,              # Discretization factor\n                                    add_wings   = true,             # Whether to add the wings\n                                    add_rotors  = true,             # Whether to add the rotors\n                                    VehicleType = uns.VLMVehicle,   # Type of vehicle to generate (uns.QVLMVehicle for quasi-steady solver)\n                                    data_path   = uns.def_data_path,# Database path\n                                    # OUTPUT OPTIONS\n                                    run_name    = \"vahana\",\n                                    verbose     = true,\n                                    v_lvl       = 0\n                                    )\n\n    ############################################################################\n    # PARAMETERS\n    ############################################################################\n\n    if verbose; println(\"\\t\"^(v_lvl)*\"Defining parameters...\"); end;\n\n    # ------------ GEOMETRIC PARAMETERS ------------------------------------\n    # Tilt and fixed rotors\n    tiltrotor_file  = \"VahanaTilt.csv\"      # Tilt-rotor file\n    R_w             = 0.75                  # (m) main-wing rotor radius (reference)\n    R_tw            = R_w                   # (m) tandem-wing rotor radius (reference)\n    CW_w            = true                  # Clockwise rotation of main-wing rotor\n    CW_tw           = false                 # Clockwise rotation of tandem-wing rotor\n    nr_w            = 2                     # Number of rotors per side of main wing\n    nr_tw           = 2                     # Number of rotors per side of tandem wing\n    pitch           = 0.0                   # (deg) collective pitch for tiltrotors rotors on main and tandem wings\n    main_outtilt    = 10                    # (deg) Mount main-wing rotors with this out-tilt angle\n    tandem_pitchtilt= 10                    # (deg) Mount tandem-wing rotors with this alternating pitch-tilt angle\n    xoc_offset_main = 0.175                 # Axial distance of main-wing rotors from LE, divided by chord\n    xoc_offset_tandem = 0.10                # Axial distance of tandem-wing rotors from LE, divided by chord\n    soD             = 0.1                   # Tip-to-tip distance of rotors, divided by diameter\n    ReD07           = 1.5e6                 # Assumed diameter-based Reynolds number for all rotors at r/R=0.7\n    ReD             = ReD07/0.7             # Reynolds number at blade tip (for XFOIL)\n    n_rotor         = 7*n_factor            # Number of blade elements per blade\n    r_rotor         = 1/20                  # Geometric expansion between blade elements\n    tilt_read_polar = vlm.ap.read_polar     # What polar reader to use\n\n    # Stacked rotors\n    stackedrotor_file = \"VahanaStacked.csv\" # Stacked-rotor file\n    stacked         = [nr_w, nr_w+1]        # Index of main-wing rotors that will be stacked rotors\n    stckd_xoc_offset= -1.40                 # Axial distance of stacked rotors from LE, divided by chord\n    stckd_zoc_offset= 0.10                  # Height of stacked rotors above wing, divided by chord\n    stckd_zoR_offset= -0.05                 # Stacking distance between stacked rotors, divided by R\n    stckd_corotating= true                  # Co-rotating stacked rotors if true, counter-rotating otherwise\n    stckd_phase     = -10                   # (deg) initial phase difference of stacked rotors (index angle)\n    stckd_pitch_up  = 5.0                   # (deg) collective pitch of upper rotor in stack\n    stckd_pitch_low = stckd_pitch_up + 7.5  # (deg) collective pitch of lower rotor in stack\n    stacked_read_polar = vlm.ap.read_polar2 # What polar reader to use\n\n    # Main wing\n    b_w             = 5.86                  # (m) span\n    AR_w            = 7.4                   # Aspect ratio (b/c_tip)\n    tr_w            = 1.0                   # Taper ratio (c_tip/c_root)\n    twist_r_w       = 14.0                  # (deg) twist at root\n    twist_t_w       = twist_r_w             # (deg) twist at tip\n    lambda_w        = main_outtilt          # (deg) sweep\n    gamma_w         = 5.0                   # (deg) dihedral\n    md_w            = 0.9                   # Length of middle section, divided by span\n    pivot_w         = 1/4                   # Pivot point along chord of tilt-wing\n    n_w             = 24*n_factor           # Number of wing elements per side\n    r_w             = 2.0                   # Geometric expansion of wing elements\n\n    # Main-wing winglets\n    b_wl            = b_w/4                 # (m) span of winglet from top to bottom\n    AR_wl           = 3.0                   # Aspect ratio (b/c_tip)\n    tr_wl           = (b_wl/AR_wl)/(b_w/AR_w/tr_w)  # Taper ratio (c_tip/c_root)\n    twist_r_wl      = 2.5                   # (deg) twist at root\n    twist_t_wl      = 0.0                   # (deg) twist at tip\n    lambda_wl       = 40.0                  # (deg) sweep\n    gamma_wl        = 15.0                  # (deg) dihedral\n    n_wl            = 8*n_factor            # Number of wing elements per side\n    r_wl            = 2.0                   # Geometric expansion of wing elements\n\n    # Tandem wing\n    b_tw            = b_w*1.0               # (m) span\n    AR_tw           = 9.5                   # Aspect ratio (b/c_tip)\n    tr_tw           = 1.0                   # Taper ratio (c_tip/c_root)\n    twist_r_tw      = 14.0                  # (deg) twist at root\n    twist_t_tw      = twist_r_tw            # (deg) twist at tip\n    lambda_tw       = 0.0                   # (deg) sweep\n    gamma_tw        = 0.0                   # (deg) dihedral\n    md_tw           = 0.2                   # Length of middle section, divided by span\n    pivot_tw        = pivot_w               # Pivot point along chord of tilt-wing\n    n_tw            = 2*n_w                 # Number of wing elements per side\n    r_tw            = r_w                   # Geometric expansion of wing elements\n\n    # Fuselage\n    l_f             = 5.86                  # (m) length\n    h_f             = 2.81*2/3              # (m) height\n\n    # ------------ ASSEMBLY PARAMETERS ------------------------------------\n    # Position of wings on fuselage\n    h_pos_w         = 0.90*h_f              # (m) height position of wing\n    h_pos_tw        = 0.15*h_f              # (m) height position of tandem wing\n    l_pos_w         = 0.95*l_f-b_w/AR_w/tr_w# (m) length position of wing\n    l_pos_tw        = 0.05*l_f              # (m) length position of tandem wing\n\n    # Position of rotors along main wing\n    d_rotor_w       = (1+soD)*(2*R_w)       # Distance between rotors\n    y_pos_rotor_w   = Float64[b_w/2 - i*d_rotor_w for i in 0:nr_w-1]    # y-positions\n\n    # Position of rotors along tandem wing\n    d_rotor_tw      = (1+soD)*(2*R_tw)      # Distance between rotors on wing\n    y_pos_rotor_tw  = Float64[b_tw/2 - i*d_rotor_tw for i in 0:nr_tw-1] # y-positions\n\n    init_ori        = 90.0                  # (deg) initial orientation of wings\n    init_ori_rotor  = 0.0                   # (deg) initial orientation of rotors\n    init_ori_stackedrotor = 30.0            # (deg) initial orientation of stacked rotors\n\n\n    ############################################################################\n    # GENERATE COMPONENTS\n    ############################################################################\n\n    if verbose; println(\"\\t\"^(v_lvl)*\"Generating components...\"); end;\n\n    # ------------ ROTORS ------------------------------------------------\n    # Generate base rotors (one for each rotation orientation)\n    if add_rotors\n\n        tiltrotors = vlm.Rotor[]                # Tilt rotors\n\n        if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating first tilt-rotor...\"); end;\n        push!(tiltrotors, uns.generate_rotor(tiltrotor_file; pitch=pitch,\n                                                n=n_rotor, blade_r=r_rotor, CW=!CW_w, ReD=ReD,\n                                                verbose=verbose, v_lvl=v_lvl+2, xfoil=xfoil,\n                                                read_polar=tilt_read_polar,\n                                                data_path=data_path, plot_disc=false))\n\n        if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating second tilt-rotor...\"); end;\n        push!(tiltrotors, uns.generate_rotor(tiltrotor_file; pitch=pitch,\n                                                n=n_rotor, blade_r=r_rotor, CW=CW_w, ReD=ReD,\n                                                verbose=verbose, v_lvl=v_lvl+2, xfoil=xfoil,\n                                                read_polar=tilt_read_polar,\n                                                data_path=data_path, plot_disc=false))\n\n        stackedrotors = vlm.Rotor[]             # Upper rotor in stacked rotors\n\n        if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating first stacked-rotor...\"); end;\n        push!(stackedrotors, uns.generate_rotor(stackedrotor_file; pitch=stckd_pitch_up,\n                                                n=n_rotor, blade_r=r_rotor, CW=!CW_w, ReD=ReD,\n                                                verbose=verbose, v_lvl=v_lvl+2, xfoil=xfoil,\n                                                read_polar=stacked_read_polar,\n                                                data_path=data_path, plot_disc=false))\n\n        if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating second stacked-rotor...\"); end;\n        push!(stackedrotors, uns.generate_rotor(stackedrotor_file; pitch=stckd_pitch_up,\n                                                n=n_rotor, blade_r=r_rotor, CW=CW_w, ReD=ReD,\n                                                verbose=verbose, v_lvl=v_lvl+2, xfoil=xfoil,\n                                                read_polar=stacked_read_polar,\n                                                data_path=data_path, plot_disc=false))\n\n        stackedrotors_low = vlm.Rotor[]         # Lower rotor in stacked rotors\n\n        if stckd_pitch_up != stckd_pitch_low\n\n            if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating first lower-stacked-rotor...\"); end;\n            push!(stackedrotors_low, uns.generate_rotor(stackedrotor_file; pitch=stckd_pitch_low,\n                                                    n=n_rotor, blade_r=r_rotor, CW=!CW_w, ReD=ReD,\n                                                    verbose=verbose, v_lvl=v_lvl+2, xfoil=xfoil,\n                                                    read_polar=stacked_read_polar,\n                                                    data_path=data_path, plot_disc=false))\n\n            if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating second lower-stacked-rotor...\"); end;\n            push!(stackedrotors_low, uns.generate_rotor(stackedrotor_file; pitch=stckd_pitch_low,\n                                                    n=n_rotor, blade_r=r_rotor, CW=CW_w, ReD=ReD,\n                                                    verbose=verbose, v_lvl=v_lvl+2, xfoil=xfoil,\n                                                    read_polar=stacked_read_polar,\n                                                    data_path=data_path, plot_disc=false))\n\n        else\n\n            for rotor in stackedrotors\n                push!(stackedrotors_low, rotor)\n            end\n\n        end\n    end\n\n\n    # ------------ MAIN WING ---------------------------------------------\n    # Generate wing\n    if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating main wing assembly...\"); end;\n\n    # Middle section\n    pos_md_w = [0.0, md_w]\n    clen_md_w = [1/tr_w, md_w + (1/tr_w)*(1-md_w)]\n    twist_md_w = [twist_r_w, twist_r_w + md_w*(twist_t_w-twist_r_w)]\n    wing_md = vlm.complexWing(b_w, AR_w, ceil(Int, md_w*n_w), pos_md_w, clen_md_w, twist_md_w,\n                          lambda_w*ones(1), gamma_w*ones(1);\n                          symmetric=true, chordalign=0.0,\n                          _ign1=true)\n\n    # Left section\n    pos_l_w = [0, -(1-md_w)]   # NOTE: Here we define this wing section from right to left\n    clen_l_w = [1, clen_md_w[end]]\n    twist_l_w = [twist_t_w, twist_md_w[end]]\n    wing_L = vlm.complexWing(b_w, AR_w, ceil(Int, (1-md_w)*n_w/2), pos_l_w, clen_l_w,\n                            twist_l_w, -lambda_w*ones(1), -gamma_w*ones(1);\n                            symmetric=false, chordalign=0.0,\n                            _ign1=true)\n\n    # Right section\n    pos_r_w = [0, (1-md_w)]\n    clen_r_w = [clen_md_w[end], 1]\n    twist_r_w = [twist_md_w[end], twist_t_w]\n    wing_R = vlm.complexWing(b_w, AR_w, ceil(Int, (1-md_w)*n_w/2), pos_r_w, clen_r_w,\n                            twist_r_w, lambda_w*ones(1), gamma_w*ones(1);\n                            symmetric=false, chordalign=0.0,\n                            _ign1=true)\n\n    # Translate right and left sections to position\n    O_w_R = (md_w*b_w/2)*[0, 1, 0]\n    O_w_L = [1 0 0; 0 -1 0; 0 0 1]*O_w_R\n    vlm.setcoordsystem(wing_R, O_w_R, Im)\n    vlm.setcoordsystem(wing_L, O_w_L, Im)\n\n    # Winglets\n    winglet_R = vlm.simpleWing(b_wl, AR_wl, tr_wl, twist_r_wl, lambda_wl, gamma_wl;\n                                          twist_tip=twist_t_wl, n=n_wl, r=r_wl)\n\n    winglet_L = vlm.simpleWing(b_wl, AR_wl, tr_wl, twist_r_wl, lambda_wl, gamma_wl;\n                                          twist_tip=twist_t_wl, n=n_wl, r=r_wl)\n\n    # Translate winglets to position\n    O_wl_R = (b_w/2)*[0, 1, 0]\n    O_wl_R += ((1-md_w)*b_w/2)*[tan(lambda_w*pi/180), 0, tan(gamma_w*pi/180)]\n    O_wl_L = [1 0 0; 0 -1 0; 0 0 1]*O_wl_R\n    Oaxis_wl_R = gt.rotation_matrix(0.0, 0.0, 90.0)\n    Oaxis_wl_L = gt.rotation_matrix(0.0, 0.0, -90.0)\n    vlm.setcoordsystem(winglet_R, O_wl_R, Oaxis_wl_R)\n    vlm.setcoordsystem(winglet_L, O_wl_L, Oaxis_wl_L)\n\n    # Generate main-wing rotors (from right to left)\n    if add_rotors\n\n        if verbose; println(\"\\t\"^(v_lvl+2)*\"Generating main-wing rotors...\"); end;\n\n        O_rotor_w = [                            # Position of each rotor\n                     (ypos - md_w*b_w/2)*[tan(lambda_w*pi/180), 0, -tan(gamma_w*pi/180)] +\n                     ypos*[0, 1, 0] +\n                     [-(i in stacked ? stckd_xoc_offset : xoc_offset_main)*AR_w/b_w, 0, 0] +\n                     [0, 0, (i in stacked ? stckd_zoc_offset*tan(gamma_w*pi/180) : 0)*AR_w/b_w]\n                     for (i, ypos) in enumerate(y_pos_rotor_w)]\n\n        rotors_w = vlm.Rotor[]                  # Rotors get stored in these arrays\n        rotors_w_stacked_up = vlm.Rotor[]\n        rotors_w_stacked_low = vlm.Rotor[]\n\n        for i in 1:2*nr_w\n            right = i<=nr_w                     # Indicates which side of the wing\n\n            copy_rotor = i in stacked ? stackedrotors[1+i%2] : tiltrotors[1+i%2]\n            this_rotor = deepcopy(copy_rotor)   # Alternates rotation orientation\n\n            this_O = O_rotor_w[ right ? i : nr_w-(i-nr_w-1)]  # Chooses position\n            this_O = [1 0 0; 0 (-1)^!right 0; 0 0 1]*this_O   # Places it in correct side\n            this_Oaxis = i in stacked ? gt.rotation_matrix(0.0, 90, 0.0) :\n                                        gt.rotation_matrix((-1)^(i%2==0)*main_outtilt, 0.0, 0.0)\n\n            # Place rotor in position\n            vlm.setcoordsystem(this_rotor, this_O, this_Oaxis; user=true)\n\n            # Rotate rotor to be tip-to-tip with others\n            vlm.rotate(this_rotor, (-1)^(!CW_w) * (i in stacked ? init_ori_stackedrotor : init_ori_rotor))\n\n            # Add the original polars that are not copied with deepcopy\n            this_rotor.airfoils = copy_rotor.airfoils\n            this_rotor._polars = copy_rotor._polars\n            this_rotor._polarroot = copy_rotor._polarroot\n            this_rotor._polartip = copy_rotor._polartip\n\n            if !(i in stacked)\n\n                push!(rotors_w, this_rotor)\n\n            else\n                push!(rotors_w_stacked_up, this_rotor)\n\n                # Generate lower rotor if this is a stacked rotor\n                copy_rotor = stackedrotors_low[ 1+(i+1*!stckd_corotating)%2 ]\n                this_rotor = deepcopy(copy_rotor)\n\n                # Place rotor in position\n                this_O += R_w*[0, 0, stckd_zoR_offset]\n                vlm.setcoordsystem(this_rotor, this_O, this_Oaxis; user=true)\n\n                # Rotate rotor to be tip-to-tip with others\n                vlm.rotate(this_rotor, (-1)^(!CW_w) * (init_ori_stackedrotor+stckd_phase))\n\n                # Add the original polars that are not copied with deepcopy\n                this_rotor.airfoils = copy_rotor.airfoils\n                this_rotor._polars = copy_rotor._polars\n                this_rotor._polarroot = copy_rotor._polarroot\n                this_rotor._polartip = copy_rotor._polartip\n\n                push!(rotors_w_stacked_low, this_rotor)\n            end\n        end\n    end\n\n    # Assemble fixed section of the wing (middle section + stacked rotors)\n    main_wing_fixed = vlm.WingSystem()\n    vlm.addwing(main_wing_fixed, \"WingM\", wing_md)\n\n    if add_rotors\n        for (i, rotor) in enumerate(rotors_w_stacked_up)\n            vlm.addwing(main_wing_fixed, \"StackedRotorUp$i\", rotor)\n        end\n        for (i, rotor) in enumerate(rotors_w_stacked_low)\n            vlm.addwing(main_wing_fixed, \"StackedRotorLow$i\", rotor)\n        end\n    end\n\n    # Assemble wing tip sections\n    main_wing_R = vlm.WingSystem()\n    vlm.addwing(main_wing_R, \"Tip\", wing_R)\n    vlm.addwing(main_wing_R, \"Winglet\", winglet_R)\n\n    main_wing_L = vlm.WingSystem()\n    vlm.addwing(main_wing_L, \"Tip\", wing_L)\n    vlm.addwing(main_wing_L, \"Winglet\", winglet_L)\n\n    # Assemble moving sections of the wing\n    main_wing_moving = vlm.WingSystem()\n    vlm.addwing(main_wing_moving, \"WingR\", main_wing_R)\n    vlm.addwing(main_wing_moving, \"WingL\", main_wing_L)\n\n    if add_rotors\n        for (i, rotor) in enumerate(rotors_w)\n            vlm.addwing(main_wing_moving, \"Rotor$i\", rotor)\n        end\n    end\n\n\n    # Align moving and fixed section with their pivot line\n    x_off_w = pivot_w*b_w/AR_w                  # offset to align with pivot line\n    O_off_w = [-x_off_w, 0.0, 0.0]\n\n    vlm.setcoordsystem(wing_md, O_off_w, Im)\n\n    for vlmwing in main_wing_moving.wings\n        if typeof(vlmwing)==vlm.Rotor\n            vlm.setcoordsystem(vlmwing, vlmwing._wingsystem.O + O_off_w,\n                                        vlmwing._wingsystem.Oaxis; user=false)\n        else\n            vlm.setcoordsystem(vlmwing, vlmwing.O + O_off_w, vlmwing.Oaxis)\n        end\n    end\n\n    # Place tilting sections at main-wing tip\n    O_mv = (md_w*b_w/2)*[tand(lambda_w), 0, tand(gamma_w)]\n\n    # Initial rotation of moving sections\n    Oaxis_wmv = gt.rotation_matrix(0.0, -init_ori, 0.0)\n    vlm.setcoordsystem(main_wing_moving, O_mv, Oaxis_wmv)\n\n    # Assemble main wing\n    main_wing = vlm.WingSystem()\n    vlm.addwing(main_wing, \"Fixed\", main_wing_fixed)\n    vlm.addwing(main_wing, \"Moving\", main_wing_moving)\n\n    # Position of main wing\n    O_w = [l_pos_w + x_off_w, 0, h_pos_w]\n    Oaxis_w = gt.rotation_matrix(0.0, 0.0, 0.0)\n    vlm.setcoordsystem(main_wing, O_w, Oaxis_w)\n\n    # ------------ TANDEM WING -------------------------------------------\n    if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating tandem wing assembly...\"); end;\n\n    # Generate tandem wing\n    twing = vlm.simpleWing(b_tw, AR_tw, tr_tw, twist_r_tw, lambda_tw,\n                                gamma_tw; twist_tip=twist_t_tw, n=n_tw, r=r_tw)\n\n    # Middle section\n    pos_md_tw = [-md_tw, 0.0, md_tw]\n    clen_md_tw = [md_tw + (1/tr_tw)*(1-md_tw), 1/tr_tw, md_tw + (1/tr_tw)*(1-md_tw)]\n    twist_md_tw = [twist_r_tw + md_tw*(twist_t_tw-twist_r_tw),\n                        twist_r_tw, twist_r_tw + md_tw*(twist_t_tw-twist_r_tw)]\n    twing_md = vlm.complexWing(b_tw, AR_tw, ceil(Int, md_tw*n_tw), pos_md_tw,\n                                  clen_md_tw, twist_md_tw,\n                                  lambda_tw*ones(2), gamma_tw*ones(2);\n                                  symmetric=false, chordalign=0.0,\n                                  _ign1=true)\n    # Left section\n    pos_l_tw = [-1, pos_md_tw[1]]\n    clen_l_tw = [1, clen_md_tw[1]]\n    twist_l_tw = [twist_t_tw, twist_md_tw[1]]\n    twing_L = vlm.complexWing(b_tw, AR_tw, ceil(Int, (1-md_tw)*n_tw/2), pos_l_tw,\n                                    clen_l_tw, twist_l_tw,\n                                    lambda_tw*ones(1), gamma_tw*ones(1);\n                                    symmetric=false, chordalign=0.0,\n                                    _ign1=true)\n    # Right section\n    pos_r_tw = [pos_md_tw[end], 1]\n    clen_r_tw = [clen_md_tw[end], 1]\n    twist_r_tw = [twist_md_tw[end], twist_t_tw]\n    twing_R = vlm.complexWing(b_tw, AR_tw, ceil(Int, (1-md_tw)*n_tw/2), pos_r_tw,\n                                    clen_r_tw, twist_r_tw,\n                                    lambda_tw*ones(1), gamma_tw*ones(1);\n                                    symmetric=false, chordalign=0.0,\n                                    _ign1=true)\n\n    ## Generate tandem-wing rotors (from right to left)\n    if add_rotors\n\n        if verbose; println(\"\\t\"^(v_lvl+2)*\"Generating tandem-wing rotors...\"); end;\n\n        O_rotor_tw = [ ypos*[tan(lambda_tw*pi/180), 1, tan(gamma_tw*pi/180)] +\n                        [-xoc_offset_tandem*AR_tw/b_tw, 0, 0]\n                                                  for ypos in y_pos_rotor_tw]\n\n        rotors_tw = vlm.Rotor[]\n\n        for i in 1:2*nr_tw\n            right = i<=nr_tw                        # Indicates which side of the wing\n\n            copy_rotor = tiltrotors[1+(i+(CW_tw!=CW_w))%2]\n            this_rotor = deepcopy(copy_rotor)       # Alternates rotation orientation\n\n            this_O = O_rotor_tw[ right ? i : nr_tw-(i-nr_tw-1)] # Chooses position\n            this_O = [1 0 0; 0 (-1)^!right 0; 0 0 1]*this_O     # Places it in correct side\n            this_Oaxis = gt.rotation_matrix(0, (-1)^(i%2==0)*(-1)^right*tandem_pitchtilt, 0)\n\n            # Place rotor in position\n            vlm.setcoordsystem(this_rotor, this_O, this_Oaxis; user=true)\n\n            # Rotates rotor to be tip-to-tip with others\n            vlm.rotate(this_rotor, (-1)^(!CW_tw) * init_ori_rotor)\n\n            # Add the original polars that are not copied with deepcopy\n            this_rotor.airfoils = copy_rotor.airfoils\n            this_rotor._polars = copy_rotor._polars\n            this_rotor._polarroot = copy_rotor._polarroot\n            this_rotor._polartip = copy_rotor._polartip\n\n            push!(rotors_tw, this_rotor)\n        end\n    end\n\n    # Assemble moving sections of the wing\n    tandem_wing_moving = vlm.WingSystem()\n    vlm.addwing(tandem_wing_moving, \"WingR\", twing_R)\n    vlm.addwing(tandem_wing_moving, \"WingL\", twing_L)\n\n    if add_rotors\n        for (i, rotor) in enumerate(rotors_tw)\n            vlm.addwing(tandem_wing_moving, \"Rotor$i\", rotor)\n        end\n    end\n\n    # Align moving and fixed section with their pivot line\n    x_off_tw = pivot_tw*b_tw/AR_tw                  # offset to align with pivot line\n    O_off_tw = [-x_off_tw, 0.0, 0.0]\n\n    vlm.setcoordsystem(twing_md, O_off_tw, Im)\n\n    for vlmwing in tandem_wing_moving.wings\n        if typeof(vlmwing)==vlm.Rotor\n            vlm.setcoordsystem(vlmwing, vlmwing._wingsystem.O + O_off_tw,\n                                        vlmwing._wingsystem.Oaxis; user=false)\n        else\n            vlm.setcoordsystem(vlmwing, vlmwing.O + O_off_tw, vlmwing.Oaxis)\n        end\n    end\n\n    # Initial rotation of moving sections\n    Oaxis_twmv = gt.rotation_matrix(0.0, -init_ori, 0.0)\n    vlm.setcoordsystem(tandem_wing_moving, zeros(3), Oaxis_twmv)\n\n    # Assemble tandem wing\n    tandem_wing = vlm.WingSystem()\n    vlm.addwing(tandem_wing, \"FixedWing\", twing_md)\n    vlm.addwing(tandem_wing, \"Moving\", tandem_wing_moving)\n\n    # Position of tandem wing\n    O_tw = [l_pos_tw + x_off_tw, 0, h_pos_tw]\n    Oaxis_tw = gt.rotation_matrix(0.0, 0.0, 0.0)\n    vlm.setcoordsystem(tandem_wing, O_tw, Oaxis_tw)\n\n    # ------------ FUSELAGE ----------------------------------------------\n    if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating fuselage...\"); end;\n\n    # Generate fuselage\n    fuselage = generatefuselage_vahana(l_f; ncells=20)\n\n    # All grids get stored here\n    body = gt.MultiGrid(3)\n    gt.addgrid(body, \"Fuselage\", fuselage)\n\n    # Generate pylons of stacked rotors\n    if add_rotors\n        if verbose; println(\"\\t\"^(v_lvl+1)*\"Generating pylons...\"); end;\n\n        pylon_pos = 0.70\n        pylon_length = stckd_xoc_offset*AR_w/b_w * pylon_pos\n\n        for i in stacked\n            pylon = generatepylon(pylon_length; ncells=5)\n\n            right = i<=nr_w\n            this_O = O_rotor_w[ right ? i : nr_w-(i-nr_w-1)]  # Chooses position\n            this_O = [1 0 0; 0 (-1)^!right 0; 0 0 1]*this_O   # Places it in correct side\n            this_O += main_wing.O                             # Translates it with the wing\n                                                              # Offsets it according to length\n            this_O += [1/3*0.5*pylon_pos, 0, 3*R_w*stckd_zoR_offset]\n            rotation = gt.rotation_matrix2(0, 0, 0)\n\n            gt.lintransform!(pylon, rotation, this_O)\n\n            gt.addgrid(body, \"Pylon$i\", pylon)\n        end\n    end\n\n\n    ############################################################################\n    # DEFINE VEHICLE\n    ############################################################################\n\n    # System of all FLOWVLM objects\n    system = vlm.WingSystem()\n    vlm.addwing(system, \"MainWing\", main_wing)\n    vlm.addwing(system, \"TandemWing\", tandem_wing)\n\n    # Tilting systems\n    tilting_systems = (main_wing_moving, tandem_wing_moving)\n\n    # Rotors grouped by systems with shared RPM control\n    if add_rotors\n        rotor_systems = (rotors_w, rotors_w_stacked_up, rotors_w_stacked_low, rotors_tw)\n    else\n        rotor_systems = ()\n    end\n\n    # System solved through VLM solver\n    vlm_system_m = vlm.WingSystem()\n    vlm.addwing(vlm_system_m, \"letL\", winglet_L)\n    vlm.addwing(vlm_system_m, \"L\", wing_L)\n    vlm.addwing(vlm_system_m, \"middle\", wing_md)\n    vlm.addwing(vlm_system_m, \"R\", wing_R)\n    vlm.addwing(vlm_system_m, \"letR\", winglet_R)\n\n    vlm_system_t = vlm.WingSystem()\n    vlm.addwing(vlm_system_t, \"L\", twing_L)\n    vlm.addwing(vlm_system_t, \"R\", twing_R)\n\n    vlm_system = vlm.WingSystem()\n    if add_wings\n        vlm.addwing(vlm_system, \"MWing\", vlm_system_m)\n        vlm.addwing(vlm_system, \"TWing\", vlm_system_t)\n    end\n\n    # All rotors\n    if add_rotors\n        rotors = vcat(rotors_w, rotors_w_stacked_up, rotors_w_stacked_low, rotors_tw)\n    end\n\n    # System that will shed a VPM wake\n    wake_system = vlm.WingSystem()\n\n    if add_wings\n        vlm.addwing(wake_system, \"SolveVLM\", vlm_system)\n    end\n\n    if add_rotors\n        if VehicleType==uns.VLMVehicle\n            for (i, rotor) in enumerate(rotors)\n                vlm.addwing(wake_system, \"Rotor$i\", rotor)\n            end\n        else\n            # Mute warnings regarding potential colinear vortex filaments. This is\n            # needed since the quasi-steady solver will probe induced velocities at the\n            # lifting line of the blade\n            uns.vlm.VLMSolver._mute_warning(true)\n        end\n    end\n\n    # Visualization grids that are rotated and translated along with the vehicle\n    grids = [body]\n\n    # Define vehicle\n    vehicle = VehicleType(   system;\n                                tilting_systems=tilting_systems,\n                                rotor_systems=rotor_systems,\n                                vlm_system=vlm_system,\n                                wake_system=wake_system,\n                                grids=grids\n                             )\n\n    return vehicle\nend","category":"page"},{"location":"examples/vahana-vehicle/","page":"Vehicle Definition","title":"Vehicle Definition","text":"info: Full example\nThe function that defines the fuselage is given in the full example under examples/vahana/vahana_vehicle.jl","category":"page"},{"location":"examples/heavingwing/#Heaving-Wing","page":"Heaving Wing","title":"Heaving Wing","text":"","category":"section"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:74%;\"\n        src=\"https://www.youtube.com/embed/Pch94bKpjrQ?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"In this example we extend the simple wing case to create a case of interactional aerodynamics. We will place a straight wing flying in front of the original swept-back wing. The front wing will be moving in a heaving motion, shedding a wake that impinges on the back wing causing an unsteady loading.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"This simulation exemplify the following features:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"Defining a uns.VLMVehicle with multiple surfaces, one of them declared as a tilting surface\nDefining the control inputs for a tilting system in uns.KinematicManeuver (in this case, tilting the surface over time in a heaving motion)","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"#=##############################################################################\n# DESCRIPTION\n    Swept-back wing flying in the wake of a tandem wing in heaving motion.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\nrun_name        = \"heavingwing-example\"    # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n# Back wing description\nb_back          = 2.489                     # (m) span length\nar_back         = 5.0                       # Aspect ratio b/c_tip\ntr_back         = 1.0                       # Taper ratio c_tip/c_root\ntwist_root_back = 0.0                       # (deg) twist at root\ntwist_tip_back  = 0.0                       # (deg) twist at tip\nlambda_back     = 45.0                      # (deg) sweep\ngamma_back      = 0.0                       # (deg) dihedral\n\n# Front wing description\nb_front         = 0.75*b_back\nar_front        = 5.0\ntr_front        = 1.0\ntwist_root_front= 5.0\ntwist_tip_front = 0.0\nlambda_front    = 0.0\ngamma_front     = 0.0\n\ndx              = 0.75*b_back               # (m) spacing between back and front wings\n\n# Discretization\nn_back          = 50                        # Number of spanwise elements per side\nr_back          = 2.0                       # Geometric expansion of elements\ncentral_back    = false                     # Whether expansion is central\n\nn_front         = 40\nr_front         = 10.0\ncentral_front   = false\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n# Vehicle motion\nmagVvehicle     = 49.7                      # (m/s) vehicle velocity\nAOA             = 4.2                       # (deg) angle of attack of back wing\nfrequency       = 25.0                      # (Hz) oscillation frequency in heaving motion\namplitude       = 5.0                       # (deg) AOA amplitude in heaving motion\n\n# Freestream\nmagVinf         = 1e-8                      # (m/s) freestream velocity\nrho             = 0.93                      # (kg/m^3) air density\nqinf            = 0.5*rho*magVvehicle^2     # (Pa) static pressure (reference)\n\nVinf(X, t)      = t==0 ? magVvehicle*[1,0,0] : magVinf*[1,0,0] # Freestream function\n\n# NOTE: In this simulation we will have the vehicle (the two wings) move while\n#       the freestream is zero. However, a zero freestream can cause some\n#       numerical instabilities in the solvers. To avoid instabilities, it is\n#       recommended giving a full freestream velocity (or the velocity of the\n#       vehicle) in the first time step `t=0`, and a negligible small velocity\n#       at any other time, as shown above in the definition of `Vinf(X ,t)`.\n\nmagVref         = magVvehicle               # (m/s) reference velocity (for calculation\n                                            # purposes since freestream is zero)\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Time parameters\nwakelength      = 4.0*b_back                # (m) length of wake to be resolved\nttot            = wakelength/magVref        # (s) total simulation time\nnsteps          = 200                       # Number of time steps\n\n# VLM and VPM parameters\np_per_step      = 2                         # Number of particle sheds per time step\n\nsigma_vlm_solver= -1                        # VLM-on-VLM smoothing radius (deactivated with <0)\nsigma_vlm_surf  = 0.05*b_back               # VLM-on-VPM smoothing radius\nlambda_vpm      = 2.0                       # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * magVref * (ttot/nsteps)/p_per_step\n\nshed_starting   = true                      # Whether to shed starting vortex\nvlm_rlx         = 0.7                       # VLM relaxation\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate back wing\nbackwing = vlm.simpleWing(b_back, ar_back, tr_back, twist_root_back,\n                            lambda_back, gamma_back; twist_tip=twist_tip_back,\n                            n=n_back, r=r_back, central=central_back);\n\n# Pitch back wing to its angle of attack\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0.0, -AOA, 0.0)     # New orientation\nvlm.setcoordsystem(backwing, O, Oaxis)\n\n# Generate front wing\nfrontwing = vlm.simpleWing(b_front, ar_front, tr_front, twist_root_front,\n                            lambda_front, gamma_front; twist_tip=twist_tip_front,\n                            n=n_front, r=r_front, central=central_front);\n\n# Move wing to the front\nO = [-dx, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0.0, 0.0, 0.0)      # New orientation\nvlm.setcoordsystem(frontwing, O, Oaxis)\n\n\nprintln(\"Generating vehicle...\")\n\n# Places the front wing into its own system that will be heaving\nheavingsystem = vlm.WingSystem()            # Tilting system\nvlm.addwing(heavingsystem, \"FrontWing\", frontwing)\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"BackWing\", backwing)\nvlm.addwing(system, \"Heaving\", heavingsystem)\n\ntilting_systems = (heavingsystem, );        # Tilting systems\n\nvlm_system = system;                        # System solved through VLM solver\nwake_system = system;                       # System that will shed a VPM wake\n\nvehicle = uns.VLMVehicle(   system;\n                            tilting_systems=tilting_systems,\n                            vlm_system=vlm_system,\n                            wake_system=wake_system\n                         );\n\n# NOTE: Through the `tilting_systems` keyword argument to `uns.VLMVehicle` we\n#       have declared that the front wing will be tilting throughout the\n#       simulation, acting as a control surface. We will later declare the\n#       control inputs to this tilting surface when we define the\n#       `uns.KinematicManeuver`\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = [-1, 0, 0]        # <---- Vehicle is traveling in the -x direction\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# Control inputs\nangle_frontwing(t) = [0, amplitude*sin(2*pi*frequency * t*ttot), 0]  # Tilt angle of front wing\n\nangle = (angle_frontwing, )                 # Angle of each tilting system\nRPM = ()                                    # RPM of each rotor system (none)\n\nmaneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time.\n#       `angle` defines the tilting angle of each tilting system over time.\n#       `RPM` defines the RPM of each rotor system over time.\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n ","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"At this point we can verify that we have correctly defined the control inputs of the maneuver calling FLOWUnsteady.plot_maneuver as follows:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"uns.plot_maneuver(maneuver)","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-maneuver-controls.png\" alt=\"Pic here\" style=\"width: 85%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"Here we confirm that the angle of the tilting surface along the y-axis of the vehicle (pitch) will change sinusoidally with amplitude 5^circ, as expected. This function also plots the kinematics of the vehicle, which in this case are rather uneventful (straight line).","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"Now we continue defining the simulation:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = magVvehicle                          # Reference velocity to scale maneuver by\nRPMref = 0.0                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\n                                            # Maximum number of particles\nmax_particles = (nsteps+1)*(vlm.get_m(vehicle.vlm_system)*(p_per_step+1) + p_per_step)\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\nfigs, figaxs = [], []                       # Figures generated by monitors\n\n# Generate function that computes aerodynamic forces\ncalc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                    add_parasiticdrag=true,\n                                    add_skinfriction=true,\n                                    airfoilpolar=\"xf-rae101-il-1000000.csv\"\n                                    )\n\nL_dir(t) = [0, 0, 1]                        # Direction of lift\nD_dir(t) = [1, 0, 0]                        # Direction of drag\n\n# Generate back wing monitor\nmonitor_backwing = uns.generate_monitor_wing(backwing, Vinf, b_back, ar_back,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name*\"-backwing\",\n                                            title_lbl=\"Back Wing\",\n                                            figname=\"back-wing monitor\",\n                                            )\n\n# Generate front wing monitor\nmonitor_frontwing = uns.generate_monitor_wing(frontwing, Vinf, b_front, ar_front,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name*\"-frontwing\",\n                                            title_lbl=\"Front Wing\",\n                                            figname=\"front-wing monitor\",\n                                            )\n\nmonitors = uns.concatenate(monitor_backwing, monitor_frontwing)\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    sigma_vlm_solver=sigma_vlm_solver,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_vlm_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    vlm_rlx=vlm_rlx,\n                    shed_starting=shed_starting,\n                    extra_runtime_function=monitors,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_BackWing_vlm...vtk;\")\n    files *= run_name*\"_Heaving_FrontWing_vlm...vtk;\"\n    files *= run_name*\"_pfield...xmf;\"\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~10 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (`n` and `nsteps`) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"As the simulation runs, you will see the monitors (shown below) plotting the lift and drag coefficients over time along with the loading distribution.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-frontwing_convergence.png\"\n                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n    <br>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-backwing_convergence.png\"\n                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"In these monitors, we clearly see the fluctuation of C_L and C_D over time due to the heaving motion (front wing) and the wake impingement (back wing). The plots of loading distribution seem very convoluted since the loading fluctuates over time, and all the time steps are super imposed in the monitor.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"To more clearly see what the loading distribution is doing, it is insightful to plot the loading as an animation as shown below.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-animation.gif\"\n                                        alt=\"Vid here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"info: Animations\nCheck the full example under examples/heavingwing/ to see how to postprocess the simulation and generate this animation.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"info: Quasi-steady solver\nFLOWUnsteady also provides a quasi-steady solver for low-fidelity simulations that replaces the particle field with rigid semi-infinite wakes. The quasi-steady solver is invoked by simply changing the line that defines the vehicle fromvehicle = uns.VLMVehicle(...)tovehicle = uns.QVLMVehicle(...)(yes, it is only one character of a difference)Use the keyword argument save_horseshoes = false in uns.run_simulation to visualize the semi-infinite rigid wake. The quasi-steady simulation looks like this:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<p align=\"center\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/tandemheaving142_1.gif\" alt=\"Vid\" width=\"75%\"/>\n</p>","category":"page"},{"location":"examples/blownwing-aero/#blownwingaero","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"","category":"section"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/3REcIdIXrZA?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"In this example we show mount propellers on a swept wing. The wing is modeled using the actuator line model that represents the wing as a lifting line. This wing model is accurate for capturing wing-on-prop interactions. For instance, the rotor will experience an unsteady blade loading (and increased tonal noise) caused by the turning of the flow ahead of the wing leading edge. However, this simple wing model is not adecuate for capturing prop-on-wing interactions (see the next two sections to accurately predict prop-on-wing interactions).","category":"page"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of swept-back wing with twin props mounted mid span blowing on\n    the wing.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Apr 2023\n  * Last updated    : Apr 2023\n  * License         : MIT\n=###############################################################################\n\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\nimport FLOWVPM as vpm\n\nrun_name        = \"blownwing-example\"       # Name of this simulation\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n# Wing geometry\nb               = 2.489                     # (m) span length\nar              = 5.0                       # Aspect ratio b/c_tip\ntr              = 1.0                       # Taper ratio c_tip/c_root\ntwist_root      = 0.0                       # (deg) twist at root\ntwist_tip       = 0.0                       # (deg) twist at tip\nlambda          = 45.0                      # (deg) sweep\ngamma           = 0.0                       # (deg) dihedral\n\n# Rotor geometry\nR               = 0.075*b                   # (m) rotor radius\nRhub            = 0.075*R                   # (m) hub radius\nB               = 2                         # Number of blades\nblade_file      = \"apc10x7_blade.csv\"       # Blade geometry\ndata_path       = uns.def_data_path         # Path to rotor database\npitch           = 5.0                       # (deg) collective pitch of blades\nxfoil           = true                      # Whether to run XFOIL\nncrit           = 9                         # Turbulence criterion for XFOIL\n\n# Vehicle assembly\nAOAwing         = 4.2                       # (deg) wing angle of attack\nspanpos         = [-0.5, 0.5]               # Semi-span position of each rotor, 2*y/b\nxpos            = [-0.5, -0.5]              # x-position of rotors relative to LE, x/c\nzpos            = [0.0, 0.0]                # z-position of rotors relative to LE, z/c\nCWs             = [false, true]             # Clockwise rotation for each rotor\nnrotors         = length(spanpos)           # Number of rotors\n\n# Discretization\nn_wing          = 50                        # Number of spanwise elements per side\nr_wing          = 2.0                       # Geometric expansion of elements\nn_rotor         = 15                        # Number of blade elements per blade\nr_rotor         = 1/10                      # Geometric expansion of elements\n\n# Check that we declared all the inputs that we need for each rotor\n@assert length(spanpos)==length(xpos)==length(zpos)==length(CWs) \"\"*\n    \"Invalid rotor inputs! Check that spanpos, xpos, zpos, and CWs have the same length\"\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n# Vehicle motion\nmagVvehicle     = 49.7                      # (m/s) vehicle velocity\nAOA             = 0.0                       # (deg) vehicle angle of attack\n\n# Freestream\nmagVinf         = 1e-8                      # (m/s) freestream velocity\nrho             = 0.93                      # (kg/m^3) air density\nmu              = 1.85508e-5                # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\nmagVref         = sqrt(magVinf^2 + magVvehicle^2) # (m/s) reference velocity\nqinf            = 0.5*rho*magVref^2         # (Pa) reference static pressure\n\nVinf(X, t)      = t==0 ? magVvehicle*[1,0,0] : magVinf*[1,0,0] # Freestream function\n\n# Rotor operation\nJ               = 0.9                       # Advance ratio Vref/(nD)\nRPM             = 60*magVref/(J*2*R)        # RPM\n\nRec             = rho * magVref * (b/ar) / mu       # Chord-based wing Reynolds number\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based rotor Reynolds number\nMatip           = 2*pi*RPM/60 * R / speedofsound    # Tip Mach number\n\nprintln(\"\"\"\n    Vref:   $(round(magVref, digits=1)) m/s\n    RPM:    $(RPM)\n    Matip:  $(round(Matip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n    Rec:    $(round(Rec, digits=0))\n\"\"\")\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n# VehicleType     = uns.QVLMVehicle         # Quasi-steady solver\nconst_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the\n                                                # solution is constant or not\n# Time parameters\nnrevs           = 15                        # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\np_per_step      = 4                         # Sheds per time step\nshed_starting   = true                      # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nunsteady_shedcrit = 0.001                   # Shed unsteady loading whenever circulation\n                                            #  fluctuates by more than this ratio\nmax_particles   = nrotors*((2*n_rotor+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles\nmax_particles   += (nsteps+1)*(2*n_wing*(p_per_step+1) + p_per_step)\n\n# Regularization\nsigma_vlm_surf  = b/100                     # VLM-on-VPM smoothing radius\nsigma_rotor_surf= R/50                      # Rotor-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\nsigmafactor_vpmonvlm= 1                     # Shrink particles by this factor when\n                                            #  calculating VPM-on-VLM/Rotor induced velocities\n\n# Rotor solver\nvlm_rlx         = 0.5                       # VLM relaxation <-- this also applied to rotors\nhubtiploss_correction = vlm.hubtiploss_nocorrection # Hub and tip correction\n\n# VPM solver\nvpm_integration = vpm.rungekutta3           # VPM temporal integration scheme\n# vpm_integration = vpm.euler\n\nvpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme\n# vpm_viscous   = vpm.CoreSpreading(-1, -1, vpm.zeta_fmm; beta=100.0, itmax=20, tol=1e-1)\n\nvpm_SFS         = vpm.SFS_none              # VPM LES subfilter-scale model\n# vpm_SFS       = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;\n#                                   alpha=0.999, maxC=1.0,\n#                                   clippings=[vpm.clipping_backscatter])\n\nif VehicleType == uns.QVLMVehicle\n    # Mute warnings regarding potential colinear vortex filaments. This is\n    # needed since the quasi-steady solver will probe induced velocities at the\n    # lifting line of the blade\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\nprintln(\"\"\"\n    Resolving wake for $(round(ttot*magVref/b, digits=1)) span distances\n\"\"\")\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\n\n# -------- Generate components\nprintln(\"Generating geometry...\")\n\n# Generate wing\nwing = vlm.simpleWing(b, ar, tr, twist_root, lambda, gamma;\n                                    twist_tip=twist_tip, n=n_wing, r=r_wing);\n\n# Pitch wing to its angle of attack\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0, -AOAwing, 0)     # New orientation\nvlm.setcoordsystem(wing, O, Oaxis)\n\n# Generate rotors\nrotors = vlm.Rotor[]\nfor ri in 1:nrotors\n\n    # Generate rotor\n    rotor = uns.generate_rotor(R, Rhub, B, blade_file;\n                                        pitch=pitch,\n                                        n=n_rotor, CW=CWs[ri], blade_r=r_rotor,\n                                        altReD=[RPM, J, mu/rho],\n                                        xfoil=xfoil,\n                                        ncrit=ncrit,\n                                        data_path=data_path,\n                                        verbose=true,\n                                        verbose_xfoil=false,\n                                        plot_disc=false\n                                        );\n\n    # Determine position along wing LE\n    y = spanpos[ri]*b/2\n    x = abs(y)*tand(lambda) + xpos[ri]*b/ar\n    z = abs(y)*tand(gamma) + zpos[ri]*b/ar\n\n    # Account for angle of attack of wing\n    nrm = sqrt(x^2 + z^2)\n    x = (x==0 ? 1 : sign(x))*nrm*cosd(AOAwing)\n    z = -(z==0 ? 1 : sign(z))*nrm*sind(AOAwing)\n\n    # Translate rotor to its position along wing\n    O = [x, y, z]                                       # New position\n    Oaxis = uns.gt.rotation_matrix2(0, 0, 180)          # New orientation\n    vlm.setcoordsystem(rotor, O, Oaxis)\n\n    push!(rotors, rotor)\nend\n\n\n# -------- Generate vehicle\nprintln(\"Generating vehicle...\")\n\n# System of all FLOWVLM objects\nsystem = vlm.WingSystem()\n\nvlm.addwing(system, \"Wing\", wing)\n\nfor (ri, rotor) in enumerate(rotors)\n    vlm.addwing(system, \"Rotor$(ri)\", rotor)\nend\n\n# System solved through VLM solver\nvlm_system = vlm.WingSystem()\nvlm.addwing(vlm_system, \"Wing\", wing)\n\n# Systems of rotors\nrotor_systems = (rotors, );\n\n# System that will shed a VPM wake\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\nvlm.addwing(wake_system, \"Wing\", wing)\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle\n    for (ri, rotor) in enumerate(rotors)\n        vlm.addwing(wake_system, \"Rotor$(ri)\", rotor)\n    end\nend\n\n# Pitch vehicle to its angle of attack\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0, -AOA, 0)         # New orientation\nvlm.setcoordsystem(system, O, Oaxis)\n\nvehicle = VehicleType(   system;\n                            vlm_system=vlm_system,\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = [-1, 0, 0]        # <---- Vehicle is traveling in the -x direction\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = (RPMcontrol, )                       # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = magVvehicle                          # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\n# Generate function that computes wing aerodynamic forces\ncalc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                    add_parasiticdrag=true,\n                                    add_skinfriction=true,\n                                    airfoilpolar=\"xf-rae101-il-1000000.csv\"\n                                    )\n\nL_dir(t) = [0, 0, 1]                        # Direction of lift\nD_dir(t) = [1, 0, 0]                        # Direction of drag\n\n# Generate wing monitor\nmonitor_wing = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            save_path=save_path,\n                                            run_name=run_name*\"-wing\",\n                                            figname=\"wing monitor\",\n                                            )\n\n# Generate rotors monitor\nmonitor_rotors = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                            t_scale=RPM/60,        # Scaling factor for time in plots\n                                            t_lbl=\"Revolutions\",   # Label for time axis\n                                            save_path=save_path,\n                                            run_name=run_name*\"-rotors\",\n                                            figname=\"rotors monitor\",\n                                            )\n# Concatenate monitors\nmonitors = uns.concatenate(monitor_wing, monitor_rotors)\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\n\n# Run simulation\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho, mu=mu, sound_spd=speedofsound,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    vpm_integration=vpm_integration,\n                    vpm_viscous=vpm_viscous,\n                    vpm_SFS=vpm_SFS,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_rotor_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    sigmafactor_vpmonvlm=sigmafactor_vpmonvlm,\n                    vlm_rlx=vlm_rlx,\n                    hubtiploss_correction=hubtiploss_correction,\n                    shed_starting=shed_starting,\n                    shed_unsteady=shed_unsteady,\n                    unsteady_shedcrit=unsteady_shedcrit,\n                    extra_runtime_function=monitors,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    save_wopwopin=true,  # <--- Generates input files for PSU-WOPWOP noise analysis\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_pfield...xmf;\")\n    for ri in 1:nrotors\n        for bi in 1:B\n            global files *= run_name*\"_Rotor$(ri)_Blade$(bi)_loft...vtk;\"\n        end\n    end\n    files *= run_name*\"_Wing_vlm...vtk;\"\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~60 minutes on a 16-core AMD EPYC 7302 processor. <br>\n</i></span>\n<br><br>","category":"page"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//blownwing-example-rotors_convergence.png\"\n                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n    <br>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//blownwing-example-wing_convergence.png\"\n                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//blownwing-example-animation.gif\"\n                                        alt=\"Vid here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/blownwing-aero/","page":"Wing-on-Prop Interactions","title":"Wing-on-Prop Interactions","text":"info: Unsteady Loading Animation\nCheck the full example under examples/blownwing/ to see how to postprocess the simulation and generate this animation.","category":"page"},{"location":"examples/propeller-quasisteady/#Quasi-Steady-Solver","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"","category":"section"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"While unsteady simulations are resolved using the reformulated VPM, FLOWUnsteady also provides a quasi-steady solver for low-fidelity simulations. The quasi-steady solver replaces the particle field with semi-infinite rigid wakes in wings and blade-element momentum theory in rotors.","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"The quasi-steady solver is invoked by simply changing the line","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"VehicleType     = uns.UVLMVehicle","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"to","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"VehicleType   = uns.QVLMVehicle","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"in the previous sections. The results of the quasi-steady solver are shown below, predicted through blade-element momentum theory.","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-Jsweep-exampleBEMT.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-quasisteady/#Quasi-Steady-Solver","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"","category":"section"},{"location":"examples/rotorhover-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"The aerodynamic and aeroacoustic analysis can also be performed using the quasi-steady solver (which uses BEMT for the aerodynamic solution), by simply changing the following parameter in the aero solution:","category":"page"},{"location":"examples/rotorhover-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"VehicleType     = uns.QVLMVehicle\nn               = 50   # <---- For some reason PSU-WOPWOP breaks with less blade elements","category":"page"},{"location":"examples/rotorhover-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"and this parameter when calling PSU-WOPWOP:","category":"page"},{"location":"examples/rotorhover-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"const_solution  = true","category":"page"},{"location":"examples/vahana-monitor/#vahanamonitor","page":"Monitors Definitions","title":"Monitors Definitions","text":"","category":"section"},{"location":"examples/vahana-monitor/","page":"Monitors Definitions","title":"Monitors Definitions","text":"Here we define the monitors of the simulation and concatenate them all.","category":"page"},{"location":"examples/vahana-monitor/","page":"Monitors Definitions","title":"Monitors Definitions","text":"\"\"\"\n    Generates the monitors of Vahana eVTOL simulation\n\"\"\"\nfunction generate_monitor_vahana(vehicle, rho, RPMref, nsteps, save_path, Vinf;\n                                                        add_wings=true,\n                                                        wingmonitor_optargs=[])\n\n    # Collect all monitors here\n    monitors = []\n\n    # -------------------- WING MONITORS ---------------------------------------\n    # Reference parameters for calculating coefficients\n    # NOTE: make b, ar, and qinf equals to 1.0 to obtain dimensional force\n    b_ref, ar_ref = 1.0, 1.0\n    qinf = 1.0\n    Jref = 1.0\n\n    # Force axis labels\n    CL_lbl = \"Lift (N)\"\n    CD_lbl = \"Drag (N)\"\n\n    # Directions of force components\n    L_dir = [0, 0, 1]\n    D_dir = [-1, 0, 0]\n\n    # Generate function that computes wing aerodynamic forces\n    calc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                        add_parasiticdrag=true,\n                                        add_skinfriction=true,\n                                        airfoilpolar=\"xf-n0012-il-500000-n5.csv\"\n                                        )\n\n    if add_wings\n\n        # Main wing monitor\n        monitor_name = \"wing_main\"\n        mainwing_system = vlm.get_wing(vehicle.vlm_system, \"MWing\")\n        mainwing_monitor = uns.generate_monitor_wing(mainwing_system, Vinf, b_ref, ar_ref,\n                                                        rho, qinf, nsteps;\n                                                        calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                                        save_path=save_path,\n                                                        run_name=monitor_name,\n                                                        figname=monitor_name,\n                                                        CL_lbl=CL_lbl,\n                                                        CD_lbl=CD_lbl,\n                                                        L_dir=L_dir,\n                                                        D_dir=D_dir,\n                                                        wingmonitor_optargs...)\n\n        # Tandem wing monitor\n        monitor_name = \"wing_tandem\"\n        tandemwing_system = vlm.get_wing(vehicle.vlm_system, \"TWing\")\n        tandemwing_monitor = uns.generate_monitor_wing(tandemwing_system, Vinf, b_ref, ar_ref,\n                                                        rho, qinf, nsteps;\n                                                        calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                                        save_path=save_path,\n                                                        run_name=monitor_name,\n                                                        figname=monitor_name,\n                                                        CL_lbl=CL_lbl,\n                                                        CD_lbl=CD_lbl,\n                                                        L_dir=L_dir,\n                                                        D_dir=D_dir,\n                                                        wingmonitor_optargs...)\n\n        push!(monitors, mainwing_monitor)\n        push!(monitors, tandemwing_monitor)\n    end\n\n\n\n\n    # -------------------- ROTOR MONITORS --------------------------------------\n    for (si, rotors) in enumerate(vehicle.rotor_systems)\n\n        monitor_name = \"rotorsys$(si)\"\n\n        rotors_monitor = uns.generate_monitor_rotors(rotors, Jref, rho, RPMref,\n                                                        nsteps;\n                                                        save_path=save_path,\n                                                        run_name=monitor_name,\n                                                        figname=monitor_name,\n                                                        save_init_plots=false)\n        push!(monitors, rotors_monitor)\n    end\n\n\n    # -------------------- OTHER MONITORS --------------------------------------\n\n    # State-variable monitor\n    statevariable_monitor = uns.generate_monitor_statevariables(; save_path=save_path)\n\n    # Global enstrophy monitor (numerical stability)\n    monitor_enstrophy = uns.generate_monitor_enstrophy(; save_path=save_path)\n\n    # Monitor of SFS model coefficient Cd\n    monitor_Cd = uns.generate_monitor_Cd(; save_path=save_path)\n\n\n    # -------------------- CONCATENATE MONITORS --------------------------------\n    return uns.concatenate(statevariable_monitor, monitor_enstrophy, monitor_Cd, monitors...)\nend","category":"page"},{"location":"examples/rotorhover-aero/#rotorhoveraero","page":"Variable Fidelity","title":"Variable Fidelity","text":"","category":"section"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/u9SgYbYhPpU?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"While propeller simulations tend to be numerically well behaved, a hover case can pose multiple numerical challenges. The rotation of blades in static air drives a strong axial flow that is solely caused by the shedding of tip vortices. This is challenging to simulate since, in the absence of a freestream, the wake quickly becomes fully turbulent and breaks down as tip vortices leapfrog and mix close to the rotor. Thus, a rotor in hover is a good engineering application to showcase the numerical stability and accuracy of FLOWUnsteady.","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"In this example we simulate a DJI rotor in hover, and we use this case to demonstrate some of the advanced features of FLOWUnsteady that make it robust and accurate in resolving turbulent mixing:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Subfilter scale (SFS) model of turbulence related to vortex stretching\nHow to monitor the dynamic SFS model coefficient with   uns.generate_monitor_Cd\nHow to monitor the global flow enstrophy with   uns.generate_monitor_enstrophy and track numerical stability\nDefining a wake treatment procedure to suppress initial hub wake, avoiding   hub fountain effects and accelerating convergence\nDefining hub and tip loss corrections","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Also, in this example you can vary the fidelity of the simulation setting the following parameters:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Parameter Mid-low fidelity Mid-high fidelity High fidelity Description\nn 20 50 50 Number of blade elements per blade\nnsteps_per_rev 36 72 360 Time steps per revolution\np_per_step 4 2 2 Particle sheds per time step\nsigma_rotor_surf R/10 R/10 R/80 Rotor-on-VPM smoothing radius\nsigmafactor_vpmonvlm 1.0 1.0 5.5 Expand particles by this factor when calculating VPM-on-VLM/Rotor induced velocities\nshed_starting false false true Whether to shed starting vortex\nsuppress_fountain true true false Whether to suppress hub fountain effect\nvpm_integration vpm.euler RK3^star RK3^star VPM time integration scheme\nvpm_SFS None^dag None^dag Dynamic^ddag VPM LES subfilter-scale model","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"^starRK3: vpm_integration = vpm.rungekutta3\n^dagNone: vpm_SFS = vpm.SFS_none\n^ddagDynamic: vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<br>\n\n<table>\n    <tr>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-midlow-00.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n            <br>\n            <center><b>Mid-Low</b><br>70k particles<br>~7 mins.</center>\n        </td>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-midhigh-00.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n            <br>\n            <center><b>Mid-High</b><br>200k particles<br>~60 mins.</center>\n        </td>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-high-03.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n            <br>\n            <center><b>High</b><br>1M particles<br>~30 hrs.</center>\n        </td>\n    </tr>\n</table>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<br>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of a DJI 9443 rotor in hover (two-bladed rotor, 9.4 inches\n    diameter).\n\n    This example replicates the experiment described in Zawodny & Boyd (2016),\n    \"Acoustic Characterization and Prediction of Representative,\n    Small-scale Rotary-wing Unmanned Aircraft System Components.\"\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\nimport FLOWVPM as vpm\n\nrun_name        = \"rotorhover-example\"      # Name of this simulation\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n\n# Rotor geometry\nrotor_file      = \"DJI9443.csv\"             # Rotor geometry\ndata_path       = uns.def_data_path         # Path to rotor database\npitch           = 0.0                       # (deg) collective pitch of blades\nCW              = false                     # Clock-wise rotation\nxfoil           = false                     # Whether to run XFOIL\nread_polar      = vlm.ap.read_polar2        # What polar reader to use\n\n# NOTE: If `xfoil=true`, XFOIL will be run to generate the airfoil polars used\n#       by blade elements before starting the simulation. XFOIL is run\n#       on the airfoil contours found in `rotor_file` at the corresponding\n#       local Reynolds and Mach numbers along the blade.\n#       Alternatively, the user can provide pre-computer airfoil polars using\n#       `xfoil=false` and providing the polar files through `rotor_file`.\n#       `read_polar` is the function that will be used to parse polar files. Use\n#       `vlm.ap.read_polar` for files that are direct outputs of XFOIL (e.g., as\n#       downloaded from www.airfoiltools.com). Use `vlm.ap.read_polar2` for CSV\n#       files.\n\n# Discretization\nn               = 20                        # Number of blade elements per blade\nr               = 1/10                      # Geometric expansion of elements\n\n# NOTE: Here a geometric expansion of 1/10 means that the spacing between the\n#       tip elements is 1/10 of the spacing between the hub elements. Refine the\n#       discretization towards the blade tip like this in order to better\n#       resolve the tip vortex.\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n\n# Operating conditions\nRPM             = 5400                      # RPM\nJ               = 0.0001                    # Advance ratio Vinf/(nD)\nAOA             = 0                         # (deg) Angle of attack (incidence angle)\n\nrho             = 1.071778                  # (kg/m^3) air density\nmu              = 1.85508e-5                # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\n\n# NOTE: For cases with zero freestream velocity, it is recommended that a\n#       negligible small velocity is used instead of zero in order to avoid\n#       potential numerical instabilities (hence, J here is negligible small\n#       instead of zero)\n\nmagVinf         = J*RPM/60*(2*R)\nVinf(X, t)      = magVinf*[cos(AOA*pi/180), sin(AOA*pi/180), 0]  # (m/s) freestream velocity vector\n\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number\nMatip           = 2*pi*RPM/60 * R / speedofsound    # Tip Mach number\n\nprintln(\"\"\"\n    RPM:    $(RPM)\n    Vinf:   $(Vinf(zeros(3), 0)) m/s\n    Matip:  $(round(Matip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n\"\"\")\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n# VehicleType     = uns.QVLMVehicle         # Quasi-steady solver\nconst_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the\n                                                # solution is constant or not\n# Time parameters\nnrevs           = 10                        # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\np_per_step      = 4                         # Sheds per time step\nshed_starting   = false                     # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nunsteady_shedcrit = 0.001                   # Shed unsteady loading whenever circulation\n                                            #  fluctuates by more than this ratio\nmax_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles\n\n# Regularization\nsigma_rotor_surf= R/10                      # Rotor-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\nsigmafactor_vpmonvlm= 1                     # Shrink particles by this factor when\n                                            #  calculating VPM-on-VLM/Rotor induced velocities\n\n# Rotor solver\nvlm_rlx         = 0.5                       # VLM relaxation <-- this also applied to rotors\nhubtiploss_correction = ((0.4, 5, 0.1, 0.05), (2, 1, 0.25, 0.05)) # Hub and tip correction\n\n# VPM solver\nvpm_integration = vpm.euler                 # VPM temporal integration scheme\n# vpm_integration = vpm.rungekutta3\n\nvpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme\n# vpm_viscous   = vpm.CoreSpreading(-1, -1, vpm.zeta_fmm; beta=100.0, itmax=20, tol=1e-1)\n\nvpm_SFS         = vpm.SFS_none              # VPM LES subfilter-scale model\n# vpm_SFS       = vpm.SFS_Cd_twolevel_nobackscatter\n# vpm_SFS       = vpm.SFS_Cd_threelevel_nobackscatter\n# vpm_SFS       = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;\n#                                   alpha=0.999, maxC=1.0,\n#                                   clippings=[vpm.clipping_backscatter])\n# vpm_SFS       = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;\n#                                   alpha=0.999, rlxf=0.005, minC=0, maxC=1\n#                                   clippings=[vpm.clipping_backscatter],\n#                                   controls=[vpm.control_sigmasensor],\n#                                   )\n\n# NOTE: In most practical situations, open rotors operate at a Reynolds number\n#       high enough that viscous diffusion in the wake is actually negligible.\n#       Hence, it does not make much of a difference whether we run the\n#       simulation with viscous diffusion enabled or not. On the other hand,\n#       such high Reynolds numbers mean that the wake quickly becomes turbulent\n#       and it is crucial to use a subfilter-scale (SFS) model to accurately\n#       capture the turbulent decay of the wake (turbulent diffusion).\n\nif VehicleType == uns.QVLMVehicle\n    # Mute warnings regarding potential colinear vortex filaments. This is\n    # needed since the quasi-steady solver will probe induced velocities at the\n    # lifting line of the blade\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\n\n\n# ----------------- WAKE TREATMENT ---------------------------------------------\n# NOTE: It is known in the CFD community that rotor simulations with an\n#       impulsive RPM start (*i.e.*, 0 to RPM in the first time step, as opposed\n#       to gradually ramping up the RPM) leads to the hub \"fountain effect\",\n#       with the root wake reversing the flow near the hub.\n#       The fountain eventually goes away as the wake develops, but this happens\n#       very slowly, which delays the convergence of the simulation to a steady\n#       state. To accelerate convergence, here we define a wake treatment\n#       procedure that suppresses the hub wake for the first three revolutions,\n#       avoiding the fountain effect altogether.\n#       This is especially helpful in low and mid-fidelity simulations.\n\nsuppress_fountain   = true                  # Toggle\n\n# Supress wake shedding on blade elements inboard of this r/R radial station\nno_shedding_Rthreshold = suppress_fountain ? 0.35 : 0.0\n\n# Supress wake shedding for this many time steps\nno_shedding_nstepsthreshold = 3*nsteps_per_rev\n\nomit_shedding = []          # Index of blade elements to supress wake shedding\n\n# Function to suppress or activate wake shedding\nfunction wake_treatment_supress(sim, args...; optargs...)\n\n    # Case: start of simulation -> suppress shedding\n    if sim.nt == 1\n\n        # Identify blade elements on which to suppress shedding\n        for i in 1:vlm.get_m(rotor)\n            HS = vlm.getHorseshoe(rotor, i)\n            CP = HS[5]\n\n            if uns.vlm.norm(CP - vlm._get_O(rotor)) <= no_shedding_Rthreshold*R\n                push!(omit_shedding, i)\n            end\n        end\n    end\n\n    # Case: sufficient time steps -> enable shedding\n    if sim.nt == no_shedding_nstepsthreshold\n\n        # Flag to stop suppressing\n        omit_shedding .= -1\n\n    end\n\n    return false\nend\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate rotor\nrotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                        n=n, CW=CW, blade_r=r,\n                                        altReD=[RPM, J, mu/rho],\n                                        xfoil=xfoil,\n                                        read_polar=read_polar,\n                                        data_path=data_path,\n                                        verbose=true,\n                                        plot_disc=true\n                                        );\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Rotor\", rotor)\n\nrotors = [rotor];                           # Defining this rotor as its own system\nrotor_systems = (rotors, );                 # All systems of rotors\n\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle\n    vlm.addwing(wake_system, \"Rotor\", rotor)\nend\n\nvehicle = VehicleType(   system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = zeros(3)\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = (RPMcontrol, )                       # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n# Restart simulation\nrestart_file = nothing\n\n# NOTE: Uncomment the following line to restart a previous simulation.\n#       Point it to a particle field file (with its full path) at a specific\n#       time step, and `run_simulation` will start this simulation with the\n#       particle field found in the restart simulation.\n\n# restart_file = \"/path/to/a/previous/simulation/rotorhover-example_pfield.360\"\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\n# Generate rotor monitor\nmonitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                            t_scale=RPM/60,        # Scaling factor for time in plots\n                                            t_lbl=\"Revolutions\",   # Label for time axis\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"rotor monitor\",\n                                            )\n\n# Generate monitor of flow enstrophy (numerical stability)\nmonitor_enstrophy = uns.generate_monitor_enstrophy(;\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"enstrophy monitor\"\n                                            )\n\n# Generate monitor of SFS model coefficient Cd\nmonitor_Cd = uns.generate_monitor_Cd(;\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"Cd monitor\"\n                                            )\n# Concatenate monitors\nmonitors = uns.concatenate(monitor_rotor, monitor_enstrophy, monitor_Cd)\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\n# Concatenate monitors and wake treatment procedure into one runtime function\nruntime_function = uns.concatenate(monitors, wake_treatment_supress)\n\n# Run simulation\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho, mu=mu, sound_spd=speedofsound,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    vpm_integration=vpm_integration,\n                    vpm_viscous=vpm_viscous,\n                    vpm_SFS=vpm_SFS,\n                    sigma_vlm_surf=sigma_rotor_surf,\n                    sigma_rotor_surf=sigma_rotor_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    sigmafactor_vpmonvlm=sigmafactor_vpmonvlm,\n                    vlm_rlx=vlm_rlx,\n                    hubtiploss_correction=hubtiploss_correction,\n                    shed_starting=shed_starting,\n                    shed_unsteady=shed_unsteady,\n                    unsteady_shedcrit=unsteady_shedcrit,\n                    omit_shedding=omit_shedding,\n                    extra_runtime_function=runtime_function,\n                    # ----- RESTART OPTIONS -----------------\n                    restart_vpmfile=restart_file,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    save_wopwopin=true,  # <--- Generates input files for PSU-WOPWOP noise analysis\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_pfield...xmf;\")\n    for bi in 1:B\n        global files\n        files *= run_name*\"_Rotor_Blade$(bi)_loft...vtk;\"\n        files *= run_name*\"_Rotor_Blade$(bi)_vlm...vtk;\"\n    end\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Mid-low fidelity runtime: ~7 minutes on a 16-core AMD EPYC 7302 processor. <br>\n    Mid-high fidelity runtime: ~60 minutes on a 16-core AMD EPYC 7302 processor. <br>\n    High fidelity runtime: ~30 hours on a 16-core AMD EPYC 7302 processor.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Rotor monitor in the high-fidelity case:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotor_convergence.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"As the simulation runs, you will see the monitor shown below plotting the global enstrophy of the flow. The global enstrophy achieves a steady state once the rate of enstrophy produced by the rotor eventually balances out with the forward scatter of the SFS turbulence model, making the simulation indefinitely stable.","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotorenstrophy.png\" alt=\"Pic here\" style=\"width:50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"The SFS model uses a dynamic procedure to compute its own model coefficient C_d as the simulation evolves. The value of the model coefficient varies for each particle in space and time. The C_d-monitor shown below plots the mean value from all the particle in the field that have a non-zero C_d (left), and also the ratio of the number of particles that got clipped to a zero C_d over the total number of particles (right).","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotorChistory.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"info: Prescribing the Model Coefficient\nThe SFS model helps the simulation to more accurately capture the effects of turbulence from the scales that are not resolved, but it adds computational cost. The following table summarizes the cost of the rVPM, the SFS model, and the C_d dynamic procedure. (Image: pic) The dynamic procedure is the most costly operation, which increases the simulation runtime by about 35%.If you need to run a case multiple times with only slight changes (e.g., sweeping the AOA and/or RPM), you can first run the simulation with the dynamic procedure (vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter), take note of what the mean C_d shown in the monitor converges to, and then prescribe that value to subsequent simulations. Prescribing C_d ends up in a simulation that is only 8% slower than the classic VPM without any SFS model.C_d can then be prescribed as followsvpm_SFS = vpm.ConstantSFS(vpm.Estr_fmm; Cs=value, clippings=[vpm.clipping_backscatter])where CS = value is the value to prescribe for the model coefficient, and clippings=[vpm.clipping_backscatter] clips the backscatter of enstrophy (making it a purely diffusive model). As a reference, in this hover case, C_d converges to 026 in the high-fidelity simulation.","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"In examples/rotorhover/rotorhover_postprocessing.jl we show how to postprocess the simulations to compare C_T and blade loading to experimental data by Zawodny et al.[1] and a URANS simulation (STAR-CCM+) by Schenk[2]:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-CTcomparison.png\" alt=\"Pic here\" style=\"width:75%;\"/>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-loadingcomparison.png\" alt=\"Pic here\" style=\"width:75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":" C_T Error\nExperimental 0.072 –\nURANS 0.071 1%\nrVPM – high fidelity 0.073 1%\nrVPM – mid-high fidelity 0.066 8%\nrVPM – mid-low fidelity 0.064 11%\nBEMT (quasi-steady) 0.073 2%","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"[1]: N. S. Zawodny, D. D. Boyd, Jr., and C. L. Burley, “Acoustic Characterization and Prediction of Representative, Small-scale Rotary-wing Unmanned Aircraft System Components,” in 72nd American Helicopter Society (AHS) Annual Forum (2016).","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"[2]: A. R. Schenk, \"Computational Investigation of the Effects of Rotor-on-Rotor Interactions on Thrust and Noise,\" Masters thesis, Brigham Young University (2020).","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"info: Hub/Tip Loss Correction\nIn the rotor actuator line model, hub and tip corrections can be applied to c_ell to account for the effects that bring the aerodynamic loading to zero at the hub and tips. These correction factors, F_mathrmtip and F_mathrmhub, are defined as modified Prandtl loss functions,beginalign*\n    F_mathrmtip\n =\n    frac2pi cos^-1 left( expleft( -f_mathrmtip right) right)\n qquad\n    f_mathrmtip\n=\n    fracB2\n    frac\n        left  left( fracR_mathrmrotorr right)^t_1 - 1  right^t_2\n    \n        vert sin left( theta_mathrmeff right) vert^t_3\n    \n\n    F_mathrmhub\n =\n    frac2pi cos^-1 left( expleft( -f_mathrmhub right) right)\n qquad\n    f_mathrmhub\n=\n    fracB2\n    frac\n        left  left( fracrR_mathrmhub right)^h_1 - 1  right^h_2\n    \n        vert sin left( theta_mathrmeff right) vert^h_3\n    \nendalign*where R_mathrmrotor and R_mathrmhub are the rotor and hub radii, B is the number of blades, r is the radial position of the blade element, and t_1, t_2, t_3, h_1, h_2, and h_3 are tunable parameters. The normal and tangential force coefficients, respectively c_n and c_t, are then calculated asbeginalign*\n    c_n\n =\n    F_mathrmtip F_mathrmhub c_ellcostheta_mathrmeff + c_dsintheta_mathrmeff\n\n    c_t\n =\n    F_mathrmtip F_mathrmhub c_ellsintheta_mathrmeff - c_dcostheta_mathrmeff\nendalign*The hub and tip corrections are passed to uns.run_simulation through the keyword argument hubtiploss_correction = ((t1, t2, t3, tminangle), (h1, h2, h3, hminangle)), where tminangle and hminangle are clipping thresholds for the minimum allowable value of verttheta_mathrmeffvert (in degs) that is used in tip and hub corrections. The following corrections are predefined in FLOWVLM for the user:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"import FLOWVLM as vlm\n\n# No corrections\nvlm.hubtiploss_nocorrection","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"import FLOWUnsteady: vlm            # hide\n\n# Original Prandtl corrections\nvlm.hubtiploss_correction_prandtl","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"import FLOWUnsteady: vlm            # hide\n\n# Modified Prandtl with a strong hub correction\nvlm.hubtiploss_correction_modprandtl","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"info: ParaView Visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"api/flowunsteady-simulation/#(3)-Simulation-Definition","page":"(3) Simulation Definition","title":"(3) Simulation Definition","text":"","category":"section"},{"location":"api/flowunsteady-simulation/","page":"(3) Simulation Definition","title":"(3) Simulation Definition","text":"FLOWUnsteady.Simulation\nFLOWUnsteady.save_vtk","category":"page"},{"location":"api/flowunsteady-simulation/#FLOWUnsteady.Simulation","page":"(3) Simulation Definition","title":"FLOWUnsteady.Simulation","text":"Simulation{V<:AbstractVehicle, M<:AbstractManeuver, R<:Real}(vehicle::V,\n                        maneuver::M, Vref::R, RPMref::R, ttot::R, optargs...)\n\nSimulation interface. This type carries the simulation's options and connects vehicle and maneuver together.\n\nARGUMENTS\n\nvehicle                 : Vehicle\nmaneuver                : Maneuver\nVref                    : Reference velocity for the maneuver\nRPMref                  : Reference RPM for the maneuver\nttot                    : Total time in which to perform the maneuver\n\nOPTIONAL ARGUMENTS\n\nVinit = zeros(3)        : Initial vehicle velocity\nWinit = zeros(3)        : Initial vehicle angular velocity\n\nState variables\n\nt::Real                 : Time of current step\nnt::Int                 : Current time step number\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-simulation/#FLOWUnsteady.save_vtk","page":"(3) Simulation Definition","title":"FLOWUnsteady.save_vtk","text":"save_vtk(self::AbstractVehicle, prefix; path=\"\", optargs...)\n\nOutput VTK files with vehicle geometry and solution fields.\n\n\n\n\n\nsave_vtk(sim::Simulation, prefix; path=\"\", save_wopwopin=false, optargs...)\n\nOutput VTK files with vehicle geometry and solution fields. The file names will have the prefix prefix, and will be saved in the directory path. If save_wopwopin=true, it will also generate PSU-WOPWOP input files that can be used to run the acoustic analysis (see run_noise_wopwop).\n\n\n\n\n\n","category":"function"},{"location":"theory/rvpm/#Reformulated-VPM","page":"Reformulated VPM","title":"Reformulated VPM","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The following is an excerpt from  E. J. Alvarez & A. Ning (2022), \"Meshless Large Eddy Simulation of Rotor-Wing Interactions Through the Reformulated Vortex Particle Method,\" (in review).","category":"page"},{"location":"theory/rvpm/#Vorticity-Navier-Stokes","page":"Reformulated VPM","title":"Vorticity Navier-Stokes","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In recent work[1][2], a new formulation of the vortex particle method (VPM) has been derived from the LES-filtered Navier-Stokes equations. The new method, referred to as the reformulated VPM or rVPM, is an LES that is both numerically stable and meshless, and is able to accurately resolve mean and fluctuating large-scale features of turbulent flow with minimal computational effort. Hereby we concisely summarize the governing equations of the reformulated VPM, and the reader is referred to Ref.[1] and the doctoral dissertation[2] accompanying this work for a detailed derivation of the method.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The reformulated VPM uses a Lagrangian scheme to solve the vorticity form of the LES-filtered Navier-Stokes equations","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n        fracpartial overline omega_i partial t\n        + overline u_j  fracpartial overline omega_i partial x_j\n     =\n        overline omega_j  fracpartial overline u_i partial x_j\n    +\n        nu nabla^2 overline omega_i  -\n        fracpartial T_ijpartial x_j +\n        fracpartial T_ijpartial x_j\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where the bar denotes the filter operator,[a] and T_ij equiv overline u_i omega_j  - overline u_i   overline omega_j  is the subfilter-scale (SFS) vorticity stress capturing the interactions between large-scale dynamics and SFS dynamics. The term fracpartial T_ijpartial x_j represents the SFS contributions arising from the advective term (vorticity advection), while fracpartial T_ijpartial x_j represents the contributions arising from vortex stretching. For simplicity, Eq. (1) is written in vector notation as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n    fractextd textd t overline boldsymbolomega \n    = left( overline boldsymbolomega  cdot nabla right) overline mathbfu  +\n    nu nabla^2 overline boldsymbolomega \n    - mathbfE_mathrmadv - mathbfE_mathrmstr\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where left( mathbfE_mathrmadv right)_i equiv fracpartial T_ijpartial x_j is the SFS vorticity advection, left( mathbfE_mathrmstr right)_i equiv - fracpartial T_ijpartial x_j is the SFS vortex stretching, and the fractextd textd t operator is the linearized version of the filtered material derivative, fractextd textd t () equiv fracpartial partial t() + (overline bf u  cdot nabla)(). Notice that casting the Navier-Stokes equation into this vorticity form gets rid of all dependance on pressure. Furthermore, this equation depends on boldsymbolomega alone since bfu can be calculated directly from boldsymbolomega = nabla times bfu through the Biot-Savart law.","category":"page"},{"location":"theory/rvpm/#particlediscretization","page":"Reformulated VPM","title":"Particle Discretization","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The material derivative in Eq. (2) and the material-conservative nature of the vorticity makes the boldsymbolomega field especially well fit for a Lagrangian description. The unfiltered boldsymbolomega field is discretized with singular vortex particles of positions bf x_p and coefficients boldsymbolGamma_p (called vortex strength), approximating boldsymbolomega as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign  labeleqparticledirac\n    boldsymbolomega(bf xt) approx sum\n        limits_p boldsymbolGamma_p (t)\n            delta  (bf x - bf x_p(t))\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where delta is the Dirac delta. Applying the filter operator,","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overline boldsymbolomega  left( mathbfx right)\n     =\n        intlimits_-infty^infty\n            boldsymbolomegaleft( mathbfy right)\n            zeta_sigma(mathbfx-mathbfy)\n        mathrmdmathbfy\n      \n    approx\n        intlimits_-infty^infty\n            left(\n                sumlimits_p\n                    boldsymbolGamma_p\n                    delta (textbf y - textbf x_p)\n            right)\n            zeta_sigma(mathbfx-mathbfy)\n        mathrmdmathbfy\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"the Dirac delta collapses the integral, obtaining an approximation of the filtered vorticity field as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign  labeleqparticleblob\n        overlineboldsymbolomegaleft( mathbfxt right)\n     approx\n        sumlimits_p\n            boldsymbolGamma_p (t)\n            zeta_sigma_p(mathbfx-mathbfx_p(t))\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where zeta_sigma(mathbfx) equiv frac1sigma^3 zeta left(fracVert mathbfx Vertsigma right) is the filter kernel of width sigma and radial basis zeta. As seen in Eq. (4), the filter operator has the effect of spreading the vortex strength boldsymbolGamma_p in space, regularizing the singularity originally introduced by the Dirac delta. Thus, the filter kernel takes the role of a basis function that is used to discretize overlineboldsymbolomega through particles. We let the filter width sigma (here on called smoothing radius or core size) change in time and space according to the evolution of each individual particle. The particle field constructs a continuous vorticity field through radial basis functions as given by Eq. (4), and also a continuous velocity field by inverting the relation overlineboldsymbolomega = nabla times overlinemathbfu as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign  labeleqUreg\n        overline mathbfu left( mathbfx right)\n    =\n        - frac14pisumlimits_p g_sigma_pleft( mathbfx-mathbfx_p right)\n            fracmathbfx-mathbfx_pVertmathbfx-mathbfx_pVert^3\n            times\n            boldsymbolGamma_p\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where g_sigma is the regularizing function[3] associated with the filter kernel zeta_sigma. Hence, all fluid properties—like overlinemathbfu and its spatial derivatives—are continuous and can be computed analytically.","category":"page"},{"location":"theory/rvpm/#Governing-Equations","page":"Reformulated VPM","title":"Governing Equations","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"Similar to the process that led from Eq. (3) to Eq. (4), we use singular particles to discretize the LES-filtered vorticity equation given in Eq. (2), and arrive to the governing equations of the reformulated VPM:","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n     labeleqrvpmgedxdt\n     bullet quad\n    \n        fractextdtextdtbf x_p\n        =\n        overlinemathbfu(bf x_p)\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n       labeleqrvpmgedGammadt\n    beginsplit\n         bullet quad\n         fracmathrmd mathrmd t boldsymbolGamma_p\n        =\n            left(\n                boldsymbolGamma_p cdot nabla\n            right)\n            overlinemathbfu (bf x_p)\n            -\n            fracg + ffrac13 + f\n            left\n                left\n                    left(\n                            boldsymbolGamma_p  cdot nabla\n                        right)\n                        overlinemathbfu small (bf x_p)\n                right\n                cdot hatboldsymbolGamma_p\n            right hatboldsymbolGamma_p\n        \n         qquad qquad \n        qquad qquad quad \n            - fracC_dzeta_sigma_p (bf 0)\n            left\n                mathbfE_mathrmstr (bf x_p)\n                -\n                fracffrac13 + f\n                left(\n                    mathbfE_mathrmstr (bf x_p) cdot hatboldsymbolGamma_p\n                right) hatboldsymbolGamma_p\n            right\n    endsplit\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n       labeleqrvpmgedsigmadt\n     bullet quad\n    \n        fracmathrmd mathrmd t sigma_p\n        =\n        - left(\n            fracg + f1 + 3f\n        right)\n        fracsigma_pVert boldsymbolGamma_p Vert\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overlinemathbfu small (bf x_p)\n            right\n            cdot hatboldsymbolGamma_p\n        +\n        left(\n            fracf1 + 3f\n        right)\n        fracsigma_pVert boldsymbolGamma_p Vert\n        fracC_dzeta_sigma_p (bf 0)\n        mathbfE_mathrmstr (bf x_p) cdot hatboldsymbolGamma_p\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n       labeleqrvpmgeviscous\n     bullet quad\n    \n        left(\n            fractextd textd t overline boldsymbolomega \n        right)_mathrmviscous\n        =\n        nu nabla^2 overline boldsymbolomega \nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where Eq. (6) resolves vorticity advection by convecting the particles, Eq. (7) governs the evolution of vortex strength, and Eq. (8) governs the evolution of particle size. Eq. (7) in conjunction with Eqs. (6) and (8) resolve the inviscid part of the LES-filtered vorticity Navier-Stokes equation, while the viscous part in Eq. (9) can be resolved through any of the schemes previously proposed in the literature (e.g., vortex redistribution method, particle strength exchange, or core spreading).","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The main headway of the reformulated VPM over the classic VPM is that rVPM uses the particle size, or fracmathrmd mathrmd t sigma_p, as an extra degree of freedom to reinforce conservation laws. As shown in References [1] and [2], momentum and mass conservation leads to f = 0 and g = frac15, and Eqs. (7) and (8) become","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n     bullet quad\n     fracmathrmd mathrmd t boldsymbolGamma_p\n    =\n        left(\n            boldsymbolGamma_p cdot nabla\n        right)\n        overline mathbfu  (mathbfx_p)\n        -\n        frac35\n        left\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overline mathbfu  small (mathbfx_p)\n            right\n            cdot hatboldsymbolGamma_p\n        right hatboldsymbolGamma_p\n        - fracC_dzeta_sigma_p (mathbf0)\n            mathbfE_mathrmstr (mathbfx_p)\n    \n     bullet quad\n    \n        fracmathrmd mathrmd t sigma_p\n        =\n        -\n        frac15\n        fracsigma_pVert boldsymbolGamma_p Vert\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overline mathbfu  small (mathbfx_p)\n            right\n            cdot hatboldsymbolGamma_p\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"which is the formulation referred to as the \"reformulated VPM.\" Notice that when f = g = 0 and mathbfE_mathrmstr is neglected, Eqs. (7) and (8) collapse back to the classic VPM equations, making these equations a generalization of the classic method. In Reference [2] is shown that the classic VPM turns out to violate both conservation of momentum and mass when it assumes fracmathrmd mathrmd t sigma_p = 0, which explains the tendency of the classic VPM to be numerically unstable. Furthermore, notice that the rVPM equations do not require more computation than the classic VPM: when SFS effects are neglected (mathbfE_mathrmstr=0), both fracmathrmd sigma_p mathrmdt and fracmathrmd boldsymbolGamma_pmathrmd t are calculated directly and solely from vortex stretching, left( boldsymbolGamma_p cdot nabla  right) overlinemathbfu (bf x_p).","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"For an in-depth derivation of the rVPM governing equations, see Chapters 1 and 2 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/#sfsmodel","page":"Reformulated VPM","title":"Turbulence Model","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"Turning our attention back to the SFS stress tensor T_ij, the accuracy of LES hinges on the modeling of this tensor. Its divergence represents the rate at which enstrophy—a measure of rotational kinetic energy—is transferred from resolved scales to subfilter scales (diffusion) and from subfilter scales to resolved scales (backscatter). In vortex methods, the most common SFS models use variants of the Smagorinsky eddy-viscosity model formulated for the vorticity stress.[4][5] However, these models are developed on the basis of homogeneous isotropic turbulence, which makes them overly diffusive in simulations with coherent vortical structures. In Reference [1], the following anisotropic model of SFS vortex stretching is proposed:","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*  labeleqEstr\n        mathbfE_mathrmstr left( mathbfx right)\n    approx\n        sumlimits_q\n            zeta_sigma(mathbfx-mathbfx_q)\n            left(\n                boldsymbolGamma_q cdot nabla\n            right)\n            left(\n                overlinemathbfu left( mathbfx right) - overlinemathbfu left( mathbfx_q right)\n            right)\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The model coefficient C_d is calculated dynamically at the position of every particle as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*  labeleqCdGammaMLave\n        C_d\n    =\n        frac\n            left boldsymbolGamma_p cdot mathbfL right\n        \n            left boldsymbolGamma_p cdot mathbfm right\n        \nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where left cdot right denotes an integration along Lagrangian trajectories[6], and","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n    \n        mathbfm =\n            fracsigma^3zeta(0) fracpartial mathbfE_mathrmstr partial sigma (mathbfx_p)\n    \n    \n        mathbfL =\n            frac3sigma\n            left( boldsymbolGamma_p cdot nabla right)\n            left(\n                mathbfu (mathbfx_p) - overlinemathbfu (mathbfx_p)\n            right)\n            +\n            left( boldsymbolGamma_p cdot nabla right)\n            fracpartial overlinemathbfu partial sigma  (mathbfx_p)\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"This dynamic procedure is based on a simultaneous balance of enstrophy-production and derivatives between true and modeled SFS contributions. Backscatter is controlled by clipping the model coefficient to C_d=0 whenever the condition C_d boldsymbolGamma_p cdot mathbfE_mathrmstr (mathbfx_p) geq 0 is not satisfied. This results in a low-dissipation SFS model that uses vortex stretching as the physical mechanism for turbulence, which is well suited for flows with coherent vortical structures where the predominant cascade mechanism is vortex stretching.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"For an in-depth derivation of the SFS model, see Chapter 3 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/#Immersed-Vorticity","page":"Reformulated VPM","title":"Immersed Vorticity","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In order to immerse the vorticity of solid boundaries into the LES-filtered Navier-Stokes equations, the filtered vorticity field overlineboldsymbolomega(mathbfx t) is decomposed into a free-vorticity field overlineboldsymbolomega_mathrmfree(mathbfx t) and a bound-vorticity field overlineboldsymbolomega_mathrmbound(mathbfx t) as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overlineboldsymbolomega\n    =\n        overlineboldsymbolomega_mathrmfree + overlineboldsymbolomega_mathrmbound\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"Both components can be discretized with vortex particles as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overlineboldsymbolomega (mathbfx)\n    =\n        underbrace\n            sumlimits_p boldsymbolGamma_p zeta_sigma_p left( mathbfx - mathbfx_p right)\n        _overlineboldsymbolomega_mathrmfree\n        +\n        underbrace\n            sumlimits_b boldsymbolGamma_b zeta_sigma_b left( mathbfx - mathbfx_b right)\n        _overlineboldsymbolomega_mathrmbound\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where the particles discretizing the free-vorticity field evolve according to the rVPM governing equations, Eqs. (6) through (9), while the ones discretizing the bound-vorticity are embedded on the solid boundaries and their strength is calculated by actuator models derived in Alvarez' Dissertation,[2] Chapter 6. The velocity field is obtained by inverting the relation boldsymbolomega = nabla times mathbfu, resulting in","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overline mathbfu left( mathbfx right)\n    =\n        underbrace\n            sumlimits_p g_sigma_pleft( mathbfx-mathbfx_p right)\n                mathbfKleft( mathbfx-mathbfx_p right)\n                times\n                boldsymbolGamma_p\n        _overlinemathbfu_mathrmfree\n        +\n        underbrace\n            sumlimits_b g_sigma_bleft( mathbfx-mathbfx_b right)\n                mathbfKleft( mathbfx-mathbfx_b right)\n                times\n                boldsymbolGamma_b\n        _overlinemathbfu_mathrmbound\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"which includes the velocity induced by both free and bound vorticity components, and where mathbfKleft( mathbfx right) equiv - frac14pi fracmathbfxVertmathbfxVert^3. Thus, the evolution of the free particles is influenced by the vorticity immersed at the solid boundaries, affecting their convection and vortex stretching through the velocity field induced by the bound particles.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The immersed vorticity not only affects the evolution of existing free vorticity, but it also creates new free vorticity at the boundary through viscous diffusion. In reality, vorticity is created in the boundary layer, it builds up as it travels along the surface, and it is eventually shed off the surface either by the Kutta condition at the trailing edge, flow separation, or other turbulent mechanisms. On a slender body, the vorticity can be assumed to be shed at the trailing edge.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In most models inside FLOWUnsteady, instead of creating vorticity through the viscous diffusion equation, the immersed vorticity is shed along a prescribed trailing edge. This approach neglects the wake created by flow separation. However, the effects of flow separation on loading (like the drop in lift and increase in pressure drag on a stalled airfoil) can still be captured whenever lookup airfoil tables are used.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"compat: Recommended\nFor an in-depth discussion of the actuator line and surface models implemented in FLOWUnsteady, see Chapter 6 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/#Other-Schemes","page":"Reformulated VPM","title":"Other Schemes","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In the default settings of FLOWUnsteady, vortex stretching is resolved with the transposed scheme and the divergence of the vorticity field is treated through the relaxation scheme developed by Pedrizzeti.[7] The time integration of the governing equations is done through a low-storage third-order Runge-Kutta scheme. A Gaussian kernel is used as the LES filter zeta_sigma (or VPM radial basis function). Like the classic VPM, the reformulated VPM is spatially second-order accurate in the convective term when a Gaussian basis is used. Viscous diffusion is solved through the core spreading method coupled with the radial basis function interpolation approach for spatial adaptation developed by Barba.[8] This viscous scheme has second-order spatial convergence, while showing linear convergence when coupled with spatial adaptation. The fast multipole method (FMM) is used for the computation of the regularized Biot-Savart law, approximating the velocity field and vortex stretching through spherical harmonics with computational complexity mathcalO(N), where N is the number of particles. The FMM computation of vortex stretching is performed through an efficient complex-step derivative approximation,[9] implemented in a modified version of the open-source, parallelized code ExaFMM. FLOWVPM and FLOWUnsteady are implemented in the Julia language, which is a modern, high-level, dynamic programming language for high-performance computing.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"compat: Recommended\nFor an in-depth discussion of the numerical schemes implemented in FLOWUnsteady, see Chapter 4 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[1]: E. J. Alvarez & A. Ning (2022), \"Reviving the Vortex Particle Method: A Stable Formulation for Meshless Large Eddy Simulation,\" (in review). [PDF]","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[2]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [VIDEO] [PDF]","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[3]: Winckelmans, G., and Leonard, A., “Contributions to Vortex Particle Methods for the Computation of Three-Dimensional Incompressible Unsteady Flows,” Journal of Computational Physics, Vol. 109, No. 2, 1993.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[4]: Winckelmans, G. S., “Some progress in large-eddy simulation using the 3D vortex particle method,” CTR Annual Research Briefs, , No. 2, 1995, pp. 391–415.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[5]: Mansfield, J. R., Knio, O. M., and Meneveau, C., “A Dynamic LES Scheme for the Vorticity Transport Equation: Formulation and a Priori Tests,” Journal of Computational Physics, Vol. 145, No. 2, 1998, pp. 693–730.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[6]: Meneveau, C., Lund, T. S., and Cabot, W. H., “A Lagrangian dynamic subgrid-scale model of turbulence,” Journal of Fluid Mechanics, Vol. 319, No. -1, 1996, p. 353.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[7]: Pedrizzetti, G., “Insight into singular vortex flows,” Fluid Dynamics Research, Vol. 10, No. 2, 1992, pp. 101–115.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[8]: Barba, L. A., Leonard, A., and Allen, C. B., “Advances in viscous vortex methods - Meshless spatial adaption based on radial basis function interpolation,” International Journal for Numerical Methods in Fluids, Vol. 47, No. 5, 2005, pp. 387–421. Also, Barba, L. A., “Vortex Method for computing high-Reynolds number Flows: Increased accuracy with a fully mesh-less formulation,” California Institute of Technology, Vol. 2004, 2004.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[9]: Alvarez, E. J., and Ning, A., “High-Fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design,” AIAA Journal, Vol. 58, No. 10, 2020, pp. 4385–4400.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[a]: Let phi be a field and zeta_sigma a filter kernel with cutoff length sigma, the filter operator is defined as overlinephi left( mathbfx right) equiv intlimits_-infty^infty phi(mathbfy)zeta_sigma(mathbfx-mathbfy) mathrmdmathbfy.","category":"page"},{"location":"examples/blownwing-asm/#asm","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"","category":"section"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"The aerodynamic solution computed in the first section was intended to be a mid-low fidelity simulation, which modeled the wing using an actuator line model (ALM). The ALM places all the surface vorticity associated with lift at the quarter chord of the wing, while placing all the trailing bound vorticity at the three-quarter chord, as shown here:","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//alm00.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"The ALM is very accurate for isolated wings and even cases with mild wake interactions. However, for cases with stronger wake interactions (e.g., a wake directly impinging on the wing surface), the ALM can lead to unphysical results as the flow tends to cross the airfoil centerline. To address this, we have developed an actuator surface model (ASM) to embed the wing surface in the LES domain and better represent the physics.","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"The ASM spreads the surface vorticity following a pressure-like distribution. This produces a velocity field at the wing surface that minimizes the mass flow that crosses the airfoil centerline, thus better representing a solid surface:","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//asm00.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//asm01.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"For an in-depth discussion of the actuator models implemented in FLOWUnsteady, see Chapter 6 in Alvarez' Dissertation[2] (also published in Alvarez & Ning, 2023[3]).","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"[2]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [VIDEO] [PDF]","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"[3]: E. J. Alvarez and A. Ning (2023), \"Meshless Large-Eddy Simulation of Propeller–Wing Interactions with Reformulated Vortex Particle Method,\" Journal of Aircraft. [DOI][PDF]","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"In order to activate the actuator surface model, we define the following parameters:","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"thickness_w     = 0.15                      # Wing airfoil thickness t/c\n\n# ---------- Vortex sheet parameters ---------------\nvlm_vortexsheet = true                      # Whether to spread the wing circulation as a vortex sheet\nvlm_vortexsheet_overlap = 2.125             # Overlap of the particles that make the vortex sheet\nvlm_vortexsheet_distribution = uns.g_pressure   # Distribution of the vortex sheet\n\nsigma_vlm_surf  = b/100         # Smoothing radius of lifting bound vorticity\nvlm_vortexsheet_sigma_tbv = thickness_w*(b/ar) / 100 # Smoothing radius of trailing bound vorticity\n\nvlm_vortexsheet_maxstaticparticle = 1000000 # How many particles to preallocate for the vortex sheet\n\n\n# ---------- Force calculation parameters ----------\nKJforce_type                = \"regular\"     # KJ force evaluated at middle of bound vortices\n# KJforce_type              = \"averaged\"  # KJ force evaluated at average vortex sheet\n# KJforce_type              = \"weighted\"  # KJ force evaluated at strength-weighted vortex sheet\n\ninclude_trailingboundvortex = false         # Include trailing bound vortices in force calculations\n\ninclude_freevortices        = false         # Include free vortices in force calculation\ninclude_freevortices_TBVs   = false         # Include trailing bound vortex in free-vortex force\n\ninclude_unsteadyforce       = true          # Include unsteady force\nadd_unsteadyforce           = false         # Whether to add the unsteady force to Ftot or to simply output it\n\ninclude_parasiticdrag       = true          # Include parasitic-drag force\nadd_skinfriction            = true          # If false, the parasitic drag is purely form, meaning no skin friction\ncalc_cd_from_cl             = false         # Whether to calculate cd from cl or effective AOA\nwing_polar_file             = \"xf-rae101-il-1000000.csv\"    # Airfoil polar for parasitic drag","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"Then we use a custom-defined function for calculating aerodynamic forces that uses the vortex sheet:","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"# ---------- Aerodynamic forces --------------\n\nforces = []\n\n# Calculate Kutta-Joukowski force\nkuttajoukowski = uns.generate_aerodynamicforce_kuttajoukowski(KJforce_type,\n                                sigma_vlm_surf, sigma_rotor_surf,\n                                vlm_vortexsheet, vlm_vortexsheet_overlap,\n                                vlm_vortexsheet_distribution,\n                                vlm_vortexsheet_sigma_tbv;\n                                vehicle=vehicle)\npush!(forces, kuttajoukowski)\n\n# Free-vortex force\nif include_freevortices\n    freevortices = uns.generate_calc_aerodynamicforce_freevortices(\n                                            vlm_vortexsheet_maxstaticparticle,\n                                            sigma_vlm_surf,\n                                            vlm_vortexsheet,\n                                            vlm_vortexsheet_overlap,\n                                            vlm_vortexsheet_distribution,\n                                            vlm_vortexsheet_sigma_tbv;\n                                            Ffv=uns.Ffv_direct,\n                                            include_TBVs=include_freevortices_TBVs\n                                            )\n    push!(forces, freevortices)\nend\n\n# Force due to unsteady circulation\nif include_unsteadyforce\n    unsteady(args...; optargs...) = uns.calc_aerodynamicforce_unsteady(args...; add_to_Ftot=add_unsteadyforce, optargs...)\n\n    push!(forces, unsteady)\nend\n\n# Parasatic-drag force (form drag and skin friction)\nif include_parasiticdrag\n    parasiticdrag = uns.generate_aerodynamicforce_parasiticdrag(wing_polar_file;\n                                                            read_path=joinpath(data_path, \"airfoils\"),\n                                                            calc_cd_from_cl=calc_cd_from_cl,\n                                                            add_skinfriction=add_skinfriction,\n                                                            Mach=speedofsound!=nothing ? magVref/speedofsound : nothing)\n    push!(forces, parasiticdrag)\nend\n\n\n# Stitch all the forces into one function\nfunction calc_aerodynamicforce_fun(vlm_system, args...; per_unit_span=false, optargs...)\n\n    # Delete any previous force field\n    fieldname = per_unit_span ? \"ftot\" : \"Ftot\"\n    if fieldname in keys(vlm_system.sol)\n        pop!(vlm_system.sol, fieldname)\n    end\n\n    Ftot = nothing\n\n    for (fi, force) in enumerate(forces)\n        Ftot = force(vlm_system, args...; per_unit_span=per_unit_span, optargs...)\n    end\n\n    return Ftot\nend","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"This custom-defined force needs to be passed to uns.generate_monitor_wing:","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"monitor_wing = uns.generate_monitor_wing(   ...\n                                            include_trailingboundvortex=include_trailingboundvortex,\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            ...\n                                            )","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"Finally, pass the following keyword arguments to uns.run_simulation:","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"# ------------- 5) RUN SIMULATION ------------------------------------------\nuns.run_simulation( ...\n                    vlm_vortexsheet=vlm_vortexsheet,\n                    vlm_vortexsheet_overlap=vlm_vortexsheet_overlap,\n                    vlm_vortexsheet_distribution=vlm_vortexsheet_distribution,\n                    vlm_vortexsheet_sigma_tbv=vlm_vortexsheet_sigma_tbv,\n                    max_static_particles=vlm_vortexsheet_maxstaticparticle\n                    ...\n                    )","category":"page"},{"location":"examples/blownwing-asm/","page":"Actuator Surface Model","title":"Actuator Surface Model","text":"info: ASM Example\nThe next section shows an example on how to set up and run a simulation using the actuator surface model.","category":"page"},{"location":"api/flowunsteady-openvsp/#openvsp_import","page":"OpenVSP geometry","title":"OpenVSP geometry","text":"","category":"section"},{"location":"api/flowunsteady-openvsp/","page":"OpenVSP geometry","title":"OpenVSP geometry","text":"FLOWUnsteady.read_degengeom\nFLOWUnsteady.import_vsp","category":"page"},{"location":"api/flowunsteady-openvsp/#FLOWUnsteady.read_degengeom","page":"OpenVSP geometry","title":"FLOWUnsteady.read_degengeom","text":"`read_degengeom(filename::String)`\n\nRead all geometry components from a DegenGeom file written out by OpenVSP\n\nArguments\n\nfilename::String: DegenGeom filename\n\nReturns\n\ncomp: Vector of vsp.VSPComponent objects\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-openvsp/#FLOWUnsteady.import_vsp","page":"OpenVSP geometry","title":"FLOWUnsteady.import_vsp","text":"`import_vsp(comp::vsp.VSPComponent; geomType::String=\"\",\n            flip_y::Bool=false, transpose_grid::Bool=false)`\n\nImports properties from OpenVSP component to FLOWUnsteady objects. Importing prop and duct geometries are under development.\n\nArguments\n\ncomp::vsp.VSPComponent: Single vsp.VSPComponent object\ngeomType::String : Geometry type may be one of - wing, fuselage, prop, duct\nsymmetric::Bool : Creates a symmetric wing using the semi-span coordinates\nflip_y::Bool : Flip y-coordinates about longitudinal plane. Useful for symmetric geometry\ntranspose_grid::Bool : Swap ordering of grid points\n\nReturns\n\ngeom: FLOWUnsteady geometry\n\n\n\n\n\n","category":"function"},{"location":"examples/openvsp-aircraft/#OpenVSP-Geometry","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"","category":"section"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"In this example, we import an aircraft model created in OpenVSP into the FLOWUnsteady environment. The aircraft.vsp3 file used here is available in the folder examples/aircraft-vsp/ in the FLOWUnsteady GitHub repo.","category":"page"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"After creating the aircraft geometry in OpenVSP, we write out a DegenGeom file using the tab Analysis > DegenGeom as shown below. This creates a CSV file that contains all the components of the aircraft geometry.","category":"page"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"(Image: DegenGeom)","category":"page"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"Let's import the geometry into Julia using the FLOWUnsteady.read_degengeom function and inspect it.","category":"page"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"import FLOWUnsteady as uns\n\ngeom_path = joinpath(uns.examples_path, \"aircraft-vsp\", \"aircraft.csv\")\ncomp = uns.read_degengeom(geom_path);\n\nfor i in 1:length(comp)\n  println(\"$i. $(comp[i].name)\")\nend","category":"page"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"Now that we have a good idea about the index of the components in the geometry, we can use them in FLOWUnsteady using the function FLOWUnsteady.import_vsp. The following example script imports the OpenVSP geometry, creates FLOWUnsteady data structures and writes it out to a vtk file. The geometry can be used with the FLOWUnsteady solver by following one of the previous examples.","category":"page"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"#=##############################################################################\n# DESCRIPTION\n    Import of OpenVSP geometry into FLOWUnsteady\n\n# AUTHORSHIP\n  * Author          : Cibin Joseph\n  * Email           : cibinjoseph92@gmail.com\n  * Created         : Aug 2023\n  * Last updated    : Aug 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\n\nrun_name        = \"aircraft-vsp\"            # Name of this simulation\nsave_path       = run_name                  # Where to save this simulation\n\n# Path to DegenGeom file\ngeom_path = joinpath(uns.examples_path, \"aircraft-vsp\", \"aircraft.csv\")\n\nVinf(X, t)      = [1.0, 0.0, 0.0]  # Freestream function\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Importing geometry...\")\n\n# Import VSP Components from DegenGeom file\ncomp = uns.read_degengeom(geom_path);\n\nfuselage = uns.import_vsp(comp[1])\nwingL = uns.import_vsp(comp[2])\nwingR = uns.import_vsp(comp[2]; flip_y=true)\nbasefuse = uns.import_vsp(comp[4])\nhorstabL = uns.import_vsp(comp[5])\nhorstabR = uns.import_vsp(comp[5]; flip_y=true)\nverstab = uns.import_vsp(comp[7])\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = uns.vlm.WingSystem()                   # System of all FLOWVLM objects\nuns.vlm.addwing(system, \"WingL\", wingL)\nuns.vlm.addwing(system, \"WingR\", wingR)\nuns.vlm.addwing(system, \"HorStabL\", horstabL)\nuns.vlm.addwing(system, \"HorStabR\", horstabR)\nuns.vlm.addwing(system, \"VerStab\", verstab)\n\nfuse_grid = uns.gt.MultiGrid(3)\nuns.gt.addgrid(fuse_grid, \"Fuselage\", fuselage)\n\nbasefuse_grid = uns.gt.MultiGrid(3)\nuns.gt.addgrid(basefuse_grid, \"BaseFuse\", basefuse)\n\ngrids = [fuse_grid, basefuse_grid]\n\nvlm_system = system                         # System solved through VLM solver\nwake_system = system                        # System that will shed a VPM wake\n\nvehicle = uns.VLMVehicle(   system;\n                            vlm_system=vlm_system,\n                            wake_system=wake_system,\n                            grids=grids\n                         );\n\n# ----------------- EXPORT GEOMETRY --------------------------------------------\nif isdir(save_path); rm(save_path, recursive=true, force=true); end\nmkdir(save_path)\n\nuns.vlm.setVinf(system, Vinf)\nstr = uns.save_vtk(vehicle, run_name; path=save_path)\n\n# Open up geometry in ParaView\nstr = joinpath(save_path, str)\nrun(`paraview -data=$(str)`)","category":"page"},{"location":"examples/openvsp-aircraft/","page":"OpenVSP Geometry","title":"OpenVSP Geometry","text":"(Image: Paraview)","category":"page"},{"location":"theory/convergence/#Convergence","page":"Convergence","title":"Convergence","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"The following is a compilation of convergence studies found in the literature using FLOWUnsteady.","category":"page"},{"location":"theory/convergence/#Wing-Performance","page":"Convergence","title":"Wing Performance","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: E. J. Alvarez, 2022[1]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-particles06.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-n100-00.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: 45^circ swept-back wing at an angle of attack of 42^circ. Aspect ratio of 5.0, RAE 101 airfoil section with 12% thickness, no dihedral, twist, nor taper. Freestream velocity of 497mathrmms, corresponding to a chord-based Reynolds number of 17 times 10^6. Convergence of loading distribution and integrated lift and drag as the number of wing elements is increased.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Takeaways:Resolving the wake for about 1.5 span-distances is sufficient to converge wing loading\nUsing between 100 and 200 elements fully resolves the wing loading (C_D changes by less than 1% with n_mathrmwing  100)","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<table>\n  <tr>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-conv00.png\"\n                                                        alt=\"Pic here\" style=\"width: 65%;\"/>\n    </td>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-conv01.png\"\n                                                        alt=\"Pic here\" style=\"width: 80%;\"/>\n    </td>\n  </tr>\n</table>\n\n<br>\n\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-conv02.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/#Rotor-Performance","page":"Convergence","title":"Rotor Performance","text":"","category":"section"},{"location":"theory/convergence/#APC-10x7-Propeller-Case","page":"Convergence","title":"APC 10x7 Propeller Case","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: E. J. Alvarez and A. Ning, 2020[2]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/propmodel00.png\" alt=\"Pic here\" style=\"width: 55%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: APC 10x7E propeller at an advance ratio of 0.6, tip Mach number of 0.36, and mathrmRe_c = 62 times 10^4 and mathrmRe_D = 65 times 10^5. Convergence of thrust w.r.t. the following parameters:N_mathrmsteps, number of time steps per revolution.\nN_mathrmsheds, number of particle sheds per revolution.\nlambda, core overlap between tip particles defined as lambda=fracsigmaDelta x. Also controlled with the particle smoothing factor f_sigma = sigmaR, .\nn, number of blade elements per blade.Default values: N_mathrmsteps=72, N_mathrmsheds=144, lambda=2125 (or f_sigma=0093), and n=50 as each parameter is independently varied.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Takeaways:Temporal discretization error less than 1% with N_mathrmsteps geq 72 (or time step smaller  than 5^circ)\nSpatial discretization error less than 1% with N_mathrmsheds geq 144 and n = 50.\nC_T starts to diverge as the stability threshold (lambda=1) is approached, while also diverging as f_sigma025 (equivalent to sigma larger than 025R) leads to unphysical wake dynamics caused by excessive smoothing. Since the instability associated with lambdarightarrow1 plateaus at lambdaapprox2, we recommend using lambda approx 2125 whenever possible.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apcconv00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<table>\n  <tr>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apcconv01.png\"\n                                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n    </td>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apcconv02.png\"\n                                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n    </td>\n  </tr>\n</table>\n\n<br>","category":"page"},{"location":"theory/convergence/#Wind-Turbine-Case","page":"Convergence","title":"Wind Turbine Case","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: J. Mehr, E. J. Alvarez, and A. Ning, 2022[4]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine.png\" alt=\"Pic here\" style=\"width: 45%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: Test series \"H\" from UAE study at US Department of Energy.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Takeaways:Spatio-temporal discretization error on thrust C_T is less than 1% with 72 steps per revolution (or 5^circ per step), while error on power C_P is less than 3%.\nBlade discretization error less than 0.1% with 50 blade elements per blade.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine-conv00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine-conv01.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/convergence/#Beaver-Propeller-Case","page":"Convergence","title":"Beaver Propeller Case","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: E. J. Alvarez, 2022[1], and E. J. Alvarez and A. Ning, 2023[3]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-beaver-aero01.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: Beaver propeller at an advance ratio of 0.8, tip Mach number of 0.46, and mathrmRe_07D = 18 times 10^6. Convergence of thrust, torque, and blade loading w.r.t. the following parameters:N_mathrmsheds, number of particle sheds per revolution.\nn, number of blade elements per blade.Constant parameters: N_mathrmsteps=72 and lambda=fracsigmaDelta x = fracsigma N_mathrmsheds2pi R = 2125, which leads to a decreasing sigma as N_mathrmshedsincreases.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-beaver-aero02.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-beaver-aero03.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-beaver-aero04.png\"\n      alt=\"Pic here\" style=\"width: 90%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/convergence/#Rotor-Wake","page":"Convergence","title":"Rotor Wake","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: E. J. Alvarez, 2022[1], and E. J. Alvarez and A. Ning, 2023[3]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: Continuation of Beaver propeller convergence study. Wake structure and flow field compared to experimental PIV measurements.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Takeaways: Even though the aerodynamic performance of the rotor (thrust, torque, and blade loading) is sufficiently converged with N_mathrmsheds=144 and n=50, higher refinement might be needed in order to properly time-resolve the vortical structure downstream of the rotor (which might be important when the rotor wake impinges on another surface). However, N_mathrmsheds=144 and n=50 is sufficient to capture the time-average velocity in the wake. This study shows that tip vortices and the inner vortex sheet can be resolved with as much granularity as desired by going to finer discretizations.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-beaver-wake00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <br><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-beaver-wake01.png\"\n      alt=\"Pic here\" style=\"width: 70%;\"/>\n  <br><br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-beaver-wake02.png\"\n      alt=\"Pic here\" style=\"width: 70%;\"/>\n\n  <br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/prowim_isolatedprop-vortvolslice_1-shortsmall00.gif\"\n      alt=\"Vid here\" style=\"width: 70%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/prowim_isolatedprop-vortslice_1-shortsmall00.gif\"\n      alt=\"Vid here\" style=\"width: 70%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/convergence/#Immersed-Vorticity","page":"Convergence","title":"Immersed Vorticity","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"We have noticed that in cases with strong wake interactions (e.g., a rotor wake impinging on a wing surface), the size of the particles used to immerse the surface vorticity can change the effects of the interaction. However, over the years we have discovered a heuristic that seems to converge to the right solution, independent of the nature of the problem: the size of the embedded particles needs to be about two orders of magnitude smaller than the relevant length scale.In FLOWUnsteady, there are three different core sizes related to the immersed vorticity:sigma_mathrmrotor, smoothing radius of the rotor bound vorticity (sigma_rotor_surf)\nsigma_mathrmLBV, smoothing radius of the lifting bound vorticity of wings (sigma_vlm_surf)\nsigma_mathrmTBV, smoothing radius of the trailing bound vorticity of wings (vlm_vortexsheet_sigma_tbv)Accordingly, whenever possible, we recommend choosing sigma-values close tosigma_mathrmrotor approx 001D, where D is the rotor diameter\nsigma_mathrmLBV approx 001b, where b is the wing span\nsigma_mathrmTBV approx 001t, where t is the thickness of the wingThe following is an excerpt from E. J. Alvarez, 2022,[1] Sec. 8.3., confirming the validity of the \"sigma approx 001ell\" heuristic:","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-sigma100rule-00.png\"\n      alt=\"Pic here\" style=\"width: 70%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-sigma100rule-01.png\"\n      alt=\"Pic here\" style=\"width: 70%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-sigma100rule-06.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <br>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-sigma100rule-02.png\"\n      alt=\"Pic here\" style=\"width: 70%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-sigma100rule-04.png\"\n      alt=\"Pic here\" style=\"width: 70%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/conv-sigma100rule-07.png\"\n      alt=\"Pic here\" style=\"width: 90%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"[1]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [PDF]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"[2]: E. J. Alvarez & A. Ning (2020), \"High-Fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design,\" AIAA Journal. [DOI] [PDF]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"[3]: E. J. Alvarez & A. Ning (2023), \"Meshless Large Eddy Simulation of Propeller-Wing Interactions Through the Reformulated Vortex Particle Method,\" Journal of Aircraft. [DOI] [PDF]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"[4]: J. Mehr, E. J. Alvarez, & A. Ning (2022), \"Interactional Aerodynamics Analysis of a Multi-Rotor Energy Kite,\" (in review).","category":"page"},{"location":"api/flowvpm-sfs/#SFS-Scheme","page":"SFS Scheme","title":"SFS Scheme","text":"","category":"section"},{"location":"api/flowvpm-sfs/","page":"SFS Scheme","title":"SFS Scheme","text":"FLOWUnsteady.vpm.SubFilterScale\nFLOWUnsteady.vpm.NoSFS\nFLOWUnsteady.vpm.ConstantSFS\nFLOWUnsteady.vpm.DynamicSFS\nFLOWUnsteady.vpm.clipping_backscatter\nFLOWUnsteady.vpm.control_directional\nFLOWUnsteady.vpm.control_magnitude\nFLOWUnsteady.vpm.dynamicprocedure_pseudo3level\nFLOWUnsteady.vpm.dynamicprocedure_sensorfunction\nFLOWUnsteady.vpm.Estr_direct\nFLOWUnsteady.vpm.Estr_fmm\nFLOWUnsteady.vpm.Estr_direct\nFLOWUnsteady.vpm.Estr_direct","category":"page"},{"location":"api/flowvpm-sfs/#FLOWVPM.SubFilterScale","page":"SFS Scheme","title":"FLOWVPM.SubFilterScale","text":"Implementation of calculations associated with subfilter-scale turbulence\n\nmodel.\n\nNOTE: Any implementation is expected to evaluate UJ and SFS terms of the particles which will be used by the time integration routine so make sure they are stored in the memory (see implementation of ConstantSFS as an example).\n\nNOTE2: Any control strategy is implemented as a function that returns true whenever the SFS model needs to be clipped. Subsequently, the model coefficient of the targeted particle will be turned to zero.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-sfs/#FLOWVPM.DynamicSFS","page":"SFS Scheme","title":"FLOWVPM.DynamicSFS","text":"Subfilter-scale scheme with an associated dynamic procedure for calculating\n\nthe model coefficient.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-sfs/#FLOWVPM.clipping_backscatter","page":"SFS Scheme","title":"FLOWVPM.clipping_backscatter","text":"Backscatter control strategy of SFS enstrophy production by clipping of the\n\nSFS model. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.control_directional","page":"SFS Scheme","title":"FLOWVPM.control_directional","text":"Directional control strategy of SFS enstrophy production forcing the model\n\nto affect only the vortex strength magnitude and not the vortex orientation. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.control_magnitude","page":"SFS Scheme","title":"FLOWVPM.control_magnitude","text":"Magnitude control strategy of SFS enstrophy production limiting the\n\nmagnitude of the forward scattering (diffussion) of the model. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.dynamicprocedure_pseudo3level","page":"SFS Scheme","title":"FLOWVPM.dynamicprocedure_pseudo3level","text":"Dynamic procedure for SFS model coefficient based on enstrophy and\n\nderivative balance between resolved and unresolved domain, numerically implemented through pseudo-three filtering levels. See 20210901 notebook for derivation.\n\nNOTES\n\nrlxf = Δ𝑡/𝑇 ≤ 1 is the relaxation factor of the Lagrangian average, where Δ𝑡\n\nis the time step of the simulation, and 𝑇 is the time length of the ensemble average.\n\nThe scaling constant becomes 1 for alpha_tau = 1 (but notice that the\n\nderivative approximation becomes zero at that point). Hence, the pseudo-three-level procedure converges to the two-level procedure for alpha_tau rightarrow 1**.\n\nThe scaling constant tends to zero when alpha_tau rightarrow 23. Hence,\n\nit can be used to arbitrarely attenuate the SFS contributions with alpha_tau rightarrow 23, or let it trully be a self-regulated dynamic procedure with alpha_tau rightarrow 1.\n\nalpha_tau\nshould not be made smaller than 23 as the constant becomes\n\nnegative beyond that point. This strains the assumption that sigma_tau is small enough to approximate the singular velocity field as mathbfu approx mathbftildeu, which now is only true if sigma is small enough.\n\n𝛼𝜏=0.999 ⇒ 3𝛼𝜏−2=0.997 𝛼𝜏=0.990 ⇒ 3𝛼𝜏−2=0.970 𝛼𝜏=0.900 ⇒ 3𝛼𝜏−2=0.700 𝛼𝜏=0.833 ⇒ 3𝛼𝜏−2=0.499 𝛼𝜏=0.750 ⇒ 3𝛼𝜏−2=0.250 𝛼𝜏=0.700 ⇒ 3𝛼𝜏−2=0.100 𝛼𝜏=0.675 ⇒ 3𝛼𝜏−2=0.025 𝛼𝜏=0.670 ⇒ 3𝛼𝜏−2=0.010 𝛼𝜏=0.667 ⇒ 3𝛼𝜏−2=0.001 𝛼𝜏=0.6667⇒ 3𝛼𝜏−2=0.0001\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.dynamicprocedure_sensorfunction","page":"SFS Scheme","title":"FLOWVPM.dynamicprocedure_sensorfunction","text":"Dynamic procedure for SFS model coefficient based on sensor function of\n\nenstrophy between resolved and unresolved domain, numerically implemented through a test filter. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.Estr_direct","page":"SFS Scheme","title":"FLOWVPM.Estr_direct","text":"Model of vortex-stretching SFS contributions evaluated with direct\n\nparticle-to-particle interactions. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.Estr_fmm","page":"SFS Scheme","title":"FLOWVPM.Estr_fmm","text":"Model of vortex-stretching SFS contributions evaluated with fast multipole\n\nmethod. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-run/#(5)-Run-Simulation","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"","category":"section"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"FLOWUnsteady.run_simulation","category":"page"},{"location":"api/flowunsteady-run/#FLOWUnsteady.run_simulation","page":"(5) Run Simulation","title":"FLOWUnsteady.run_simulation","text":"Run the FLOWUnsteady simulation sim in nsteps number of time steps.\n\nrun_simulation(\n\n    sim::Simulation,                    # Simulation object\n    nsteps::Int;                        # Total time steps in simulation\n\n    # -------- SIMULATION OPTIONS -----------------------------------------\n    Vinf            = (X, t)->zeros(3), # Freestream velocity\n    sound_spd       = 343,              # (m/s) speed of sound\n    rho             = 1.225,            # (kg/m^3) air density\n    mu              = 1.81e-5,          # (Pa*s) air dynamic viscosity\n    tquit           = Inf,              # (s) force quit the simulation at this time\n    rand_RPM        = false,            # (experimental) randomize RPM fluctuations\n\n    extra_runtime_function = (sim, PFIELD, T, DT; optargs...)->false,\n\n    # -------- SOLVERS OPTIONS --------------------------------------------\n    # Vortex particle method\n    max_particles   = Int(1e5),         # Maximum number of particles\n    max_static_particles = nothing,     # Maximum number of static particles (use `nothing` to automatically estimate it)\n    p_per_step      = 1,                # Particle sheds per time step\n    vpm_formulation = vpm.rVPM,         # VPM formulation (`vpm.rVPM` or `vpm.cVPM`)\n    vpm_kernel      = vpm.gaussianerf,  # VPM kernel (`vpm.gaussianerf` or `vpm.winckelmans`)\n    vpm_UJ          = vpm.UJ_fmm,       # VPM particle-to-particle interaction scheme (`vpm.UJ_fmm` or `vpm.UJ_direct`)\n    vpm_SFS         = vpm.SFS_none,     # VPM LES subfilter-scale model (`SFS_none`, `SFS_Cd_threelevel_nobackscatter`, `SFS_Cd_twolevel_nobackscatter`, or `SFS_Cs_nobackscatter`)\n    vpm_integration = vpm.rungekutta3,  # VPM time integration scheme (`vpm.euler` or `vpm.rungekutta3`)\n    vpm_transposed  = true,             # VPM transposed stretching scheme\n    vpm_viscous     = vpm.Inviscid(),   # VPM viscous diffusion scheme (`vpm.Inviscid()`, `vpm.CoreSpreading(nu, sgm0, zeta)`, or `vpm.ParticleStrengthExchange(nu)`)\n    vpm_fmm         = vpm.FMM(; p=4, ncrit=50, theta=0.4, phi=0.5), # VPM's FMM settings\n    vpm_relaxation  = vpm.pedrizzetti,  # VPM relaxation scheme (`vpm.norelaxation`, `vpm.correctedpedrizzetti`, or `vpm.pedrizzetti`)\n    vpm_surface     = true,             # Whether to include surfaces in the VPM through ASM/ALM\n\n    # Actuator surface/line model (ASM/ALM): VLM and blade elements\n    vlm_vortexsheet = false,            # Whether to spread surface circulation as a vortex sheet in the VPM (turns ASM on; ALM if false)\n    vlm_vortexsheet_overlap     = 2.125,# Overlap of particles that make the vortex sheet\n    vlm_vortexsheet_distribution= g_pressure, # Vorticity distribution of vortex sheet (`g_uniform`, `g_linear`, or `g_pressure`)\n    vlm_vortexsheet_sigma_tbv   = nothing, # Size of particles in trailing bound vortices (defaults to `sigma_vlm_surf` if not given)\n    vlm_rlx         = -1,               # VLM relaxation (>0.9 can cause divergence, <0.2 slows simulation too much, deactivated with <0)\n    vlm_init        = false,            # Initialize the first step with the VLM semi-infinite wake solution\n    hubtiploss_correction = vlm.hubtiploss_nocorrection, # Hub and tip loss correction of rotors (ignored in quasi-steady solver)\n\n    # Wake shedding\n    wake_coupled        = true,         # Couple VPM wake -> VLM solution\n    shed_unsteady       = true,         # Whether to shed vorticity from unsteady loading\n    unsteady_shedcrit   = 0.01,         # Criterion for unsteady-loading shedding\n    shed_starting       = false,        # Whether to shed starting vortex (only when `shed_unsteady=true`)\n    shed_boundarylayer  = false,        # (experimental) whether to shed vorticity from boundary layer of surfaces\n    boundarylayer_prescribedCd = 0.1,   # (experimental) prescribed Cd for boundary layer shedding used for wings\n    boundarylayer_d     = 0.0,          # (experimental) dipole width for boundary layer shedding\n    omit_shedding       = [],           # Indices of elements in `sim.vehicle.wake_system` on which omit shedding VPM particles\n\n    # Regularization of solvers\n    sigma_vlm_solver    = -1,           # Regularization of VLM solver (internal VLM-on-VLM)\n    sigma_vlm_surf      = -1,           # (REQUIRED!) Size of embedded particles in ASM/ALM wing surfaces (for VLM-on-VPM and VLM-on-Rotor)\n    sigma_rotor_surf    = -1,           # (REQUIRED!) Size of embedded particles in ALM blade surfaces (for Rotor-on-VPM, Rotor-on-VLM, and Rotor-on-Rotor)\n    sigmafactor_vpm     = 1.0,          # Core overlap of wake particles\n    sigmafactor_vpmonvlm = 1,           # (experimental) shrinks the particles by this factor when calculating VPM-on-VLM/Rotor induced velocities\n    sigma_vpm_overwrite = nothing,      # Overwrite core size of wake to this value (ignoring `sigmafactor_vpm`)\n\n    # -------- RESTART OPTIONS --------------------------------------------\n    restart_vpmfile     = nothing,      # VPM restart file to restart simulation\n\n    # -------- OUTPUT OPTIONS ---------------------------------------------\n    save_path       = nothing,          # Where to save simulation\n    run_name        = \"flowunsteadysim\",# Suffix of output files\n    create_savepath = true,             # Whether to create `save_path`\n    prompt          = true,             # Whether to prompt the user\n    verbose         = true,             # Enable verbose\n    v_lvl           = 0,                # Indentation level of verbose\n    verbose_nsteps  = 10,               # Verbose every this many steps\n    raisewarnings   = true,             # Whether to raise warnings\n    debug           = false,            # Output extra states for debugging\n    nsteps_save     = 1,                # Save vtks every this many steps\n    nsteps_restart  = -1,               # Save jlds every this many steps (restart files)\n    save_code       = \"\",               # Copy the source code in this path to `save_path`\n    save_horseshoes = false,            # Whether to output VLM horseshoes in VTKs\n    save_static_particles = true,       # Whether to save ASM/ALM embedded particles\n    save_wopwopin   = false,            # Generate input files for PSU-WOPWOP\n\n)\n\nEven though a bast number of settings are exposed to the user, the only required keyword arguments are sigma_vlm_surf and sigma_rotor_surf. Thus, running the simulation can be as simple as\n\nrun_simulation(sim::Simulation, nsteps::Int;\n                    sigma_vlm_surf = ..., sigma_rotor_surf = ...)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"compat: Extra Runtime Function\nextra_runtime_function is a function that is called at every time step after the state variables are updated and before outputting VTK files. The state variables of the simulation are passed to this function, giving the user complete freedom to modify the states of the simulation (e.g., add/remove particles, clip vortex strengths, re-orient the vehicle) or to do some extra computation (e.g., compute aerodynamic forces, create plots, write to files, etc).This function is expected be of the formextra_runtime_function(sim, pfield, t, dt; vprintln) -> Boolwhere sim is the FLOWUnsteady.Simulation object, pfield is the FLOWVPM.ParticleField, t is the current simulation time, dt is the length of the current time step, and vprintln(str, v_lvl) is a function for printing the verbose of the simulation (default to vprintln = (args...)->nothing if there is nothing to add to the verbose).The output of extra_runtime_function is a flag for breaking the simulation at the current time step, such that if it ever returns true, the simulation will immediately quit.","category":"page"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"compat: So, what is going on under the hood?\nFLOWUnsteady is simply a runtime function that is provided to FLOWVPM, as shown below. Hence, FLOWVPM (green block) is the solver that is actually driving the simulation. FLOWUnsteady (blue block) acts as a runtime function inside a VPM simulation that at each time step uses the solvers in the gray block to compute surface vorticities and adds particles to embed such vorticity in the flow field (thus implementing the actuator surface/line models developed in Alvarez' dissertation, Chapter 6).This workflow makes it very easy to couple more solvers in the simulation. For instance, a structural solver can be inserted as a runtime function (step 6 of the blue block) that deflects the geometry according to the aerodynamic loads, obtaining a full aeroelastic simulation.","category":"page"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"<center>\n  <img src=\"../../assets/images/flowchart/flowchart00.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-incidence/#Incidence-Sweep","page":"Incidence Sweep","title":"Incidence Sweep","text":"","category":"section"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//prowim_isoprop_J100-AOA200-00_3.gif\" alt=\"Vid here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"In simple cases like a propeller in cruise, steady and quasi-steady methods like blade element momentum theory can be as accurate as a fully unsteady simulation, and even faster. However, in more complex cases, quasi-steady solvers are far from accurate and a fully unsteady solver is needed. We now highlight one of such cases: the case of a propeller at an incidence angle.","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"A rotor operating at an incidence angle relative to the freestream experiences an unsteady loading due to the blade seeing a larger local velocity in the advancing side of the rotor and a smaller local velocity in the retreating side. This also causes a wake that is skewed. For this example we will run a sweep of simulations on a 4-bladed propeller operating at multiple incidence angles alpha (where alpha=0^circ is fully axial inflow, and alpha=90^circ is fully edgewise inflow).","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of Beaver propeller (four-bladed rotor, 9.34-inch diameter) at\n    various incidence angles.\n\n    This example uses the blade geometry reported in Sinnige & de Vries (2018),\n    \"Unsteady Pylon Loading Caused by Propeller-Slipstream Impingement for\n    Tip-Mounted Propellers,\" and replicates the experiment conducted by Sinnige\n    et al. (2019), \"Wingtip-Mounted Propellers: Aerodynamic Analysis of\n    Interaction Effects and Comparison with Conventional Layout.\"\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\ncase_name       = \"propeller-incidencesweep-example\"    # Name of this sweep case\n\nsave_path       = case_name                 # Where to save this sweep\noutput_runs     = [20]                      # Saves the VTK output of these AOAs for viz\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n\n# Rotor geometry\nrotor_file      = \"beaver.csv\"              # Rotor geometry\ndata_path       = uns.def_data_path         # Path to rotor database\npitch           = 0.0                       # (deg) collective pitch of blades\nCW              = false                     # Clock-wise rotation\nxfoil           = false                     # Whether to run XFOIL\nread_polar      = vlm.ap.read_polar2        # What polar reader to use\n\n# Discretization\nn               = 20                        # Number of blade elements per blade\nr               = 1/5                       # Geometric expansion of elements\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n\n# Operating conditions\nAOAs            = 0:4:20                    # (deg) incidence angles to evaluate\nmagVinf         = 40.0                      # (m/s) freestream velocity\nJ               = 0.9                       # Advance ratio Vinf/(nD)\nRPM             = magVinf / (2*R/60) / J    # RPM\n\nrho             = 1.225                     # (kg/m^3) air density\nmu              = 1.79e-5                   # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\n\n\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number\nMatip           = 2*pi*RPM/60*R / speedofsound      # Tip Mach number\n\nprintln(\"\"\"\n    RPM:    $(RPM)\n    Vinf:   $(magVinf) m/s\n    Matip:  $(round(Matip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n\"\"\")\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n\n# Time parameters\nnrevs           = 4                         # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = nrevs*nsteps_per_rev      # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\np_per_step      = 2                         # Sheds per time step\nshed_starting   = true                      # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nmax_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles\n\n# Regularization\nsigma_rotor_surf= R/40                      # Rotor-on-VPM smoothing radius\n# sigma_rotor_surf= R/80\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\n\n# Rotor solver\nvlm_rlx         = 0.7                       # VLM relaxation <-- this also applied to rotors\n                                            # Prandtl's tip correction with a strong hub\nhubtiploss_correction = ( (0.75, 10, 0.5, 0.05), (1, 1, 1, 1.0) ) # correction up to r/R = 0.35\n\nif VehicleType == uns.QVLMVehicle           # Mute colinear warnings if quasi-steady solver\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate rotor\nrotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                        n=n, CW=CW, blade_r=r,\n                                        altReD=[RPM, J, mu/rho],\n                                        xfoil=xfoil,\n                                        read_polar=read_polar,\n                                        data_path=data_path,\n                                        verbose=true,\n                                        verbose_xfoil=false,\n                                        plot_disc=true\n                                        );\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Rotor\", rotor)\n\nrotors = [rotor];                           # Defining this rotor as its own system\nrotor_systems = (rotors, );                 # All systems of rotors\n\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle\n    vlm.addwing(wake_system, \"Rotor\", rotor)\nend\n\nvehicle = VehicleType(   system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = zeros(3)\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = (RPMcontrol, )                       # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\n\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n# ------------- RUN AOA SWEEP --------------------------------------------------\n\n# Create path where to save sweep\nuns.gt.create_path(save_path, true)\n\nfor AOA in AOAs\n\n    println(\"\\n\\nRunning AOA = $(AOA)\")\n\n    Vinf(X, t)      = magVinf*[cosd(AOA), sind(AOA), 0] # (m/s) freestream velocity vector\n\n    # ------------- 4) MONITOR DEFINITION ---------\n    monitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                                t_scale=RPM/60,\n                                                t_lbl=\"Revolutions\",\n                                                save_path=save_path,\n                                                run_name=\"AOA$(ceil(Int, AOA*100))\",\n                                                disp_conv=false\n                                                )\n\n    # ------------- 5) RUN SIMULATION -------------\n    println(\"\\tRunning simulation...\")\n\n    save_vtks = AOA in output_runs ? save_path*\"-AOA$(ceil(Int, AOA*100))\" : nothing\n\n    uns.run_simulation(simulation, nsteps;\n                        # ----- SIMULATION OPTIONS -------------\n                        Vinf=Vinf,\n                        rho=rho, mu=mu, sound_spd=speedofsound,\n                        # ----- SOLVERS OPTIONS ----------------\n                        p_per_step=p_per_step,\n                        max_particles=max_particles,\n                        sigma_vlm_surf=sigma_rotor_surf,\n                        sigma_rotor_surf=sigma_rotor_surf,\n                        sigma_vpm_overwrite=sigma_vpm_overwrite,\n                        vlm_rlx=vlm_rlx,\n                        hubtiploss_correction=hubtiploss_correction,\n                        shed_unsteady=shed_unsteady,\n                        shed_starting=shed_starting,\n                        extra_runtime_function=monitor_rotor,\n                        # ----- OUTPUT OPTIONS ------------------\n                        save_path=save_vtks,\n                        run_name=\"singlerotor\",\n                        v_lvl=1, verbose_nsteps=24\n                        );\nend\n","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~15 minutes on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"Check examples/propeller/propeller_incidence.jl to postprocess and plot the results as shown below.","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-incidencesweep-example.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"info: Paraview visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...). To open in Paraview: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"examples/tetheredwing/#Tethered-Wing","page":"Tethered Wing","title":"Tethered Wing","text":"","category":"section"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//tetheredwing-example-00small.gif\" alt=\"Vid here\" style=\"width: 80%;\"/>\n</center>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"In this example we extend the simple wing case to fly a circular path. This simulates a kite tethered to the ground with a crosswind that causes it to fly in circles. The kite effectively acts as a turbine extracting energy from the wind to sustain flight, which is the basis for the field of airborne wind energy.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"This simulation exemplify the following features:","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"Translating and re-orienting the initial position of the vehicle using   FLOWVLM.setcoordsystem\nDefining a uns.KinematicManeuver object that prescribes the   kinematics of a circular path\nCustomizing the wing monitor (uns.generate_monitor_wing) to   compute and plot forces decomposed in arbitrary directions (in this   case, following the orientation of the vehicle along the circular path)\nMonitoring the vehicle state variables with   uns.generate_monitor_statevariables","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"#=##############################################################################\n# DESCRIPTION\n    Kite flying in a circular path with crosswind while tethered to the ground.\n    The kite is the same 45° swept-back wing from the previous example.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Feb 2023\n  * Last updated    : Feb 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\nrun_name        = \"tetheredwing-example\"    # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n# Wing description\nb               = 2.489                     # (m) span length\nar              = 5.0                       # Aspect ratio b/c_tip\ntr              = 1.0                       # Taper ratio c_tip/c_root\ntwist_root      = 0.0                       # (deg) twist at root\ntwist_tip       = 0.0                       # (deg) twist at tip\nlambda          = 45.0                      # (deg) sweep\ngamma           = 0.0                       # (deg) dihedral\n\n# Discretization\nn               = 50                        # Number of spanwise elements per side\nr               = 10.0                      # Geometric expansion of elements\ncentral         = false                     # Whether expansion is central\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n# Freestream\nmagVinf         = 5.0                       # (m/s) freestream velocity\nmagVeff         = 49.7                      # (m/s) vehicle effective velocity\nAOAeff          = 4.2                       # (deg) vehicle effective AOA\nrho             = 0.93                      # (kg/m^3) air density\nqinf            = 0.5*rho*magVeff^2         # (Pa) static pressure\n\nVinf(X, t)      = magVinf*[1, 0, 0]         # Freestream function\n\n# Circular path\nR               = 3.0*b                     # (m) radius of circular path\nmagVvehicle     = sqrt(magVeff^2 - magVinf^2) # (m/s) vehicle velocity\nomega           = magVvehicle/R             # (rad/s) angular velocity\nalpha           = AOAeff - atand(magVinf, magVvehicle) # (deg) vehicle pitch angle\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Time parameters\nnrevs           = 2.50                      # Revolutions to resolve\nnsteps_per_rev  = 144                       # Number of time steps per revolution\n\nttot            = nrevs / (omega/(2*pi))    # (s) total simulation time\nnsteps          = ceil(Int, nrevs * nsteps_per_rev) # Number of time steps\n\n# VLM and VPM parameters\np_per_step      = 4                         # Number of particle sheds per time step\n\nsigma_vlm_solver= -1                        # VLM-on-VLM smoothing radius (deactivated with <0)\nsigma_vlm_surf  = 0.05*b                    # VLM-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * magVeff * (ttot/nsteps)/p_per_step\n\nshed_starting   = true                      # Whether to shed starting vortex\nvlm_rlx         = 0.7                       # VLM relaxation\n\n# NOTE: In some cases the starting vortex can cause numerical instabilities at\n#       the beginning of the simulation. If so, consider omitting shedding of\n#       the starting vortex with `shed_starting=false`, or relax the VLM solver\n#       with `0.2 < vlm_rlx < 0.9`\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate wing\nwing = vlm.simpleWing(b, ar, tr, twist_root, lambda, gamma;\n                        twist_tip=twist_tip, n=n, r=r, central=central);\n\n# Rotate wing to pitch\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0.0, -alpha, 0.0)   # New orientation\nvlm.setcoordsystem(wing, O, Oaxis)\n\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Wing\", wing)\n\nvlm_system = system;                        # System solved through VLM solver\nwake_system = system;                       # System that will shed a VPM wake\n\nvehicle = uns.VLMVehicle(   system;\n                            vlm_system=vlm_system,\n                            wake_system=wake_system\n                         );\n\n # Rotate vehicle to be perpendicular to crosswind\n # and translate it to start at (x, y, z) = (0, R, 0)\n O = [0, R, 0]                                      # New position\n Oaxis = uns.gt.rotation_matrix2(0.0, -90, 0.0)     # New orientation\n\n vlm.setcoordsystem(system, O, Oaxis)\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n\n# Translational velocity of vehicle over time\nfunction Vvehicle(t)\n\n    # NOTE: This function receives a non-dimensional time `t` (with t=0 being\n    #       the start of simulation and t=1 the end), and returns a\n    #       non-dimensional velocity vector. This vector will later be scaled\n    #       by `Vref`.\n\n    Vx = 0\n    Vy = -sin(2*pi*nrevs*t)\n    Vz = cos(2*pi*nrevs*t)\n\n    return [0, Vy, Vz]\nend\n\n# Angle of the vehicle over time\nfunction anglevehicle(t)\n\n    # NOTE: This function receives the non-dimensional time `t` and returns the\n    #       attitude of the vehicle (a vector with inclination angles with\n    #       respect to each axis of the global coordinate system)\n\n    return [0, 0, 360*nrevs*t]\nend\n\nangle = ()                                  # Angle of each tilting system (none)\nRPM = ()                                    # RPM of each rotor system (none)\n\nmaneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time.\n#       `angle` defines the tilting angle of each tilting system over time (none\n#       in this case). `RPM` defines the RPM of each rotor system over time\n#       (none in this case).\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n\n\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = magVvehicle                          # Reference velocity to scale maneuver by\nRPMref = 0.0                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\n                                            # Maximum number of particles\nmax_particles = (nsteps+1)*(vlm.get_m(vehicle.vlm_system)*(p_per_step+1) + p_per_step)\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\nfigs, figaxs = [], []                       # Figures generated by monitors\nimport FLOWUnsteady: @L_str                 # Macro for writing LaTeX labels\n\n# Generate function that computes aerodynamic forces\ncalc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                    add_parasiticdrag=true,\n                                    add_skinfriction=true,\n                                    airfoilpolar=\"xf-rae101-il-1000000.csv\"\n                                    )\n\n# Time-varying directions used to decompose the aerodynamic force\nN_dir(t) = [1, 0, 0]                        # Direction of normal force\nT_dir(t) = [0, sin(omega*t), -cos(omega*t)] # Direction of tangent force\nS_dir(t) = uns.cross(N_dir(t), T_dir(t))    # Spanwise direction\n\nX_offset(t) = system.O                      # Reference wing origin (for calculating spanwise position)\nS_proj(t)   = S_dir(t)                      # Reference span direction (for calculating spanwise position)\n\n# Generate wing monitor\nmonitor_wing = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=N_dir,\n                                            D_dir=T_dir,\n                                            X_offset=X_offset,\n                                            S_proj=S_proj,\n                                            CL_lbl=L\"Normal force $C_n$\",\n                                            CD_lbl=L\"Tangent force $C_t$\",\n                                            cl_lbl=L\"Sectional normal force $c_n$\",\n                                            cd_lbl=L\"Sectional tangent force $c_t$\",\n                                            cl_ttl=\"Normal force distribution\",\n                                            cd_ttl=\"Tangent force distribution\",\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"wing monitor\",\n                                            );\n\n# Generate monitor of state variables\nmonitor_states = uns.generate_monitor_statevariables(; save_path=save_path,\n                                                       run_name=run_name,\n                                                       out_figs=figs,\n                                                       out_figaxs=figaxs,\n                                                       nsteps_savefig=10)\n\nmonitors = uns.concatenate(monitor_wing, monitor_states)\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    sigma_vlm_solver=sigma_vlm_solver,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_vlm_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    vlm_rlx=vlm_rlx,\n                    shed_starting=shed_starting,\n                    extra_runtime_function=monitors,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_Wing_vlm...vtk\")\n    files *= \";\"*run_name*\"_pfield...xmf;\"\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~20 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (n and steps) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"As the simulation runs, you will see the monitor shown below plotting the state variables of the vehicle. The components of both velocity and position follow a sinusoidal function, which is consistent with the circular path, while the angular velocity is constant.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//tetheredwing-example-statemonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"The force monitor (shown below) plots the force components that are normal and tangential to the plane of rotation. Notice that the tangential force is negative, which is equivalent to having a negative drag, meaning that the vehicle is actually being propelled by the crosswind. Also notice that the forces are perturbed every time it completes a revolution. This is due to encountering the starting point of the wake that is slowly traveling downstream. It takes a couple revolutions for the forces to converge once the wake has been fully deployed.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//tetheredwing-example-wingmonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"info: Disable monitors to speed up simulation\nFor unknown reasons, the simulation oftentimes halts in between time steps while plotting the monitors. This slows down the overall simulation time, sometimes taking up to 2x longer. If you are not particularly interested in the plots of the monitors, you can disable the plots passing the keyword disp_plot=false to each monitor generator.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"info: ParaView visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"examples/vahana-run/#vahanarun","page":"Run Simulation","title":"Run Simulation","text":"","category":"section"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"A mid fidelity resolution makes the computational cost tractable and possible to be run the full maneuver (30 seconds of real time) overnight on a laptop computer. This is a video of the full maneuver in mid fidelity:","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/d__wNtRIBY8?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"With a finer temporal and spatial resolution, it becomes impractical to resolve the entire maneuver, and instead we recommend simulating one fragment of the maneuver at a time. For instance, here is a high-fidelity simulation of the transition from hover to cruise:","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/-6aR37Z6hig?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"As a reference, here are the parameters that we have used for the mid and high fidelity simulations:","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"Parameter Mid fidelity High fidelity Description\nn_factor 1 4 Factor that controls the level of discretization of wings and blade surfaces\nnsteps 4*5400 8*5400 Time steps for the entire maneuver\nt_start 0 0.20*ttot (s) start simulation at this point in time\nt_quit ttot 0.30*ttot (s) end imulation at this point in time\nlambda_vpm 2.125 1.5*2.125 VPM core overlap\nvlm_vortexsheet false true Whether to spread the wing surface vorticity as a vortex sheet\nvpm_integration vpm.euler vpm.rungekutta3 VPM time integration scheme","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"<br>","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"Along the way, in this simulation we exemplify the following advanced features:","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"Defining a variable pitch for rotors between hover and cruise\nUsing the actuator surface model for wing surfaces\nDefining a wake treatment that speeds up the   simulation by removing particles that can be neglected","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"<br>","category":"page"},{"location":"examples/vahana-run/","page":"Run Simulation","title":"Run Simulation","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of eVTOL transition maneuver of a tandem tilt-wing multirotor\n    aircraft. The aircraft configuration resembles the Vahana eVTOL aircraft\n    but with tilt, stacked, and variable-pitch rotors.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Feb 2021\n  * Last updated    : Feb 2021\n  * License         : MIT\n=###############################################################################\n\n\n\nimport FLOWUnsteady as uns\nimport FLOWUnsteady: vlm, vpm, gt, Im\n\ninclude(joinpath(uns.examples_path, \"vahana\", \"vahana_vehicle.jl\"))\ninclude(joinpath(uns.examples_path, \"vahana\", \"vahana_maneuver.jl\"))\ninclude(joinpath(uns.examples_path, \"vahana\", \"vahana_monitor.jl\"))\n\nrun_name        = \"vahana\"                  # Name of this simulation\nsave_path       = \"vahana-example\"          # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\nn_factor        = 1                         # Discretization factor\nadd_wings       = true                      # Whether to include wings\nadd_rotors      = true                      # Whether to include rotors\n\n# Reference lengths\nR               = 0.75                      # (m) reference blade radius\nb               = 5.86                      # (m) reference wing span\nchord           = b/7.4                     # (m) reference wing chord\nthickness       = 0.04*chord                # (m) reference wing thickness\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n# Maneuver settings\nVcruise         = 15.0                      # (m/s) cruise speed (reference)\nRPMh_w          = 600.0                     # RPM of main-wing rotors in hover (reference)\nttot            = 30.0                      # (s) total time to perform maneuver\n\nuse_variable_pitch = true                   # Whether to use variable pitch in cruise\n\n# Freestream\nVinf(X,t)       = 1e-5*[1, 0, -1]           # (m/s) freestream velocity (if 0 the solvers can become unstable)\nrho             = 1.225                     # (kg/m^3) air density\nmu              = 1.81e-5                   # (kg/ms) air dynamic viscosity\n\n# NOTE: Use these parameters to start and end the simulation at any arbitrary\n#       point along the eVTOL maneuver (tstart=0 and tquit=ttot will simulate\n#       the entire maneuver, tstart=0.20*ttot will start it at the beginning of\n#       the hover->cruise transition)\ntstart          = 0.00*ttot                 # (s) start simulation at this point in time\ntquit           = 1.00*ttot                 # (s) end simulation at this point in time\n\nstart_kinmaneuver = true                    # If true, it starts the maneuver with the\n                                            # velocity and angles of tstart.\n                                            # If false, starts with velocity=0\n                                            # and angles as initiated by the geometry\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n# VehicleType     = uns.QVLMVehicle         # Quasi-steady solver\n\n# Time parameters\nnsteps          = 4*5400                    # Time steps for entire maneuver\ndt              = ttot/nsteps               # (s) time step\n\n# VPM particle shedding\np_per_step      = 5                         # Sheds per time step\nshed_starting   = false                     # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nunsteady_shedcrit = 0.001                   # Shed unsteady loading whenever circulation\n                                            #  fluctuates by more than this ratio\n\n# Regularization of embedded vorticity\nsigma_vlm_surf  = b/400                     # VLM-on-VPM smoothing radius\nsigma_rotor_surf= R/20                      # Rotor-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite         = lambda_vpm * (2*pi*RPMh_w/60*R + Vcruise)*dt / p_per_step\nsigmafactor_vpmonvlm        = 1             # Shrink particles by this factor when\n                                            #  calculating VPM-on-VLM/Rotor induced velocities\n\n# Rotor solver\nvlm_rlx                     = 0.2           # VLM relaxation <-- this also applied to rotors\nhubtiploss_correction       = vlm.hubtiploss_correction_prandtl # Hub and tip correction\n\n# Wing solver: actuator surface model (ASM)\nvlm_vortexsheet             = false         # Whether to spread the wing surface vorticity as a vortex sheet (activates ASM)\nvlm_vortexsheet_overlap     = 2.125         # Overlap of the particles that make the vortex sheet\nvlm_vortexsheet_distribution= uns.g_pressure# Distribution of the vortex sheet\n# vlm_vortexsheet_sigma_tbv = thickness*chord / 100  # Size of particles in trailing bound vortices\nvlm_vortexsheet_sigma_tbv   = sigma_vpm_overwrite\n                                            # How many particles to preallocate for the vortex sheet\nvlm_vortexsheet_maxstaticparticle = vlm_vortexsheet==false ? nothing : 6000000\n\n# Wing solver: force calculation\nKJforce_type                = \"regular\"     # KJ force evaluated at middle of bound vortices_vortexsheet also true)\ninclude_trailingboundvortex = false         # Include trailing bound vortices in force calculations\n\ninclude_unsteadyforce       = true          # Include unsteady force\nadd_unsteadyforce           = false         # Whether to add the unsteady force to Ftot or to simply output it\n\ninclude_parasiticdrag       = true          # Include parasitic-drag force\nadd_skinfriction            = true          # If false, the parasitic drag is purely parasitic, meaning no skin friction\ncalc_cd_from_cl             = false         # Whether to calculate cd from cl or effective AOA\nwing_polar_file             = \"xf-n0012-il-500000-n5.csv\"    # Airfoil polar for parasitic drag\n\n\n# VPM solver\n# vpm_integration = vpm.rungekutta3         # VPM temporal integration scheme\nvpm_integration = vpm.euler\n\nvpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme\n# vpm_viscous   = vpm.CoreSpreading(-1, -1, vpm.zeta_fmm; beta=100.0, itmax=20, tol=1e-1)\n\n# vpm_SFS       = vpm.SFS_none              # VPM LES subfilter-scale model\nvpm_SFS         = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;\n                                  alpha=0.999, maxC=1.0,\n                                  clippings=[vpm.clipping_backscatter],\n                                  controls=[vpm.control_directional, vpm.control_magnitude])\n\nif VehicleType == uns.QVLMVehicle\n    # Mute warnings regarding potential colinear vortex filaments. This is\n    # needed since the quasi-steady solver will probe induced velocities at the\n    # lifting line of the blade\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\n\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nvehicle = generate_vahana_vehicle(; xfoil       = false,\n                                    n_factor    = n_factor,\n                                    add_wings   = add_wings,\n                                    add_rotors  = add_rotors,\n                                    VehicleType = VehicleType,\n                                    run_name    = \"vahana\"\n                                    )\n\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\nmaneuver = generate_maneuver_vahana(; add_rotors=add_rotors)\n\n# Plot maneuver before running the simulation\nuns.plot_maneuver(maneuver)\n\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n# Reference parameters\nVref = Vcruise                              # Reference velocity to scale maneuver by\nRPMref = RPMh_w                             # Reference RPM to scale maneuver by\n\n# Initial conditions\nt0 = tstart/ttot*start_kinmaneuver          # Time at start of simulation\nVinit = Vref*maneuver.Vvehicle(t0)          # Initial vehicle velocity\nWinit = pi/180 * (maneuver.anglevehicle(t0+1e-12)- maneuver.anglevehicle(t0))/(ttot*1e-12) # Initial angular velocity\n\n# Define simulation\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                            Vinit=Vinit, Winit=Winit, t=tstart);\n\n# Maximum number of particles (for pre-allocating memory)\nmax_particles = ceil(Int, (nsteps+2)*(2*vlm.get_m(vehicle.wake_system)*(p_per_step+1) + p_per_step) )\nmax_particles = tquit != Inf ? ceil(Int, max_particles*(tquit-tstart)/ttot) : max_particles\nmax_particles = min(10000000, max_particles)\nmax_particles = VehicleType==uns.QVLMVehicle ? 10000 : max_particles\n\n\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\n# ------------- Routine for force calculation on wings\nforces = []\n\n# Calculate Kutta-Joukowski force\nkuttajoukowski = uns.generate_aerodynamicforce_kuttajoukowski(KJforce_type,\n                                sigma_vlm_surf, sigma_rotor_surf,\n                                vlm_vortexsheet, vlm_vortexsheet_overlap,\n                                vlm_vortexsheet_distribution,\n                                vlm_vortexsheet_sigma_tbv;\n                                vehicle=vehicle)\npush!(forces, kuttajoukowski)\n\n\n# Force due to unsteady circulation\nif include_unsteadyforce\n    unsteady(args...; optargs...) = uns.calc_aerodynamicforce_unsteady(args...; add_to_Ftot=add_unsteadyforce, optargs...)\n\n    push!(forces, unsteady)\nend\n\n# Parasatic-drag force (form drag and skin friction)\nif include_parasiticdrag\n    parasiticdrag = uns.generate_aerodynamicforce_parasiticdrag(wing_polar_file;\n                                                            calc_cd_from_cl=calc_cd_from_cl,\n                                                            add_skinfriction=add_skinfriction)\n    push!(forces, parasiticdrag)\nend\n\n\n# Stitch all the forces into one function\nfunction calc_aerodynamicforce_fun(vlm_system, args...; per_unit_span=false, optargs...)\n\n    # Delete any previous force field\n    fieldname = per_unit_span ? \"ftot\" : \"Ftot\"\n    if fieldname in keys(vlm_system.sol)\n        pop!(vlm_system.sol, fieldname)\n    end\n\n    Ftot = nothing\n\n    for force in forces\n        Ftot = force(vlm_system, args...; per_unit_span=per_unit_span, optargs...)\n    end\n\n    return Ftot\nend\n\n\n# Extra options for generation of wing monitors\nwingmonitor_optargs = (\n                        include_trailingboundvortex=include_trailingboundvortex,\n                        calc_aerodynamicforce_fun=calc_aerodynamicforce_fun\n                      )\n\n# ------------- Create monitors\nmonitors = generate_monitor_vahana(vehicle, rho, RPMref, nsteps,\n                                         save_path, Vinf;\n                                         add_wings=add_wings,\n                                         wingmonitor_optargs=wingmonitor_optargs)\n\n\n\n\n# ------------- INTERMEDIATE STEP BEFORE RUN ------------------------------------\n\n# ------------- Define function for variable pitch\n\n# Original blade twists\norg_theta = [\n                [\n                    deepcopy(rotor._theta) for (ri, rotor) in enumerate(rotors)\n                ]\n                for (si, rotors) in enumerate(simulation.vehicle.rotor_systems)\n            ]\n\n# End time of each stage\n#  Stage 1: [0, t1]  -> Take off\n#  Stage 2: [t1, t2] -> Transition\n#  Stage 3: [t2, t3] -> Cruise\n#  Stage 4: [t3, t4] -> Transition\n#  Stage 5: [t4, 1]  -> Landing\nt1, t2, t3, t4 = 0.2, 0.3, 0.5, 0.6\n\n# Pitch at each stage\npitch_takeoff  = 0\npitch_cruise   = 35\npitch_landing  = 0\n\n# Function for smoothly transitioning pitch between stages\ncollective(tstr) =  tstr < t1 ? pitch_takeoff :\n                    tstr < t2 ? pitch_takeoff + (pitch_cruise-pitch_takeoff)*(tstr-t1)/(t2-t1) :\n                    tstr < t3 ? pitch_cruise :\n                    tstr < t4 ? pitch_cruise + (pitch_landing-pitch_cruise)*(tstr-t3)/(t4-t3) :\n                                pitch_landing\n\nfunction variable_pitch(sim, args...; optargs...)\n\n    if !use_variable_pitch\n        return false\n    end\n\n    tstr = sim.t/sim.ttot               # Non-dimensional time\n\n    for (si, rotors) in enumerate(sim.vehicle.rotor_systems)\n        for (ri, rotor) in enumerate(rotors)\n\n            if si==1                            # Main wing rotors\n\n                # Restore original twist distribution\n                rotor._theta .=  org_theta[si][ri]\n\n                # Add collective pitch\n                rotor._theta .+= 1.0 * (-1)^(rotor.CW)*collective(tstr)\n\n            elseif si==2                        # Stacked upper rotors\n                nothing\n\n            elseif si==3                        # Stacked lower rotors\n                nothing\n\n            elseif si==4                        # Tandem-wing rotors\n                rotor._theta .=  org_theta[si][ri]\n                rotor._theta .+= 1.25 * (-1)^(rotor.CW)*collective(tstr)\n\n            end\n\n        end\n    end\n\n    return false\nend\n\n\n# ------------- Define wake treatment\n\n# Remove by particle strength\n# (remove particles neglibly faint, remove blown up)\nrmv_strngth = 2*2/p_per_step * dt/(30/(4*5400))         # Reference strength\nminmaxGamma = rmv_strngth*[0.0001, 0.05]                # Strength bounds (removes particles outside of these bounds)\nwake_treatment_strength = uns.remove_particles_strength( minmaxGamma[1]^2, minmaxGamma[2]^2; every_nsteps=1)\n\n# Remove by particle size\n# (remove particle nearly singular, remove negligibly smeared)\nminmaxsigma = sigma_vpm_overwrite*[0.1, 5]              # Size bounds (removes particles outside of these bounds)\nwake_treatment_sigma = uns.remove_particles_sigma( minmaxsigma[1], minmaxsigma[2]; every_nsteps=1)\n\n# Remove by distance\n# (remove particles outside of the computational domain of interest, i.e., far from vehicle)\nwake_treatment_sphere = uns.remove_particles_sphere((1.25*b)^2, 1; Xoff=[4.0, 0, 0])\n\n# Concatenate all wake treatments\nwake_treatment = uns.concatenate(wake_treatment_sphere, wake_treatment_strength, wake_treatment_sigma)\n\n\n\n# ------------- Define runtime function: monitors + variable pitch + wake treatment\nruntime_function = uns.concatenate(wake_treatment, monitors, variable_pitch)\n\n\n\n\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\n\n# Run simulation\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho, mu=mu, tquit=tquit,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    max_static_particles=vlm_vortexsheet_maxstaticparticle,\n                    vpm_integration=vpm_integration,\n                    vpm_viscous=vpm_viscous,\n                    vpm_SFS=vpm_SFS,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_rotor_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    sigmafactor_vpmonvlm=sigmafactor_vpmonvlm,\n                    vlm_vortexsheet=vlm_vortexsheet,\n                    vlm_vortexsheet_overlap=vlm_vortexsheet_overlap,\n                    vlm_vortexsheet_distribution=vlm_vortexsheet_distribution,\n                    vlm_vortexsheet_sigma_tbv=vlm_vortexsheet_sigma_tbv,\n                    vlm_rlx=vlm_rlx,\n                    hubtiploss_correction=hubtiploss_correction,\n                    shed_starting=shed_starting,\n                    shed_unsteady=shed_unsteady,\n                    unsteady_shedcrit=unsteady_shedcrit,\n                    extra_runtime_function=runtime_function,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    save_wopwopin=true,  # <--- Generates input files for PSU-WOPWOP noise analysis\n                    );","category":"page"},{"location":"api/flowunsteady-maneuver/#(2)-Maneuver-Definition","page":"(2) Maneuver Definition","title":"(2) Maneuver Definition","text":"","category":"section"},{"location":"api/flowunsteady-maneuver/","page":"(2) Maneuver Definition","title":"(2) Maneuver Definition","text":"FLOWUnsteady.KinematicManeuver\nFLOWUnsteady.DynamicManeuver\n\nFLOWUnsteady.plot_maneuver\nFLOWUnsteady.visualize_kinematics","category":"page"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.KinematicManeuver","page":"(2) Maneuver Definition","title":"FLOWUnsteady.KinematicManeuver","text":"KinematicManeuver{N, M}(angle, RPM, Vvehicle, anglevehicle)\n\nA vehicle maneuver that prescribes the kinematics of the vehicle through the functions Vvehicle and anglevehicle. Control inputs to each tilting and rotor systems are given by the collection of functions angle and RPM, respectively.\n\nARGUMENTS\n\nangle::NTuple{N, Function} where angle[i](t) returns the angles       [Ax, Ay, Az] (in degrees) of the i-th tilting system at time t (t is       nondimensionalized by the total time of the maneuver, from 0 to 1,       beginning to end).\nRPM::NTuple{M, Function} where RPM[i](t) returns the normalized RPM of       the i-th rotor system at time t. These RPM values are normalized by       an arbitrary RPM value (usually RPM in hover or cruise).\nVvehicle::Function where Vvehicle(t) returns the normalized vehicle       velocity [Vx, Vy, Vz] at the normalized time t. The velocity is       normalized by a reference velocity (typically, cruise velocity).\nanglevehicle::Function where anglevehicle(t) returns the angles       [Ax, Ay, Az] (in degrees) of the vehicle relative to the global       coordinate system at the normalized time t.\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.DynamicManeuver","page":"(2) Maneuver Definition","title":"FLOWUnsteady.DynamicManeuver","text":"DynamicManeuver{N, M}(angle, RPM)\n\nA vehicle maneuver that automatically couples the kinematics of the vehicle with the forces and moments, resulting in a fully dynamic simulation. Control inputs to each tilting and rotor systems are given by the collection of functions angle and RPM, respectively.\n\nNOTE: This methods has not been implemented yet, but it may be developed in future versions of FLOWunsteady.\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.plot_maneuver","page":"(2) Maneuver Definition","title":"FLOWUnsteady.plot_maneuver","text":"plot_maneuver(maneuver::KinematicManeuver; ti::Real=0, tf::Real=1,\n                            vis_nsteps=300, figname=\"maneuver\", tstages=[])\n\nPlots the kinematics and controls of a KinematicManeuver.\n\n(Image: image) (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.visualize_kinematics","page":"(2) Maneuver Definition","title":"FLOWUnsteady.visualize_kinematics","text":"visualize_kinematics(sim::Simulation, nsteps::Int, save_path::String)\n\nSteps the vehicle through the prescribed kinematics, outputting VTK files of the vehicle at every time step. Use this to visualize and debug a maneuver.\n\nnsteps is the number of time steps in which to perform the maneuver. save_path is the path where to save the VTK files.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-misc/#miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"api/flowunsteady-postprocessing-misc/","page":"Miscellaneous","title":"Miscellaneous","text":"  FLOWUnsteady.postprocess_statistics\n  FLOWUnsteady.postprocess_bladeloading","category":"page"},{"location":"api/flowunsteady-postprocessing-misc/#FLOWUnsteady.postprocess_statistics","page":"Miscellaneous","title":"FLOWUnsteady.postprocess_statistics","text":"postprocess_statistics(read_path, save_path, nums;\n                        # PROCESSING OPTIONS\n                        idens           = [\"\"],     # Use this to agglomerate multiple simulations\n                        to_exclude      = [],       # Exclude file names containing these words\n                        cyl_axial_dir   = nothing,  # Calculate cylindrical statistics if given an axial axis (vector)\n                        # OUTPUT OPTIONS\n                        prompt=true, debug=false,\n                        verbose=true, v_lvl=0)\n\nCalculate statistics of the simulation VTK outputs over a given range of time steps given by nums. Use this to calculate, for instance, the mean load distribution and fluctuations on wings and rotors.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-misc/#FLOWUnsteady.postprocess_bladeloading","page":"Miscellaneous","title":"FLOWUnsteady.postprocess_bladeloading","text":"postprocess_bladeloading(read_path;\n                            O           = zeros(3),     # Rotor center\n                            rotor_axis  = [-1, 0, 0],   # Rotor centerline axis\n                            Ftot_axis   = nothing,      # Use a different centerline axis for forces if given\n                            filename    = \"singlerotor_Rotor_Blade1_vlm-statistics.vtk\", # File name\n                            fieldsuff   = \"-mean\"       # Suffix of fields \"Gamma\" and \"Ftot\", if any\n                            )\n\nRead a blade VTK file filename under directory read_path and returns the circulation and force components of the load distribution along the blade.\n\nReturn: rs, Gamma, Np, Tp, Rp, Zhat, Rhat, That, Ftot\n\n\n\n\n\n","category":"function"}]
}
